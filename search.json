[{"title":"JS中的this与相关函数","url":"/study/JS%E4%B8%AD%E7%9A%84this%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/","content":"<h1 id=\"this指向\" class=\"active\"><a class=\"anchor\"  href=\"#this指向\">#</a> this指向</h1>\n在非严格模式下，总是指向一个对象，在严格模式下可以是任意值，开启严格模式可以使用如下两种方式:\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为整个脚本开启严格模式</span></span><br><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span></span><br><span class=\"line\">unction <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 为函数开启严格模式</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;use strict&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n然后就可以根据不同的模式来确认this指向啦，\n<ol>\n<li>\n<p>全局执行环境中，指向全局对象 (非严格模式、严格模式)</p>\n</li>\n<li>\n<p>函数内部，取决于函数被调用的方式</p>\n<ol>\n<li>\n<p>直接调用的 this 值:</p>\n<ol>\n<li>非严格模式：全局对象 (window)</li>\n<li>严格模式:undefined</li>\n</ol>\n</li>\n<li>\n<p>对象方法调用的 this 值:<br>\n 调用者</p>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"如何改变this指向\" class=\"active\"><a class=\"anchor\"  href=\"#如何改变this指向\">#</a> 如何改变this指向</h1>\n<ol>\n<li>\n<p>调用函数并传入具体的 <code>this</code> :</p>\n<ol>\n<li>\n<p><code>call</code> :</p>\n<ol>\n<li>参数 1: <code>this</code></li>\n<li>参数 2: 传递给函数的参数</li>\n</ol>\n</li>\n<li>\n<p><code>apply</code> : 数组作为参数</p>\n<ol>\n<li>参数 1: <code>this</code></li>\n<li>参数 2: 以数组的形式，传递给函数的参数</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>创建绑定 <code>this</code>  的函数:</p>\n<ol>\n<li>bind: 返回一个绑定了 <code>this</code>  的新函数</li>\n<li>箭头函数：就近向父级找 <code>this</code></li>\n</ol>\n</li>\n</ol>\n<h1 id=\"手搓call apply bind\" class=\"active\"><a class=\"anchor\"  href=\"#手搓call apply bind\">#</a> 手搓call apply bind</h1>\n  <h2 id=\"手搓call\" class=\"active\"><a class=\"anchor\"  href=\"#手搓call\">#</a> 手搓call</h2>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbA==\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//手写myCall 任何函数都能调用所以写到构造函数的原型上</span></span><br><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">myCall</span> = <span class=\"keyword\">function</span> (<span class=\"params\">thisArg, ...args</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//使用Symobl产生绝对唯一属性 防止传入对象中含有与新增属性重名的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> z = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;z&#x27;</span>)</span><br><span class=\"line\">  <span class=\"comment\">//this指的是调用myCall的函数 thisArg为传入的需要设置为this的对象</span></span><br><span class=\"line\">  thisArg[z] = <span class=\"variable language_\">this</span></span><br><span class=\"line\">  <span class=\"comment\">//args为传入调用myCall的函数的参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = thisArg[z](...args)</span><br><span class=\"line\">  <span class=\"comment\">//删掉传入对象新增属性z</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span> thisArg[z]</span><br><span class=\"line\">  <span class=\"comment\">//返回myCall调用者的结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"手搓apply\" class=\"active\"><a class=\"anchor\"  href=\"#手搓apply\">#</a> 手搓apply</h2>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYXBwbHk=\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//手写myApply</span></span><br><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">myApply</span> = <span class=\"keyword\">function</span> (<span class=\"params\">thisAry, args</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//与myCall唯一的不同就是传入的args参数为数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> w = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">  thisAry[w] = <span class=\"variable language_\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = thisAry[w](...args)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> thisAry[w]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"手搓bind\" class=\"active\"><a class=\"anchor\"  href=\"#手搓bind\">#</a> 手搓bind</h2>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZA==\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">myBind</span> = <span class=\"keyword\">function</span> (<span class=\"params\">thisArg, ...args</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//this是调用myBind的原函数 要把thisArg设置为新函数的this</span></span><br><span class=\"line\">  <span class=\"comment\">//...args是需要绑定的参数 ...reArgs是新函数需要传入的参数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...reArgs</span>) =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">call</span>(thisArg, ...args, ...reArgs)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","categories":["自学笔记","JavaScript"],"tags":["JavaScript"]},{"title":"js继承","url":"/study/js%E7%BB%A7%E6%89%BF/","content":"<h1 id=\"ES5\" class=\"active\"><a class=\"anchor\"  href=\"#ES5\">#</a> ES5</h1>\n<h2 id=\"ES5 原型链继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 原型链继承\">#</a> ES5 原型链继承</h2>\n<ol>\n<li>将父类的实例作为子类的原型实现继承</li>\n<li>这种继承方法的缺点是父类中的引用类型数据会被所有子类共享</li>\n</ol>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Son</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>(<span class=\"string\">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES5 构造函数继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 构造函数继承\">#</a> ES5 构造函数继承</h2>\n<ol>\n<li>在子类的构造函数中通过 <code>call</code>  或者 <code>apply</code>  调用父类的构造函数</li>\n<li>这种继承方法的缺点是：子类没法使用父类原型上的属性 / 方法</li>\n</ol>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Son</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES5 组合继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 组合继承\">#</a> ES5 组合继承</h2>\n<ol>\n<li>组合继承结合上面 2 种方法的优点:\n<ol>\n<li>通过原型链继承公共的属性和方法</li>\n<li>通过构造函数继承实例独有的属性和方法</li>\n</ol>\n</li>\n<li>组合继承的特点：调用 2 次父类的构造函数，浪费性能</li>\n</ol>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Son</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用父类构造函数传入this</span></span><br><span class=\"line\">  <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name)</span><br><span class=\"line\">  <span class=\"comment\">// 子类独有的属性和方法单独设置</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 设置子类的原型为 父类实例</span></span><br><span class=\"line\"><span class=\"title class_\">Son</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>()</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES5 原型式继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 原型式继承\">#</a> ES5 原型式继承</h2>\n<ol>\n<li>直接基于对象实现继承，对某个对象进行浅拷贝，可以通过内置 api <code>Object.create</code>  实现，不需要调用构造函数即可实现继承，主要针对于继承对象的情况</li>\n<li>原型式继承的缺点是：父类中的引用数据类型，会被所有子类共享</li>\n</ol>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZQ==\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以用 Object.create替代</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">objectFactory</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">Fun</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  <span class=\"title class_\">Fun</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = obj</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Fun</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parent = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;parent&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">25</span>,</span><br><span class=\"line\">  <span class=\"attr\">friend</span>: [<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"string\">&#x27;aa&#x27;</span>],</span><br><span class=\"line\">  <span class=\"title function_\">sayHi</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">age</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> son1 = <span class=\"title function_\">objectFactory</span>(parent)</span><br><span class=\"line\"><span class=\"comment\">//const son1 = Object.create(parent)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> son2 = <span class=\"title function_\">objectFactory</span>(parent)</span><br><span class=\"line\">son1.<span class=\"property\">friend</span>.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;Gin&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(son2.<span class=\"property\">friend</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES5 寄生式继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 寄生式继承\">#</a> ES5 寄生式继承</h2>\n<ol>\n<li>寄生式继承的核心步骤是：基于对象创建新对象 (可以使用 <code>Object.create</code> ), 并且为新创建的对象增加新的属性和方法，通过定义工厂函数，并在内部:\n<ol>\n<li>对传入的对象进行浅拷贝 (公共属性 / 方法)</li>\n<li>为浅拷贝对象增加属性 / 方法 (独有属性 / 方法)</li>\n</ol>\n</li>\n<li>寄生式继承和原型式继承的区别是：创建出来的新对象，会额外的增加新的<strong>属性 / 方法</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createAnother</span>(<span class=\"params\">origin</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Object.create基于原型创建新对象，对属性进行浅拷贝</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> clone = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(origin)</span><br><span class=\"line\">  <span class=\"comment\">// 为对象增加属性/方法</span></span><br><span class=\"line\">  clone.<span class=\"property\">sayHi</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;你好&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parent = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;parent&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">friend</span>: [<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"string\">&#x27;aa&#x27;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> son1 = <span class=\"title function_\">createAnother</span>(parent)</span><br><span class=\"line\"><span class=\"keyword\">const</span> son2 = <span class=\"title function_\">createAnother</span>(parent)</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES5 寄生组合式继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 寄生组合式继承\">#</a> ES5 寄生组合式继承</h2>\n<ol>\n<li>通过构造函数来继承属性，通过原型链来继承方法</li>\n<li>寄生组合式继承和组合式继承的区别是：原型链的继承并没有调用父类的构造函数，而是直接基于父类的原型创建一个新副本实现继承</li>\n</ol>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承原型函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inheritPrototype</span>(<span class=\"params\">son, parent</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> prototype = object.<span class=\"title function_\">create</span>(parent.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)</span><br><span class=\"line\">    prototype.<span class=\"property\">constructor</span> = son</span><br><span class=\"line\">    son.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = prototype</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Parent</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">friends</span> = [<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"string\">&#x27;aa&#x27;</span>,<span class=\"string\">&#x27;ss&#x27;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Parent</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHi</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>, <span class=\"string\">`My friends are,<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.friends&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类借用父类的构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Son</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name)</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 完成原型继承</span></span><br><span class=\"line\"><span class=\"title function_\">inheritPrototype</span>(<span class=\"title class_\">Son</span>,<span class=\"title class_\">Parent</span>)</span><br><span class=\"line\"><span class=\"comment\">// 可以继续在原型上添加属性/方法</span></span><br><span class=\"line\"><span class=\"title class_\">Son</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayAge</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我的年龄是&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">age</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> son1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>(<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> son2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>(<span class=\"string\">&#x27;hh&#x27;</span>, <span class=\"number\">19</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"ES6\" class=\"active\"><a class=\"anchor\"  href=\"#ES6\">#</a> ES6</h1>\n<h2 id=\"class核心语法\" class=\"active\"><a class=\"anchor\"  href=\"#class核心语法\">#</a> class核心语法</h2>\n<ol>\n<li>通过 <code>class 类名&#123;&#125;</code>  的形式来定义类</li>\n<li>内部直接写实例属性，可以设置默认值，</li>\n<li>实例方法的添加方式为 <code>方法名()&#123;&#125;</code></li>\n<li>构造函数通过 <code>constructor</code>  进行添加</li>\n<li>通过 <code>new 类名()</code>  创建实例，会调用构造函数 <code>constructor</code></li>\n</ol>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9jbGFzcw==\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Parent</span>&#123;</span><br><span class=\"line\">    name</span><br><span class=\"line\">    friends = [<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"string\">&#x27;aa&#x27;</span>,<span class=\"string\">&#x27;ss&#x27;</span>]</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"title function_\">sayHi</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;你好,我叫:&#x27;</span>,<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"class实现继承\" class=\"active\"><a class=\"anchor\"  href=\"#class实现继承\">#</a> class实现继承</h2>\n<ol>\n<li>子类通过 <code>extends</code>  继承继承父类</li>\n<li>子类如果需要重新定义构造函数，必须在内部通过 <code>super</code>  关键字调用父类的构造函数</li>\n</ol>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3N1cGVy\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Parent</span> &#123;</span><br><span class=\"line\">  age</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 子类构造函数使用this以前必须调用super</span></span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(name)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加方法</span></span><br><span class=\"line\">  <span class=\"title function_\">sayHey</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`我叫<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>,我今年<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.age&#125;</span>岁`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>(<span class=\"string\">&#x27;yy&#x27;</span>, <span class=\"string\">&#x27;18&#x27;</span>)</span><br><span class=\"line\">s.<span class=\"title function_\">sayHi</span>()</span><br><span class=\"line\">s.<span class=\"title function_\">sayHey</span>()</span><br></pre></td></tr></table></figure>\n<h2 id=\"class私有,静态属性和方法\" class=\"active\"><a class=\"anchor\"  href=\"#class私有,静态属性和方法\">#</a> class私有,静态属性和方法</h2>\n<ol>\n<li>\n<p>class 中私有属性 / 方法</p>\n<ol>\n<li><strong>定义和使用时</strong>需要使用关键字 <code>#</code></li>\n<li>私有属性只能在类的内部使用，外部无法使用 (代码中)</li>\n<li><strong>Chrome</strong> 的控制台中为了方便调试，可以直接访问</li>\n</ol>\n</li>\n<li>\n<p>class 中静态属性 / 方法</p>\n<ol>\n<li><strong>定义和使用时</strong>需要使用关键字 <code>static</code></li>\n<li>通过类访问</li>\n<li>静态方法中的 <code>this</code>  是类本身</li>\n</ol>\n</li>\n</ol>\n","categories":["自学笔记","JavaScript"],"tags":["JavaScript"]},{"title":"Hello World","url":"/dailysharing/hello-world/","content":"<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"markdownIt-Anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"markdownIt-Anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"markdownIt-Anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"markdownIt-Anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"markdownIt-Anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n"},{"title":"第一篇ovo","url":"/dailysharing/%E7%AC%AC%E4%B8%80%E7%AF%87ovo/","content":"<p>这是第一篇～</p>\n","categories":["日常碎碎念"],"tags":["Blog","日常"]},{"title":"C language basics and Computer memory","url":"/course/C-language-basics-and-Computer-memory/","content":"<h1 id=\"C language basics\" class=\"active\"><a class=\"anchor\"  href=\"#C language basics\">#</a>C language basics</h1>\n<h2 id=\"input/output\" class=\"active\"><a class=\"anchor\"  href=\"#input/output\">#</a> input/output</h2>\n<ol>\n<li>To print output to the terminal screen:</li>\n</ol>\n<ul>\n<li>printf(“Hello\\n”);</li>\n<li>printf(“Hello %s”, “haxor”);  // using a format string</li>\n</ul>\n<ol start=\"2\">\n<li>To get input from the user:</li>\n</ol>\n<ul>\n<li>scanf(&quot;%d&quot;, &amp;number);</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>Input/output format symbols</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test\\n&quot;</span>);   <span class=\"comment\">// `\\n`:  Carriage return/new line</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test %d&quot;</span>, <span class=\"number\">123</span>);  <span class=\"comment\">//`%d`:  Decimal value</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test %s&quot;</span>, <span class=\"string\">&quot;123&quot;</span>);  <span class=\"comment\">//`%s`:  String value</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test %x&quot;</span>, <span class=\"number\">0x123</span>);  <span class=\"comment\">//`%x`:  Hex value</span></span><br></pre></td></tr></table></figure>\n <figure class=\"highlight c\"><figcaption><span>C Program takes command-line arguments</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//meet.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\">greeting(<span class=\"type\">char</span> *temp1, <span class=\"type\">char</span> *temp2) <span class=\"comment\">// greeting function to say hello</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">400</span>];  <span class=\"comment\">// string variable to hold the name</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(name, temp2);  <span class=\"comment\">// copy function argument to name</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello %s %s\\n&quot;</span>, temp1, name);  <span class=\"comment\">// print out the greeting</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[]) <span class=\"comment\">// note the format for arguments</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    greeting(argv[<span class=\"number\">1</span>], argv[<span class=\"number\">2</span>]);  <span class=\"comment\">// call function, pass title &amp; name</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Bye %s %s\\n&quot;</span>, argv[<span class=\"number\">1</span>], argv[<span class=\"number\">2</span>]);  <span class=\"comment\">// say “bye&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Compiling C programs\" class=\"active\"><a class=\"anchor\"  href=\"#Compiling C programs\">#</a> Compiling C programs</h2>\nCompiling C programs(Linux) Using gcc\n<ol>\n<li>To compile our  <code>meet.c</code>  program, type</li>\n</ol>\n <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$gcc</span> -o meet meet.c</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>Then to execute the new program, type</li>\n</ol>\n <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./meet zz</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Commonly used gcc flags</li>\n</ol>\n<ul>\n<li>-o <filename>: produces compiled binary file with filename (a.out by default).</li>\n<li>-S: produces assembly code in a file; saved with a .s extension</li>\n<li>-g, -ggdb: produces extra debugging information for gdb (GNU debugger)</li>\n<li>-c: compiles without linking; produces object files with an .o extension</li>\n<li>Check out manual by using: man gcc</li>\n</ul>\n<ol start=\"4\">\n<li>32-bit vs 64-bit compilation</li>\n</ol>\n<ul>\n<li>To compile into 32-bit binaries:</li>\n</ul>\n <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$gcc</span> -m32 hello.c -o hello</span><br></pre></td></tr></table></figure>\n<ul>\n<li>install a standard library of</li>\n</ul>\n <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$sudo</span> apt install gcc-multilib </span><br></pre></td></tr></table></figure>\n<h2 id=\"C vs C#\" class=\"active\"><a class=\"anchor\"  href=\"#C vs C#\">#</a> C vs C#</h2>\n<ol>\n<li>C# is type-safe</li>\n</ol>\n<ul>\n<li>Strong static type system + runtime checks (e.g. bounds, type casts) + automatic memory management</li>\n</ul>\n<ol start=\"2\">\n<li>C is type-unsafe</li>\n</ol>\n<ul>\n<li>Pointers + no runtime check (out-of-bound access, bad type casts), manual memory management<br>\nRuntime array bounds check in C#</li>\n</ul>\n<p>If the following C# code is executed on .NET:</p>\n <figure class=\"highlight c#\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"> arr[<span class=\"number\">10</span>] = <span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure>\n<p>An exception will be raised at runtime!</p>\n<p>The length of the array is recorded and checked by the runtime</p>\n<ul>\n<li>The length of an array is fixed once created</li>\n</ul>\n<p>No runtime array bounds check in C, If the same C code is executed:</p>\n <figure class=\"highlight c\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"> arr[<span class=\"number\">10</span>] = <span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure>\n<p>No error, result in a silent buffer overflow!</p>\n<ul>\n<li>Unexpected behaviours such as mysterious crashes depending on what was overwritten</li>\n<li>Attackers may exploit this if they can control the overwritten data</li>\n</ul>\n<ol start=\"3\">\n<li>Automatic memory management in C#</li>\n</ol>\n<p>Programmers do not write code to perform memory management tasks<br>\nGarbage collector manages the allocation and release of memory<br>\nC# has no common memory problems such as buffer overflow</p>\n<ol start=\"4\">\n<li>C# strings</li>\n</ol>\n<p>C# strings are  <code>objects</code>  of the  <code>String</code>  class</p>\n<ul>\n<li>Similar to an array of chars, but immutable</li>\n<li>The length is stored on the object for bounds checks at runtime</li>\n</ul>\n<p>All string manipulation operations do not modify the original string</p>\n<ul>\n<li>A new string is created upon modification</li>\n<li>For example,  <code>str.Trim()</code>  returns a new string</li>\n</ul>\n<ol start=\"5\">\n<li>C strings</li>\n</ol>\n<p>C strings are arrays of characters</p>\n<ul>\n<li>Terminated by and including the first occurrence of the null character  <code>\\0</code></li>\n</ul>\n<p>String length is not automatically tracked</p>\n<ul>\n<li>It is determined by the number of bytes (character) preceding the null character.</li>\n<li>The memory required to store a string is the number of characters plus one</li>\n</ul>\n<p>A string can be manipulated just like any other arrays</p>\n<ul>\n<li>We usually use some built-in string functions in C libraries</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>copy one string to another</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span>    <span class=\"comment\">// use string library     </span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;Hello, Z&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(str2, str1);  <span class=\"comment\">// copy each character in str1 into str2</span></span><br></pre></td></tr></table></figure>\n<p>The function  <code>strcpy</code>  copies each character in the source string (a series of characters ending with and including a null character) into the destination string</p>\n <figure class=\"highlight c\"><figcaption><span>To compare two strings</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"> <span class=\"type\">char</span> str2[] = <span class=\"string\">&quot;haxor&quot;</span>;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(str1, str2) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Strings are the same.\\n&quot;</span>);</span><br><span class=\"line\"> <span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Strings are different.\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>This code prints out: Strings are different.<br>\nNote that the function  <code>strcmp()</code>  does not return a  <code>boolean</code>  result</p>\n<ul>\n<li>Zero represents false, anything else represents true</li>\n<li>No  <code>boolean</code>  type in C language prior to C99</li>\n</ul>\n<ol start=\"6\">\n<li><strong>Other common string functions</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQ19Qcm9ncmFtbWluZy9TdHJpbmdfbWFuaXB1bGF0aW9u\">More can be found</span><br>\n <code>strlen</code> : gets the length of a string<br>\n <code>strncpy</code> : copies one string to another with a bound<br>\n <code>strcat</code> ,  <code>strncat</code> : string concatenation<br>\n <code>gets</code> ,  <code>fgets</code> : receives input into a string</li>\n</ol>\n<h2 id=\"C strings is error prone\" class=\"active\"><a class=\"anchor\"  href=\"#C strings is error prone\">#</a>C strings is error prone</h2>\n<ol>\n<li>Common string manipulation errors:</li>\n</ol>\n<ul>\n<li>Buffer errors</li>\n<li>Heap errors</li>\n<li>Out‐by‐bound errors</li>\n<li>Integer overflows</li>\n<li>Other memory, pointer and type errors</li>\n</ul>\n<p><strong>When data is copied from an unbounded source to a fixed‐length sink</strong></p>\n <figure class=\"highlight c\"><figcaption><span>Unbounded string copy</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> \t<span class=\"type\">char</span> username[<span class=\"number\">8</span>];</span><br><span class=\"line\"> \t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please enter your username:&quot;</span>);</span><br><span class=\"line\"> \tgets(username);</span><br><span class=\"line\"> \t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Your username is %s\\n&quot;</span>, username);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Use of  <code>gets()</code>  Function</li>\n</ul>\n<p>The function  <code>gets()</code>  reads input from the user into a buffer, but it does not check the length of the input against the buffer’s size.<br>\nIn this code, the  <code>username</code>  array is only 8 bytes long. However,  <code>gets()</code>  allows users to enter an input of any length, which means it can write beyond the 8 bytes allocated for  <code>username</code> .<br>\nThis can cause a buffer overflow, which can lead to memory corruption, unexpected behavior, or even security vulnerabilities where attackers can execute arbitrary code.</p>\n<ul>\n<li>Fixed-Length Buffer</li>\n</ul>\n<p>The username array is declared to have a size of 8, but we need to reserve one byte for the null-terminator  <code>\\0</code> , which marks the end of the string.<br>\nThis means only 7 characters can safely be stored in the username buffer.<br>\nIf the input exceeds this limit, it will overflow into adjacent memory, potentially causing the program to crash or behave unpredictably.</p>\n <figure class=\"highlight c\"><figcaption><span>Unbounded string copy(fixed)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> username[<span class=\"number\">8</span>];  <span class=\"comment\">// Buffer limited to 8 bytes</span></span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please enter your username:&quot;</span>);</span><br><span class=\"line\">    fgets(username, <span class=\"keyword\">sizeof</span>(username), <span class=\"built_in\">stdin</span>);  <span class=\"comment\">// Limit input size to prevent overflow</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Your username is %s\\n&quot;</span>, username);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">// Standard return type</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Better string functions from libraries</strong><br>\nShould use functions that restrict the number of bytes for safer programming</p>\n<ul>\n<li>Use  <code>fgets()</code> , instead of  <code>gets()</code></li>\n<li>Use  <code>strncpy()</code> , instead of  <code>strcpy()</code></li>\n<li>Use  <code>strncat()</code> , instead of  <code>strcat()</code></li>\n<li>Use  <code>snprintf()</code> , instead of instead of  <code>sprintf()</code></li>\n</ul>\n<p><strong>Null‐termination errors</strong></p>\n <figure class=\"highlight c\"><figcaption><span>Null‐termination errors</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr, <span class=\"string\">&quot;0123456789&quot;</span>, <span class=\"keyword\">sizeof</span>(arr));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, arr);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>The array is not properly terminated by a null character!</p>\n<ul>\n<li>When there is no null character among the first n character of the source, the string placed in the<br>\ndestination will not be null-terminated!<br>\nThe  <code>printf()</code>  call prints out all bytes as character till reaching a null!</li>\n</ul>\n<p>To test out, let’s add another array:</p>\n <figure class=\"highlight c\"><figcaption><span>Null‐termination errors</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr2[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr, <span class=\"string\">&quot;0123456789&quot;</span>, <span class=\"keyword\">sizeof</span>(arr));</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr2, <span class=\"string\">&quot;9876543210&quot;</span>, <span class=\"keyword\">sizeof</span>(arr2));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, arr);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>The program will print out 01234567899876543210<br>\nWhere the length of source string is the same or greater than the length of target string</p>\n<ul>\n<li>The source string gets truncated</li>\n<li>The target string may not be properly terminated by null!</li>\n</ul>\n<p>How can we fix it?<br>\nManually add a null character at the end of the target string:</p>\n <figure class=\"highlight c\"><figcaption><span>Null‐termination errors(fixed)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr, <span class=\"string\">&quot;0123456789&quot;</span>, <span class=\"keyword\">sizeof</span>(arr)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tarr[<span class=\"keyword\">sizeof</span>(arr)<span class=\"number\">-1</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, arr);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>The function char  <code>*fgets(char *str, int n, FILE *stream)</code>  reads  <code>(n-1)</code>  characters from the specific stream plus the final null character</p>\n<h1 id=\" Computer memory\" class=\"active\"><a class=\"anchor\"  href=\"# Computer memory\">#</a> Computer memory</h1>\n<h2 id=\" Intel x86 (32-bit)\" class=\"active\"><a class=\"anchor\"  href=\"# Intel x86 (32-bit)\">#</a> Intel x86 (32-bit)</h2>\n<ol>\n<li>von Neumann architecture</li>\n</ol>\n<ul>\n<li>\n<p>Central processing unit (CPU) executes code</p>\n</li>\n<li>\n<p>Main memory of the system (RAM) stores all data and code</p>\n</li>\n<li>\n<p>Input/output system (I/O) interfaces with devices such as hard drives, keyboards, and monitors</p>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/24/671a56f0c953f.png\" alt=\"img\"></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>CPU</li>\n</ol>\n<p>The <strong>control unit</strong> gets instructions to execute from RAM using the instruction pointer, which stores the address of the instruction to execute<br>\n<strong>Registers</strong> are the CPU’s basic data storage units and are often used to save time so that the CPU doesn’t need to access RAM.</p>\n<p>在 32 位 x86 架构中，主要的通用寄存器包括：</p>\n<ul>\n<li>EAX: 累加器寄存器，用于算术运算和返回值。</li>\n<li>EBX: 基址寄存器，常用于基址存取。</li>\n<li>ECX: 计数器寄存器，常用于循环和移位操作。</li>\n<li>EDX: 数据寄存器，用于 I/O 操作和乘除法。</li>\n<li>ESI: 源索引寄存器，常用于指向内存数据源。</li>\n<li>EDI: 目标索引寄存器，常用于指向内存数据目标。</li>\n<li>EBP: 基址指针寄存器，用于栈帧基址指针。</li>\n<li>ESP: 栈指针寄存器，指向当前栈顶</li>\n</ul>\n<p>The <strong>Arithmetic Logic Unit (ALU)</strong> executes an instruction fetched from RAM and places the results in registers or memory</p>\n<p>CPU runs a program by fetching and executing each instruction</p>\n<h2 id=\"Programs in the main memory\" class=\"active\"><a class=\"anchor\"  href=\"#Programs in the main memory\"> #</a>  Programs in the main memory</h2>\n<p>Processes are programs loaded into memory, broken into small sections</p>\n<ul>\n<li>\n<p>.text section</p>\n</li>\n<li>\n<p>.data section</p>\n</li>\n<li>\n<p>.bss section</p>\n</li>\n<li>\n<p>Heap section</p>\n</li>\n<li>\n<p>Stack section</p>\n</li>\n<li>\n<p>Environment/Arguments section</p>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/24/671a56f09cb3d.png\" alt=\"img\"></p>\n</li>\n</ul>\n<ol>\n<li>.text section</li>\n</ol>\n<p>Correspond to the .text portion of the binary executable file.</p>\n<p>Contain the machine instructions to get the task done</p>\n<ol start=\"2\">\n<li>.data section</li>\n</ol>\n<p>Store global initialised variables such as:</p>\n<ul>\n<li>int a = 0;</li>\n</ul>\n<ol start=\"3\">\n<li>.bss section</li>\n</ol>\n<p>Store global uninitialised variables such as:</p>\n<ul>\n<li>int a;</li>\n</ul>\n<ol start=\"4\">\n<li>Heap section</li>\n</ol>\n<p>Store dynamically allocated variables</p>\n<ul>\n<li>Contain the pre-existing value of that memory</li>\n</ul>\n<p>Grows from the lower-addressed memory to the higher-addressed memory</p>\n<ul>\n<li>int *I = malloc (sizeof (int));</li>\n</ul>\n<ol start=\"5\">\n<li>Stack section</li>\n</ol>\n<p>Keep track of function calls (recursively)</p>\n<p>Grow from the higher-addressed memory to the lower-addressed memory</p>\n<p>Local variables are in the stack section</p>\n<ol start=\"6\">\n<li>Environment/Arguments section</li>\n</ol>\n<p>Store a copy of system-level variables that may be required by the process</p>\n<ul>\n<li>For example, path, shell name, hostname, etc.</li>\n</ul>\n<p>Command-line arguments are stored in this area.</p>\n<h2 id=\" Buffers\" class=\"active\"><a class=\"anchor\"  href=\"# Buffers\">#</a> Buffers</h2>\n<p>A storage place used to receive and hold data until it can be handled by a process<br>\nEach process can have its own set of buffers</p>\n<ul>\n<li>E.g. memory allocated within the .data or .bss section of the process’s memory<br>\nBuffer is of <strong>fixed length once allocated</strong>.</li>\n<li>Hold any predefined type of data</li>\n</ul>\n<h2 id=\" Pointers\" class=\"active\"><a class=\"anchor\"  href=\"# Pointers\">#</a> Pointers</h2>\n<p>Pointers hold the address of other pieces of memory</p>\n<ul>\n<li>Their size is fixed of 4 bytes for 32-bit memory address</li>\n</ul>\n<p>C string can be written as a pointer to character:</p>\n<ul>\n<li>char * str;</li>\n<li>int * point1;</li>\n</ul>\n<p>C#’s reference types implicitly use pointers<br>\nUse dereference to read the value inside the memory address pointed to by the pointer:</p>\n<ul>\n<li>printf(&quot;%d&quot;, *point1);</li>\n</ul>\n<p>The  <code>*</code>  symbol dereferences the pointer called point1 and displays the value of the integer using the  <code>printf()</code>  function</p>\n<ul>\n<li>The type of  <code>point1</code>  is a pointer</li>\n<li>The type of  <code>*point1</code>  is an integer</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>Putting the pieces of memory together</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ind = <span class=\"number\">5</span>;                     <span class=\"comment\">// integer stored in .data (initialized)</span></span><br><span class=\"line\"> <span class=\"type\">char</span> *str;                       <span class=\"comment\">// string pointer stored in .bss (uninitialized)</span></span><br><span class=\"line\"> <span class=\"type\">int</span> nothing;                     <span class=\"comment\">// integer stored in .bss (uninitialized)</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">(<span class=\"type\">int</span> c)</span> </span><br><span class=\"line\">&#123;                                              </span><br><span class=\"line\"> \t<span class=\"type\">int</span> i = c;                                  <span class=\"comment\">// stored in stack section</span></span><br><span class=\"line\"> \tstr = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">10</span> * <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>));    <span class=\"comment\">// reserves 10 characters in heap region </span></span><br><span class=\"line\"> \t<span class=\"built_in\">strncpy</span>(str, <span class=\"string\">&quot;abcde&quot;</span>, <span class=\"number\">5</span>);                   <span class=\"comment\">// copies &quot;abcde&quot; into str</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tfun(<span class=\"number\">1</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["课程笔记","Principles of Software Security"],"tags":["C language","Linux","software security"]},{"title":"Format string bugs","url":"/course/Format-string-bugs/","content":"<h1 id=\"Format Functions\" class=\"active\"><a class=\"anchor\"  href=\"#Format Functions\">#</a>Format Functions</h1>\n<ol>\n<li>Format Functions</li>\n</ol>\n<ul>\n<li><code>printf</code>  Output a formatted string</li>\n<li><code>fprintf</code>  Writes the printf to a file</li>\n<li><code>sprintf</code>  Prints into a string</li>\n<li><code>snprintf</code>  Prints into a string checking the length</li>\n<li><code>vprintf</code>  Prints the argument list to stdout</li>\n<li><code>vfprintf</code>  Prints the argument list to a file</li>\n<li><code>vsprintf</code>  Prints the argument list to a string</li>\n<li><code>vsnprintf</code>  Prints the argument to a string checking the length<br>\n 总结： <code>printf</code>  和  <code>fprintf</code>  用于输出格式化字符串到标准输出或文件。<br>\n <code>sprintf</code>  和  <code>snprintf</code>  用于将格式化字符串写入字符串缓冲区， <code>snprintf</code>  更安全。<br>\n <code>vprintf</code> 、 <code>vfprintf</code> 、 <code>vsprintf</code>  和  <code>vsnprintf</code>  用于处理可变参数列表，与前面的函数类似，但专门用于  <code>va_list</code>  参数的处理。</li>\n</ul>\n<ol start=\"2\">\n<li>Format Strings</li>\n</ol>\n<ul>\n<li>Format String is the argument of format functions that contains format parameters. Format parameters are placeholders to be replaced with user inputs</li>\n<li>For example, the statement will output different sentences, depending on what is contained in the variable name:  <code>printf(&quot;Hello, %s.&quot;, &amp;name);</code></li>\n<li>If the variable name contains the string “Zz”, then  <code>printf()</code>  will output: Hello, Zz.</li>\n</ul>\n<ol start=\"3\">\n<li>Common Parameters Used in Format String Attacks</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>传递方式</th>\n<th>在攻击中的作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%s</td>\n<td>打印字符串</td>\n<td>引用（指向字符串的指针）</td>\n<td>攻击者可以利用 % s 打印出内存中的任意数据，通过提供特定的内存地址，读取敏感数据（如密码、密钥等）。</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>打印有符号十进制整数</td>\n<td>整数值</td>\n<td>虽然 % d 通常用于整数显示，但攻击者可以通过它来泄露内存中的整数值。</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>打印无符号十进制整数</td>\n<td>无符号整数值</td>\n<td>与 % d 类似，但用于无符号整数的显示。</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>打印十六进制整数（小写）</td>\n<td>无符号整数值</td>\n<td>攻击者可以通过 % x 逐步读取内存，以十六进制显示地址中的数据内容。</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>打印单个字符</td>\n<td>字符值</td>\n<td>用于显示单个字符，但在攻击中用途有限。</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>将已打印的字符数写入指定变量</td>\n<td>引用（指向整数的指针）</td>\n<td>攻击者可以利用 % n 修改任意内存地址的值，这是格式字符串攻击中最危险的参数之一，可能被用来修改程序的控制流。</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>打印 % 字符</td>\n<td>无</td>\n<td>用于输出 % 字符，无特别的攻击价值。</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li>How Do Format Functions Work?<br>\nAccording to the data format dictated by the format parameters, format functions retrieve the arguments from the stack</li>\n</ol>\n<ul>\n<li>printf(“A is the number %d, B is the string %s”, A, &amp;B);<br>\nThe  <code>printf()</code>  function will attempt to retrieve the value of A and the address of string B from the stack<br>\n 在格式化字符串中，每个格式参数（如  <code>%d</code> 、 <code>%s</code> ）都告诉  <code>printf()</code>  如何解释栈中的数据： <code>%d</code>  表示检索一个 整数值。 <code>%s</code>  表示检索一个 字符串指针（地址），然后根据地址打印对应的字符串。</li>\n</ul>\n<h1 id=\"Exploit\" class=\"active\"><a class=\"anchor\"  href=\"#Exploit\">#</a>Exploit</h1>\nThe vulnerability occurs when there is a mismatch between the number of format parameters and the number of function arguments provided to fill those places \n- For example, if an attacker is able to supply more placeholders than there are arguments, he/she can use format functions to read or write the stack! \nFormat functions can be exploited when an attacker is given direct control over the format string fed into the function\n<ol>\n<li>Reading Data from Stack</li>\n</ol>\n<ul>\n<li>printf(&quot;A is the number  <code>%d</code> , reading stack data:  <code>%x</code> &quot;, A);\n<ul>\n<li><code>printf()</code>  will attempt to retrieve two values from the stack</li>\n<li>But only one of those is placed on the stack</li>\n<li><code>printf()</code>  will retrieve the next value on the stack and display it in hex format!</li>\n</ul>\n</li>\n<li>To print the next 20 items on the stack:\n<ul>\n<li>printf(&quot;%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x&quot;);</li>\n</ul>\n</li>\n<li>To print the tenth element next on the stack:\n<ul>\n<li>printf(&quot;%10$x&quot;);</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Reading Data at Arbitrary Location  <code>%s</code></li>\n</ol>\n<ul>\n<li>Format functions treat the data on the stack as an address to go fetch a string\n<ul>\n<li>Note that  <code>%s</code>  is passed as reference!</li>\n</ul>\n</li>\n<li>How to control the address accessed by  <code>%s</code> ?\n<ul>\n<li>Place an address on the format string (the string is stored on stack)</li>\n<li>Get  <code>%s</code>  to dereference it!</li>\n</ul>\n</li>\n<li>To print the string located at address 0x12345678:\n<ul>\n<li>printf(&quot;\\x78\\x56\\x34\\x12%x%x%x%s&quot;, A, B, C);</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Writing Data at Arbitrary Location  <code>%n</code></li>\n</ol>\n<ul>\n<li><code>%n</code>  stores the number of characters written so far into the corresponding function argument! For example, the following code put the integer 5 into the variable  <code>num_char</code></li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num_char; </span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;11111%n&quot;</span>, &amp;num_char); </span><br></pre></td></tr></table></figure>\n<p>With width-controlling format parameters, the attacker can write arbitrary integers to the location pointed to by the function argument</p>\n<ul>\n<li>Write 10 to num_char using width-controlling format parameter</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num_char; </span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%10d%n&quot;</span>, <span class=\"number\">0</span>, &amp;num_char);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Control the amount of data written with length parameter\n<ul>\n<li><code>printf(&quot;%10d%hn&quot;, 0, &amp;num_char);</code></li>\n<li>Writes 2 bytes (instead of 4 bytes) to  <code>&amp;num_char</code></li>\n</ul>\n</li>\n<li>Combined with the trick to access arbitrary memory locations, the attacker can write to arbitrary memory locations</li>\n</ul>\n<ol start=\"4\">\n<li>Example</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"type\">char</span> buf[<span class=\"number\">512</span>]; </span><br><span class=\"line\">     fgets(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"built_in\">stdin</span>); <span class=\"comment\">// 安全读取输入，不会导致缓冲区溢出</span></span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The input is:&quot;</span>); </span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(buf);  <span class=\"comment\">// 存在格式化字符串漏洞</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\"> &#125; </span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>printf(buf);</code>  直接使用了用户输入的内容作为格式化字符串。如果  <code>buf</code>  中包含格式化占位符（如  <code>%s</code> 、 <code>%x</code> 、 <code>%n</code>  等）， <code>printf()</code>  会将其解释为格式化指令，从而造成安全隐患。</li>\n<li>修复：  <code>printf(&quot;The input is: %s&quot;, buf);</code> ：% s 确保输入内容被当作普通字符串处理，而不是格式化字符串</li>\n</ul>\n<h1 id=\"Denial of Service Attacks\" class=\"active\"><a class=\"anchor\"  href=\"#Denial of Service Attacks\">#</a>Denial of Service Attacks</h1>\n<ul>\n<li>\n<p>Crash the program by attempting to access an invalid address</p>\n<ul>\n<li>Use  <code>%s</code>  to retrieve a value from the stack till encountering an invalid memory location</li>\n</ul>\n</li>\n<li>\n<p>The exploit string would look something like this</p>\n<ul>\n<li>·printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;);·</li>\n</ul>\n</li>\n<li>\n<p>The more %s used in the format string, the higher the chance of an invalid address</p>\n</li>\n</ul>\n<h1 id=\"Format String Attacks Prevention\" class=\"active\"><a class=\"anchor\"  href=\"#Format String Attacks Prevention\">#</a>Format String Attacks Prevention</h1>\n<ol>\n<li>Hard-coded format strings (e.g. no  <code>printf(arg)</code> )</li>\n<li>Do not use the fancy  <code>%n</code></li>\n<li>Be careful with pass as references</li>\n</ol>\n<ul>\n<li>e.g.  <code>%s</code>  and  <code>sprintf</code>  can be used to create disclosure attacks</li>\n</ul>\n<ol start=\"4\">\n<li>Compiler support to match  <code>printf</code>  arguments with format string</li>\n</ol>\n<ul>\n<li>e.g. the  <code>gcc</code>  compiler provides options to check format strings</li>\n</ul>\n","categories":["课程笔记","Principles of Software Security"],"tags":["software security","C","vulnerability"]},{"title":"Stack buffer overflow","url":"/course/Stack-buffer-overflow/","content":"<h1 id=\"Stack buffer overflow\" class=\"active\"><a class=\"anchor\"  href=\"#Stack buffer overflow\">#</a>Stack buffer overflow</h1>\n<ol>\n<li>The Process Stack</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>Sample Process C Code</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">A</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c)</span>  </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">\t<span class=\"type\">char</span> buffer1[<span class=\"number\">5</span>]; </span><br><span class=\"line\">\t<span class=\"type\">char</span> buffer2[<span class=\"number\">10</span>]; </span><br><span class=\"line\">    \t... </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>  </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">\tA(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(...); </span><br><span class=\"line\">   \t ... </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/26/671ca1b71cfbb.png\" alt=\"img\"></p>\n<p>在调用函数时，函数参数是按照从右到左的顺序依次压入栈中。这种参数传递方式是 x86 架构的标准做法，用于保证函数参数在栈上的正确顺序。<br>\n在这个例子中，函数  <code>A(int a, int b, int c)</code>  被调用时， <code>c</code>  首先被压入栈，然后是  <code>b</code> ，最后是  <code>a</code> 。</p>\n<ol start=\"2\">\n<li>Buffer Overflow</li>\n</ol>\n<ul>\n<li>Occurs when:<br>\nInput is unconstrained<br>\nRuns past the end of a buffer, replacing valid (control) data</li>\n<li>Technique that allows:<br>\nYour code to be executed by another program<br>\nOverflow data area to alter variable values</li>\n<li>Problem: declaration in version of login.c is  <code>char name[80], passwd[80], hash[13];</code> . Attack login procedure:\n<ol>\n<li>User types username, which is stored in name</li>\n<li>Compute hash for the corresponding password</li>\n<li>User types password, pads to 80 chars, and types hash for that password</li>\n<li>The program validates password against user-supplied hash; user is in (with any password)</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Stack Smashing<br>\n 缓冲区溢出攻击的核心是覆盖栈上的 返回地址（ret）。当返回地址被覆盖时，程序在函数返回时不会跳回调用函数的位置，而是跳转到攻击者指定的位置。攻击者可以利用这种技术让程序执行任意代码（如恶意代码或 shellcode），这被称为堆栈破坏。</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>Stack Smashing</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionA</span><span class=\"params\">(<span class=\"type\">char</span> *str)</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"type\">char</span> buffer[<span class=\"number\">16</span>]; </span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(buffer, str);   <span class=\"comment\">//segmentation fault</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"type\">char</span> large_string[<span class=\"number\">256</span>]; </span><br><span class=\"line\">\t<span class=\"type\">int</span> i; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">255</span>; i++) </span><br><span class=\"line\">       &#123; </span><br><span class=\"line\">\t\tlarge_string[i] = <span class=\"string\">&#x27;A&#x27;</span>; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">\tfunctionA(large_string); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>buffer</code> ：在  <code>functionA</code>  中声明为 16 字节的字符数组。</li>\n<li><code>strcpy(buffer, str)</code> ：使用  <code>strcpy</code>  将外部传入的字符串 str 复制到 buffer 中。由于  <code>strcpy</code>  不检查长度，如果  <code>str</code>  的长度超过 16 字节，会导致缓冲区溢出。</li>\n<li>在  <code>main</code>  中， <code>large_string</code>  是一个 256 字节的数组，它被填充为 255 个 ‘A’。当  <code>large_string</code>  被传递给  <code>functionA</code>  时， <code>buffer</code>  被溢出。</li>\n<li>修复：  <code>strcpy(buffer, str)</code>  --&gt;  <code>strncpy(buffer, str, 16);</code></li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/26/671ca87ccb1e2.png\" alt=\"img\"><br>\n <code>large_str</code>  has overflowed  <code>buffer</code>  and  <code>sfp</code>  and  <code>ret</code>  and  <code>*str</code> .Note that  <code>ret</code>  is the return address!<br>\nThis means we can get the function to return to any point in the code that we specify.</p>\n<ul>\n<li>Buffer overflows allow us to change return address\n<ol>\n<li>Can point to any function in the library</li>\n<li>Can point to own code</li>\n</ol>\n</li>\n<li>Add code in the overflowed buffer\n<ol>\n<li>Run at privilege of process (very useful if root!)</li>\n<li>Even a small buffer can invoke a shell using the system call (often called shellcode)</li>\n</ol>\n</li>\n<li>Attacker would like to run shell at root level\n<ol>\n<li>Make system call to  <code>execve</code> , passing  <code>/bin/sh</code></li>\n<li>Needs to be part of the buffer, and in assembly code (以便精确控制其大小和功能)</li>\n<li>Program has to fit in buffer without overwriting return address (如果 shellcode 覆盖了返回地址本身，可能导致程序崩溃而无法执行攻击代码)</li>\n<li>Pad out buffer to return address, and point return address to start of buffer</li>\n<li>Don’t generate core dump (this will cause suspicion)</li>\n</ol>\n</li>\n</ul>\n<ol start=\"4\">\n<li>What do You Need to Hack a Buffer Overflow\n<ol>\n<li>Address where buffer begins</li>\n</ol>\n<ul>\n<li>Easy to get if you have access to the same type of system being attacked</li>\n<li>Can use Null Operation (NOP) commands to make the target address bigger</li>\n</ul>\n<ol start=\"2\">\n<li>Location where return address is stored</li>\n</ol>\n<ul>\n<li>Can pad out the buffer with return address</li>\n</ul>\n<ol start=\"3\">\n<li>Assembly language program to spawn a shell (shellcode payload)</li>\n</ol>\n<ul>\n<li>Can use gdb to disassemble a program for you</li>\n</ul>\n</li>\n<li>Affected Languages</li>\n</ol>\n<p>Buffer overflows mainly occur in low-level programming languages that allow direct memory access: Assembler, C, C++<br>\nNote that some high-level languages such as Java, C# and Visual Basic are written in C, C++ or call modules written in these languages</p>\n<ol start=\"6\">\n<li>\n<p>Buffer Overflow Examples<br>\nFunctions that handle arrays but do not check length (checking for termination character is insufficient) In C/C++,   <code>gets</code> ,  <code>strcpy</code> ,  <code>strcat</code> ,  <code>sprintf</code></p>\n<ol>\n<li>Example 1</li>\n</ol>\n</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[<span class=\"number\">20</span>]; </span><br><span class=\"line\"> gets(buf);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>char buf[20]</code> ：定义了一个长度为 20 的字符数组  <code>buf</code> 。</p>\n</li>\n<li>\n<p><code>gets(buf)</code> ：使用  <code>gets()</code>  函数从标准输入读取字符串，并存储在  <code>buf</code>  中</p>\n</li>\n<li>\n<p><code>gets()</code>  函数不检查输入的长度，意味着如果输入的字符串长度超过了  <code>buf</code>  的大小（20 字节），则会发生缓冲区溢出。</p>\n</li>\n<li>\n<p>修复：  <code>fgets(buf, sizeof(buf), stdin);</code></p>\n<ol start=\"2\">\n<li>Example 2</li>\n</ol>\n</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[<span class=\"number\">20</span>]; </span><br><span class=\"line\"> <span class=\"type\">char</span> prefix[] = <span class=\"string\">&quot;http://&quot;</span>; </span><br><span class=\"line\">   ... </span><br><span class=\"line\">   <span class=\"comment\">// copies the string prefix to buf </span></span><br><span class=\"line\"> <span class=\"built_in\">strcpy</span>(buf, prefix); </span><br><span class=\"line\">   <span class=\"comment\">// concatenates path to the string buf </span></span><br><span class=\"line\"> <span class=\"built_in\">strncat</span>(buf, path, <span class=\"keyword\">sizeof</span>(buf));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>char buf[20]</code> ：定义了一个长度为 20 字节的字符数组  <code>buf</code> 。</p>\n</li>\n<li>\n<p><code>char prefix[] = &quot;http://&quot;;</code> ：定义了一个包含字符串  <code>&quot;http://&quot;</code>  的字符数组。</p>\n</li>\n<li>\n<p><code>strcpy(buf, prefix)</code> ：将字符串  <code>&quot;http://&quot;</code>  复制到  <code>buf</code>  中。</p>\n<ul>\n<li>问题： <code>&quot;http://&quot;</code>  长度为 7 字节（包括终止符 \\0），在复制后， <code>buf</code>  中只剩下 13 个字节可用。</li>\n</ul>\n</li>\n<li>\n<p><code>strncat(buf, path, sizeof(buf))</code> ：将字符串  <code>path</code>  连接到  <code>buf</code>  中，指定的最大长度为  <code>sizeof(buf)</code> （即 20 字节）。</p>\n<ul>\n<li>问题：这里的  <code>sizeof(buf)</code>  是 20 字节，但在前面已经用掉了 7 字节（包括终止符）。 <code>strncat()</code>  试图追加  <code>path</code>  的内容时，可能会超出  <code>buf</code>  的剩余空间（13 字节），导致缓冲区溢出。</li>\n</ul>\n</li>\n<li>\n<p>修复： <code>strncat(buf, path, sizeof(buf) - strlen(buf) - 1);</code></p>\n<ol start=\"3\">\n<li>Example 3</li>\n</ol>\n</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[<span class=\"number\">32</span>]; </span><br><span class=\"line\"> <span class=\"built_in\">strncpy</span>(buf, data, <span class=\"built_in\">strlen</span>(data)); </span><br></pre></td></tr></table></figure>\n<p><code>strncpy(buf, data, strlen(data))</code> ：将字符串  <code>data</code>  复制到  <code>buf</code>  中，复制的长度为  <code>strlen(data)</code> 。</p>\n<ul>\n<li>\n<p>缺陷 1：缺少终止符 \\0： <code>strncpy</code>  不会自动添加字符串的终止符  <code>\\0</code> ，如果  <code>data</code>  的长度等于或大于 32，那么  <code>buf</code>  不会以  <code>\\0</code>  结尾。这可能导致  <code>buf</code>  被当作未终止的字符串处理，带来不确定的行为或安全风险。</p>\n</li>\n<li>\n<p>缺陷 2：可能的缓冲区溢出：如果  <code>strlen(data) &gt; 32</code> ， <code>strncpy</code>  将尝试复制超过  <code>buf</code>  大小的内容，导致缓冲区溢出。</p>\n</li>\n<li>\n<p>修复： <code>strncpy(buf, data, sizeof(buf) - 1); buf[sizeof(buf) - 1] = '\\0';</code></p>\n<ol start=\"4\">\n<li>Example 4</li>\n</ol>\n</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[MAX_PATH]; </span><br><span class=\"line\"> <span class=\"built_in\">sprintf</span>(buf, <span class=\"string\">&quot;%s - %d\\n&quot;</span>, path, errno);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>sprintf(buf, &quot;%s - %d\\n&quot;, path, errno)</code>  会将  <code>path</code>  和  <code>errno</code>  的格式化字符串复制到  <code>buf</code>  中。</li>\n<li><code>sprintf</code>  不检查  <code>buf</code>  的大小是否足以容纳格式化后的结果。如果  <code>path</code>  很长，加上数字  <code>errno</code>  和其他字符，可能会超过  <code>MAX_PATH</code> ，导致缓冲区溢出。</li>\n<li>修复：  <code>snprintf(buf, sizeof(buf), &quot;%s - %d\\n&quot;, path, errno);</code></li>\n</ul>\n<h1 id=\"Stack buffer overflow prevention\" class=\"active\"><a class=\"anchor\"  href=\"#Stack buffer overflow prevention\">#</a>Stack buffer overflow prevention</h1>\n<ol>\n<li>Spotting Buffer Overflows</li>\n</ol>\n<ul>\n<li>Check inputs, whether read from the network, a file, or from the command line</li>\n<li>Check transfer of data from said input to internal structures</li>\n<li>Look for use of unsafe string handling calls</li>\n<li>Look for use of arithmetic to calculate an allocation size or remaining buffer size</li>\n</ul>\n<ol start=\"2\">\n<li>Fixing Buffer Overflows</li>\n</ol>\n<ul>\n<li>Replace dangerous string handling functions</li>\n<li>Replace C string buffers with C++ strings</li>\n<li>Replace static arrays with STL containers</li>\n<li>Use analysis tools, Examples include Fortify, Coverity, PREfast, and Klocwor</li>\n</ul>\n<ol start=\"3\">\n<li>Code Analysis</li>\n</ol>\n<ul>\n<li>Statically check source to detect buffer overflows s</li>\n<li>Several tools exist to automate the review process<br>\nStanford:  Engler, et al.  Test trust inconsistency<br>\n@stake.com  (<span class=\"exturl\" data-url=\"aHR0cDovL2wwcGh0LmNvbQ==\">l0pht.com</span>): SLINT (designed for UNIX)<br>\nBerkeley:  Wagner, et al.  Test constraint violations</li>\n<li>Find lots of bugs, but not all</li>\n</ul>\n<ol start=\"4\">\n<li>Marking Stack as Non-Execute<br>\nBasic stack exploit can be prevented by marking stack segment as non-executable<br>\nLimitations and Problems</li>\n</ol>\n<ul>\n<li>Some apps need executable stack (e.g. LISP interpreters)</li>\n<li>Does not block more general overflow exploits</li>\n<li>Overflow on heap: overflow buffer next to func pointer</li>\n<li>Cannot make all the data segment non-executable</li>\n<li>More recent UNIX and MS windows emit dynamic code into program data for performance optimisations</li>\n</ul>\n<ol start=\"5\">\n<li>Stack Protection and Run-time Checking<br>\nMany run-time checking techniques\n<ol>\n<li>Example:  StackGuard (WireX)</li>\n</ol>\n<ul>\n<li>Run time tests for stack integrity</li>\n<li>Code generator for emitting code to set up and tear down functions</li>\n<li>Embeds “canaries” in stack frames and verify their integrity prior to function return</li>\n</ul>\n<ol start=\"2\">\n<li>Libsafe (Avaya Labs)</li>\n</ol>\n<ul>\n<li>Dynamically loaded library</li>\n<li>Intercepts calls to  <code>strcpy (dest, src)</code>\n<ul>\n<li>Validate sufficient space in current stack frame: |framepointer–dest| &gt; strlen(src)</li>\n<li>If so, does strcpy. Otherwise, terminates application</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Address obfuscation (Stony Brook’03)</li>\n</ol>\n<ul>\n<li>Encrypt return address on stack by XORing with random string. Decrypt just before returning from function</li>\n<li>Attacker needs decryption key to set return address to desired value</li>\n</ul>\n<ol start=\"7\">\n<li>PaX ASLR: Randomise location of libc</li>\n</ol>\n<ul>\n<li>Attacker cannot jump directly to exec function</li>\n</ul>\n","categories":["课程笔记","Principles of Software Security"],"tags":["software security","C","vulnerability"]},{"title":"Integer overflow","url":"/course/Integer-overflow/","content":"<h1 id=\"Integer overflow\" class=\"active\"><a class=\"anchor\"  href=\"#Integer overflow\">#</a>Integer overflow</h1>\n When the result of an integer operation does not fit within the allocated memory space. All common languages are affected \n<ol>\n<li>How Does an Integer Overflow Happen?\n<ol>\n<li>无符号整数溢出：例如，一个 32 位无符号整数的范围是 0 到 4,294,967,295（即 2**32 − 1 或 0xffffffff）。如果我们执行计算 4,294,967,295 + 1，则会导致溢出，因为结果超出了无符号整数的范围</li>\n<li>有符号整数溢出</li>\n</ol>\n<ul>\n<li>符号位的溢出<br>\n当一个整数运算的结果超过有符号整数的范围时，符号位（最高位）可能会被覆盖，从而引发溢出。<br>\n有符号整数的符号位：在有符号整数中，最高位用来表示数值的正负。例如，32 位有符号整数的最高位是第 31 位（第 0 位到第 30 位是数值位）。溢出导致符号变化：如果运算结果超出正数范围，符号位会被设置为 1，这会导致数值被解释为负数。例如，在 32 位有符号整数中，+2,147,483,647 + 1 会导致数值变成 -2,147,483,648，因为符号位被改变。</li>\n<li>向下类型转换（Downcasting）和数值截断（Truncation）\n<ul>\n<li>向下类型转换：指将一个高精度的数据类型转换为低精度的数据类型。例如，将 long 类型转换为 int 时，如果原始值超过 int 的范围，可能会导致数值截断。</li>\n<li>数值截断可能导致溢出：截断发生时，较高位的数值会被忽略，只保留低位部分。这可能导致数值错误，甚至触发整数溢出。例如，如果一个 64 位的 long 类型被转换为 32 位的 int 类型，而其数值超过了 32 位整数的最大值，那么高位将被截断，只保留低 32 位，可能导致溢出或错误的计算结果。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Risks of Integer Overflow<br>\nMostly lead to program errors, but can have severe consequences</li>\n</ol>\n<ul>\n<li>Buffer overflow occurs when an integer overflow happens in calculating the length of the buffer</li>\n<li>Erroneous program behaviours in mission critical software Incorrect financial calculations</li>\n</ul>\n<h1 id=\"Real-World Examples\" class=\"active\"><a class=\"anchor\"  href=\"#Real-World Examples\">#</a>Real-World Examples</h1>\n<ol>\n<li>Integer Overflow Leads to Buffer Overflow in OpenSSH 3.3</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">nresp = packet_get_int(); </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (nresp &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\"> \tresponse = xmalloc(nresp * <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span> *)); </span><br><span class=\"line\"> \t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nresp; i++) </span><br><span class=\"line\"> \t\tresponse[i] = packet_get_string(<span class=\"literal\">NULL</span>); </span><br><span class=\"line\"> &#125; </span><br></pre></td></tr></table></figure>\n<p>When  <code>nresp</code>  is 1073741824 (1073741824*4=4294967296=2**32), results in an overflow</p>\n<ul>\n<li><code>xmalloc()</code>  receives and allocates a 0-byte buffer</li>\n<li>The subsequent loop causes a heap buffer overflow (当循环试图将数据写入到  <code>response</code>  时，由于  <code>response</code>  并未真正分配内存，写入操作会覆盖其他内存区域，导致程序崩溃或被攻击者利用。)</li>\n<li>fixed:  <code>if (nresp &gt; 0 &amp;&amp; nresp &lt;= SIZE_MAX / sizeof(char *))</code></li>\n</ul>\n<ol start=\"2\">\n<li>A Real-World Vulnerability in the Handling JPEG Files</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">getComment</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> len, <span class=\"type\">char</span> *src)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\"> \t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> size; </span><br><span class=\"line\"> \tsize = len ‐ <span class=\"number\">2</span>; </span><br><span class=\"line\"> \t<span class=\"type\">char</span> *comment = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(size + <span class=\"number\">1</span>); </span><br><span class=\"line\"> \t<span class=\"built_in\">memcpy</span>(comment, src, size); </span><br><span class=\"line\"> \t<span class=\"keyword\">return</span>; </span><br><span class=\"line\"> &#125; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>整数下溢<br>\n在这段代码中，变量  <code>len</code>  和  <code>size</code>  被声明为无符号整数（unsigned int），这意味着它们的值不能是负数。<br>\n当  <code>len</code>  小于 2 时，计算  <code>size = len - 2</code>  会导致 整数下溢：<br>\n例如， <code>len</code>  为 1 时， <code>size</code>  将变为 0xffffffff（4294967295），即无符号整数的最大值。<br>\n下溢的原因在于无符号整数的运算特性，当减法结果为负时，会回绕（wrap around）到最大值。</li>\n<li>0 字节内存分配<br>\n在下溢的情况下，当  <code>size</code>  被设置为 0xffffffff 时，表达式  <code>size + 1</code>  变为 0。<br>\n这会导致  <code>malloc(0)</code> ，即分配一个 0 字节的缓冲区。<br>\n在许多系统中，0 字节的  <code>malloc()</code>  是合法的，它会返回一个指针，但该指针不能被写入任何数据。</li>\n<li>堆缓冲区溢出<br>\n <code>memcpy(comment, src, size)</code>  将从  <code>src</code>  复制  <code>size</code>  个字节到  <code>comment</code> ，其中  <code>size</code>  的值为 0xffffffff。<br>\n由于  <code>comment</code>  是一个 0 字节的缓冲区，这将导致 堆缓冲区溢出，可能覆盖其他堆内存区域，从而导致程序崩溃或被攻击者利用。</li>\n<li>修复</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> size = len - <span class=\"number\">2</span>;</span><br><span class=\"line\"> ...</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Example 3</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">CopyStructs</span><span class=\"params\">(InputFile* pInFile, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> count)</span> &#123;</span><br><span class=\"line\">     <span class=\"type\">unsigned</span> <span class=\"type\">long</span> i;</span><br><span class=\"line\">     m_pStructs = new Structs[count]; </span><br><span class=\"line\">     <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123; </span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!ReadFromFile(pInFile, &amp;(m_pStructs[i]))) </span><br><span class=\"line\">             <span class=\"keyword\">break</span>; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>The C++’s  <code>new[]</code>  operator, it is similar to  <code>malloc(count*sizeof(Structs))</code> <br>\nAllocate a buffer smaller than we need, the attacker is able to write over the buffer</p>\n<ul>\n<li>By <strong>overflowing the multiplication operation</strong> internally</li>\n</ul>\n<ol start=\"4\">\n<li>Example 4</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_BUF 256</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BadCode</span><span class=\"params\">(<span class=\"type\">char</span> *input)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"type\">short</span> len; </span><br><span class=\"line\">     <span class=\"type\">char</span> buf[MAX_BUF]; </span><br><span class=\"line\">     len = <span class=\"built_in\">strlen</span>(input); </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (len &lt; MAX_BUF) </span><br><span class=\"line\">         <span class=\"built_in\">strcpy</span>(buf, input); </span><br><span class=\"line\"> &#125; </span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>strlen()</code>  返回无符号整数<br>\n <code>strlen()</code>  返回的是无符号整数类型 <code>size_t</code> ，通常是一个 32 位或 64 位无符号整数。<br>\n <code>len</code>  被定义为一个 16 位有符号短整型 <code>short</code> ，其范围是 -32,768 到 32,767。</li>\n<li>类型截断和符号翻转<br>\n当  <code>strlen(input)</code>  返回的长度超过  <code>32,767</code>  时，赋值给  <code>short len</code>  时会发生 类型截断，导致溢出。<br>\n例如，如果  <code>strlen(input)</code>  返回 40,000，那么赋值后， <code>len</code>  的值将会变成 -25,536（溢出后的值），因为  <code>short</code>  类型的最大正值只能到 32,767。<br>\n这会将一个本应是大于 256 的值变成一个负数。</li>\n<li>缓冲区溢出风险<br>\n在类型截断后， <code>len</code>  可能是负数。条件  <code>if (len &lt; MAX_BUF)</code>  将会成立，因为负数小于 256。<br>\n这意味着，即使输入字符串的实际长度超过了 256 字节， <code>strcpy(buf, input)</code>  仍会被执行，导致缓冲区溢出。</li>\n<li>修复<br>\n <code>len = strnlen(input, MAX_BUF);</code> : The  <code>strnlen()</code>  function returns an integer value capped by  <code>MAX_BUF</code></li>\n</ul>\n<h1 id=\"Integer Overflow Prevention\" class=\"active\"><a class=\"anchor\"  href=\"#Integer Overflow Prevention\">#</a>Integer Overflow Prevention</h1>\nInteger overflow is very hard to discover and prevent\n<ol>\n<li>Runtime checks</li>\n</ol>\n<ul>\n<li>ubsan instruments binaries to be executed and checks the results of arithmetic operations</li>\n<li>Microsoft Visual C++ 2005 and later automatically catch calls to operator new that overflow</li>\n</ul>\n<ol start=\"2\">\n<li>Library support</li>\n</ol>\n<ul>\n<li>SafeInt class performs safe operations</li>\n</ul>\n<ol start=\"3\">\n<li>Static analysis tools and formal verification techniques<br>\n 在程序编译前对源代码进行分析，寻找潜在的整数溢出问题。这些工具可以检测代码中的常见整数运算错误，包括加减乘除溢出、类型转换溢出等</li>\n</ol>\n","categories":["课程笔记","Principles of Software Security"],"tags":["software security","C"]},{"title":"Fuzz testing","url":"/course/Fuzz-testing/","content":"<h1 id=\"Software testing\" class=\"active\"><a class=\"anchor\"  href=\"#Software testing\">#</a> Software testing</h1>\n<h2 id=\"Definition\" class=\"active\"><a class=\"anchor\"  href=\"#Definition\">#</a>Definition</h2>\n<ol>\n<li>The process of running a program to evaluate properties of interest</li>\n</ol>\n<ul>\n<li>Meet design requirements</li>\n<li>Produce correct results</li>\n<li>Perform within an acceptable time</li>\n<li>Reasonably usable</li>\n<li>Handle all inputs correctly</li>\n</ul>\n<ol start=\"2\">\n<li>Software Testing Steps</li>\n</ol>\n<ul>\n<li>验证（Verification）：我们是否在正确地构建产品？<br>\n任务集确保软件正确地实现了特定功能。<br>\n验证的目标是确保程序在所有可能的输入下都能正常工作。</li>\n<li>确认（Validation）：我们是否在构建正确的产品？<br>\n任务集确保软件符合客户需求。</li>\n</ul>\n<ol start=\"3\">\n<li>Test Oracles<br>\nSoftware testing determines the correctness of software under the assumption of some specific hypotheses. Compares the state and behaviour of the product against test oracles.</li>\n</ol>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/27/671dfbadce67b.png\" alt=\"img\"></p>\n<ol start=\"4\">\n<li>Types of Software Testing\n<ol>\n<li>Manual testing</li>\n</ol>\n<ul>\n<li>Without using any automated tool or any script</li>\n<li>E.g. unit testing, integration testing, system testing, user experience testing</li>\n</ul>\n<ol start=\"2\">\n<li>Automated testing</li>\n</ol>\n<ul>\n<li>Use scripts or another software to test the product</li>\n<li>E.g. regression testing, performance testing, stress testing</li>\n</ul>\n</li>\n<li>Testing levels\n<ol>\n<li>Unit testing: Test an individual component or group of inter-related components</li>\n<li>Integration testing: Individual components are combined and tested as a group</li>\n<li>System testing: Test a complete and integrated system</li>\n<li>Acceptance testing: Evaluate a system for compliance with the business requirements</li>\n</ol>\n</li>\n<li>Testing techniques and tactics\n<ol>\n<li>Regression testing: Make sure that whole system works properly after adding new components</li>\n<li>Stress testing: Test the software under extreme conditions</li>\n<li>Performance testing: Test the speed and effectiveness of the software</li>\n<li>Security testing: Test the program for security vulnerabilities</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Methods\" class=\"active\"><a class=\"anchor\"  href=\"#Methods\">#</a>Methods</h2>\n<ol>\n<li>Black-box testing: No access to the source code of the software. Only monitor the output of a system after providing a specific input\n<ol>\n<li>Treat the software as a black box</li>\n</ol>\n<ul>\n<li>Examining functionality without any knowledge of internal implementation</li>\n<li>Not biased toward an implementation</li>\n<li>But may leaves parts of the program untested</li>\n</ul>\n<ol start=\"2\">\n<li>Examples:</li>\n</ol>\n<ul>\n<li>Boundary value and all-pairs testing</li>\n<li>Model-based and specification-based testing</li>\n<li>Use case testing</li>\n<li>Fuzz testing</li>\n</ul>\n</li>\n<li>White-box testing: Access to the source code of the software\n<ol>\n<li>Verify the internal structures or workings of a program</li>\n</ol>\n<ul>\n<li>Exercise paths through the code and determine the appropriate outputs</li>\n<li>Bring more complexity to testing</li>\n</ul>\n<ol start=\"2\">\n<li>Code coverage criteria:</li>\n</ol>\n<ul>\n<li>Control flow testing</li>\n<li>Data flow testing</li>\n<li>Branch testing and decision coverage</li>\n<li>Statement coverage</li>\n</ul>\n<ol start=\"3\">\n<li>Code Coverage: Code that has not been covered by tests is likely to contain bugs</li>\n</ol>\n<ul>\n<li>Coverage = (# of elements tested) ÷ (# of elements in the program)</li>\n</ul>\n</li>\n<li>Grey-box testing: A mix of white-box and black-box tests<br>\nGrey-box testers partially know the internal structure, such as documentation of internal data structures as well as the algorithms used<br>\nThey make better-informed testing choices while testing the software from outside</li>\n</ol>\n<ul>\n<li>Can take the straightforward technique of black-box testing</li>\n<li>Still benefited from the code-targeted systems in white-box testing</li>\n</ul>\n<ol start=\"4\">\n<li>Principles of Software Testing</li>\n</ol>\n<ul>\n<li>Testing shows the presence of defects, not their absence: Testing reduces the number of defects but not a proof of correctness</li>\n<li>Exhaustive testing is impossible: For every combinations of inputs and preconditions in a nontrivial program</li>\n<li>Early testing saves time and money: Testing should start as early as possible in software development life cycle</li>\n<li>Defects cluster together: Pareto Principle in software testing: 80% of issues comes from 20% of modules</li>\n<li>Beware of the pesticide paradox: Repeating old test cases will eventually fail to find new defects</li>\n<li>Testing is context dependent: Different kinds of software are tested differently</li>\n<li>Absence-of-errors is a fallacy: Unusable software without bugs is still unusable</li>\n</ul>\n<h1 id=\"Fuzz testing\" class=\"active\"><a class=\"anchor\"  href=\"#Fuzz testing\">#</a>Fuzz testing</h1>\n<h2 id=\"Definition\" class=\"active\"><a class=\"anchor\"  href=\"#Definition\">#</a>Definition</h2>\n<ol>\n<li>What Is Fuzzing<br>\nA negative testing method that provides random or abnormal input data (fuzz) to a program</li>\n</ol>\n<ul>\n<li>Produce almost no false positive (误报)<br>\nMonitor bad behaviour in the responses</li>\n<li>For example, by crashing, or by failing built-in code assertions</li>\n<li>If the program fails, the defects can be noted</li>\n<li>If no crash is produced, inputs are mutated to produce further inputs<br>\nSoftware tools that work with fuzzing are called fuzzers</li>\n</ul>\n<ol start=\"2\">\n<li>Anatomy of a Fuzzer</li>\n</ol>\n<ul>\n<li>Fuzz targets: Small programs that test predefined API functions, similar to unit tests</li>\n<li>Fuzz generators: Create random mutations of inputs to the software under test</li>\n<li>Delivery mechanism: Process inputs from fuzz generators and feed them to the software for execution</li>\n<li>Monitoring system: Keep track of how the inputs are executed and detect triggered bugs from the<br>\nsoftware</li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/27/671e081d4f722.png\" alt=\"img\"></p>\n<ol start=\"3\">\n<li>Reasons for its Success\n<ol>\n<li>Random input<br>\nNo model of program behaviour, application type, or system description\n<ul>\n<li>Random ASCII characters used to test command-line utility options</li>\n<li>Studied Unix, Linux, Windows NT and Mac OS X<br>\nAble to test hundreds of applications, each with a multitude of inputs</li>\n</ul>\n</li>\n<li>Simple criteria</li>\n</ol>\n<ul>\n<li>Pass or fail verdict for fuzzing was very simple: If the application crashes or hangs, it is considered to fail the test. Otherwise, it passes (i.e. quietly exit)</li>\n<li>Very little monitoring was used<br>\nAny means of trying to hide the failures would have left the problems undiscovered<br>\nNo memory leak or heap overflow was caught, unless they resulted in a crash</li>\n</ul>\n<ol start=\"3\">\n<li>Automated testing<br>\nThe fuzz testing was entirely automated<br>\nResults were compared across applications, operating systems, and vendors<br>\nKey differences to traditional testing practices\n<ul>\n<li>General purpose tool</li>\n<li>Extremely easy to use</li>\n<li>Find security problems</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Types of Fuzzers\" class=\"active\"><a class=\"anchor\"  href=\"#Types of Fuzzers\">#</a>Types of Fuzzers</h2>\n<ol>\n<li>Dumb fuzzing</li>\n</ol>\n<ul>\n<li>Produce input completely randomly</li>\n<li>Easy and inexpensive to set up</li>\n<li>Not efficient</li>\n</ul>\n<ol start=\"2\">\n<li>Smart fuzzing</li>\n</ol>\n<ul>\n<li>Produce inputs that are based on valid input formats</li>\n<li>Require detailed knowledge about input format</li>\n<li>Take longer to set up</li>\n</ul>\n<ol start=\"3\">\n<li>Black-box fuzzin</li>\n</ol>\n<ul>\n<li>Feed a program random inputs to see whether it crashes</li>\n<li>Advantage: easy to configure</li>\n<li>Disadvantage: inefficient search\n<ul>\n<li>Input often requires structures, random inputs are likely to be malformed</li>\n<li>Hard to generate inputs for certain paths</li>\n<li>May re-run the same path over and over again</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>White-box fuzzing</li>\n</ol>\n<ul>\n<li>Look inside the box: Use source code to guide fuzzing</li>\n<li>Can understand and assert security properties: Explore different program execution paths to check for security properties</li>\n<li>Significantly more complex\n<ul>\n<li>Need to check whether an input can violate a security property</li>\n<li>Find inputs that will go down different program execution paths</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>Mutation-based fuzzing</li>\n</ol>\n<ul>\n<li>User supplies a well-formed input</li>\n<li>Fuzzer generates random changes to that input</li>\n<li>No assumption about input\n<ul>\n<li>Only assume that variants of well-formed input may be problematic</li>\n<li>Not dependent on program details</li>\n<li>May be strongly biased by the initial input!</li>\n</ul>\n</li>\n<li>Example: zzuf</li>\n</ul>\n<ol start=\"6\">\n<li>Generation-based fuzzing</li>\n</ol>\n<ul>\n<li>Generate inputs from some description of the format\n<ul>\n<li>Using specified protocols or file format info (RFC, documentation, etc.)</li>\n</ul>\n</li>\n<li>Require the user to specify a format or protocol. Or, write a generator for generating well-formatted inputs</li>\n<li>Advantage: more complete search with inputs more specific to the program operations</li>\n<li>Disadvantage: more cumbersome\n<ul>\n<li>Need specification or generator for every input format and program!</li>\n</ul>\n</li>\n<li>Example: Peach, SPIKE</li>\n</ul>\n<ol start=\"7\">\n<li>Coverage-based fuzzing</li>\n</ol>\n<ul>\n<li>Instrument the program to track coverage</li>\n<li>Maintain a pool of high-quality tests\n<ul>\n<li>Start with some initial ones specified by users</li>\n<li>Mutate tests in the pool to generate new tests</li>\n<li>Run new tests</li>\n<li>If a new test leads to new elements, save the new test to the pool</li>\n</ul>\n</li>\n<li>Example: AFL</li>\n</ul>\n","categories":["课程笔记","Principles of Software Security"],"tags":["software security"]},{"title":"x86 architecture and Assembly basics","url":"/course/x86-architecture-and-Assembly-basics/","content":"<h1 id=\" x86 architecture\" class=\"active\"><a class=\"anchor\"  href=\"# x86 architecture\">#</a> x86 architecture</h1>\n<h2 id=\"Levels of Abstraction\" class=\"active\"><a class=\"anchor\"  href=\"#Levels of Abstraction\">#</a> Levels of Abstraction</h2>\n<p>抽象层次（Levels of Abstraction） 是指在计算机系统设计中，将复杂的系统分解为不同的层次，以便于理解、设计和实现。每个抽象层都基于更底层的层次，同时也为更高层次提供基础。这种层次化的设计方式使得复杂系统的开发和维护更加高效。以下是这些抽象层次的具体解释：</p>\n<ol>\n<li>硬件层（Hardware Level）<br>\n解释：这是最底层的抽象层，主要是由各种电子电路和逻辑门（如 XOR、AND、OR、NOT 门等）组成。这些电路实现了最基本的逻辑运算和数据处理，是计算机所有功能的基础。<br>\n特点：这一层是最接近物理硬件的，直接处理电信号和物理开关状态。</li>\n<li>微码层（Microcode Level）/ 固件层（Firmware Level）<br>\n解释：微码（或固件）是一种嵌入在硬件中的特殊程序，用来解释机器指令并控制底层硬件的操作。它位于硬件和机器码之间。<br>\n特点：微码作为硬件与机器码的桥梁，是指令执行的控制逻辑，可以在不改变硬件的情况下更新或调整计算机的功能。</li>\n<li>机器码层（Machine Code Level）<br>\n解释：机器码是计算机直接执行的二进制代码，通常以操作码（opcodes）和十六进制数字形式表示。它由一系列低级指令组成，用于控制计算机的处理器执行任务。<br>\n特点：机器码是最底层的可编程语言，只有计算机可以直接执行，由处理器按照指令执行具体操作。</li>\n<li>低级语言层（Low-Level Languages Level）<br>\n解释：低级语言是机器码的人类可读版本，例如汇编语言（Assembly Language）。它使用助记符（如 MOV、ADD、JMP 等）来代表机器指令，更易于编程和调试。<br>\n特点：低级语言紧密对应计算机的硬件结构，编程者需要了解具体的计算机架构，适合编写操作系统、驱动程序和嵌入式系统。</li>\n<li>高级语言层（High-Level Languages Level）<br>\n解释：高级语言（如 C、C++、Java 等）提供了更抽象、更人性化的语法和结构，使得编程者可以更轻松地编写复杂的程序。这些语言中的代码通过编译器转换成机器码。<br>\n特点：高级语言通常具有良好的跨平台性和可移植性，编程效率高，适合开发应用程序和大型软件系统。</li>\n<li>解释型语言层（Interpreted Languages Level）<br>\n解释：解释型语言（如 Python、JavaScript）不是直接编译成机器码，而是先被翻译成字节码，然后在解释器中执行。<br>\n特点：解释型语言更灵活，适合快速开发和原型设计，但执行速度通常比编译型语言慢。</li>\n<li>字节码层（Bytecode Level）<br>\n解释：字节码是高级语言在被解释执行之前的中间形式。解释器将字节码翻译为机器可以执行的指令。<br>\n特点：字节码的设计通常与硬件无关，可以在不同的平台上被相同的解释器执行，例如 Java 和 Python 的虚拟机（JVM、Python Interpreter）都使用字节码。</li>\n</ol>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b4d8733f64.png\" alt=\"img\"></p>\n<h2 id=\"Assembly\" class=\"active\"><a class=\"anchor\"  href=\"#Assembly\">#</a> Assembly</h2>\n<ol>\n<li>汇编语言（Assembly Language） 是一种低级编程语言，它与计算机的机器码有着一一对应的关系，并且比机器码更易于人类理解和编写。以下是对汇编语言及相关概念的详细中文解释：</li>\n</ol>\n<ul>\n<li>汇编语言的定义<br>\n汇编语言是最接近机器码的高级语言，它可以将机器指令用人类可读的助记符（如 MOV、ADD、JMP 等）来表示。这使得程序员能够直接控制硬件，同时比直接编写二进制代码更加方便。</li>\n<li>与机器码的关系<br>\n汇编语言是最可靠的、可以从机器码中恢复的高级语言。如果高层语言的源代码不可用时，通过反汇编（disassembly），可以将机器码转换回对应的汇编代码。<br>\n汇编语言和机器码之间的对应关系使得程序员可以清楚地了解计算机底层的执行逻辑和流程。</li>\n<li>脆弱代码和恶意软件的存储形式<br>\n在内存或磁盘中，脆弱代码或恶意软件通常以二进制形式（即机器码）存储。这种形式是计算机直接执行的代码，但对人类而言不可读。</li>\n<li>反汇编器的作用<br>\n反汇编器是一种工具，它以二进制代码为输入，并将其翻译成相应的汇编代码输出。通过反汇编，可以将机器码还原为人类可读的汇编语言，有助于分析和调试程序，特别是在逆向工程或安全分析中。</li>\n<li>汇编语言是多种语言的集合<br>\n汇编语言实际上是多种语言的集合，因为不同的计算机架构（如 x86、ARM、MIPS 等）有各自独特的指令集和汇编语言格式。<br>\n在学习和使用汇编语言时，通常会针对特定的计算机架构进行深入研究。例如，x86 汇编和 ARM 汇编在指令集、寄存器使用和指令格式上都有明显的不同。</li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b4f21f3929.png\" alt=\"img\"><br>\n 整个过程从汇编语言（asm 文件）开始，通过汇编器生成目标文件，再通过链接器将目标文件和库文件结合生成可执行文件，最后将可执行文件加载到内存中运行</p>\n<ul>\n<li>汇编器（Assembler）<br>\n汇编器的作用是将汇编语言的代码（asm 文件）翻译成目标文件（object file）。目标文件是二进制形式的文件，包含了机器可以理解的指令和数据，但还不是完整的可执行程序。</li>\n<li>链接器（Linker）<br>\n链接器的作用是将多个目标文件和库文件（如静态库或动态库）组合起来，生成一个完整的可执行文件（Executable）。<br>\n静态库（Static Library）：静态库中的代码在编译期间直接被链接到可执行文件中。<br>\n动态库（Dynamic Library）：动态库中的代码在运行时被加载到内存中。</li>\n</ul>\n<ol start=\"2\">\n<li>Assembler vs. Compiler</li>\n</ol>\n<ul>\n<li>编译器 (Compiler) vs. 汇编器 (Assembler)<br>\n 编译器：将高级编程语言的代码（如 C、C++、Java 等）转换为机器级代码。<br>\n汇编器：将汇编语言的代码转换为机器级代码。</li>\n<li>输入<br>\n编译器：以高级语言的源代码为输入。<br>\n汇编器：以汇编语言的代码为输入。</li>\n<li>转换方式<br>\n编译器：会检查并一次性将整个代码转换为机器代码。<br>\n汇编器：一般不一次性转换完整代码，而是分两步处理。</li>\n<li>内部模块<br>\n编译器：包含词法分析器、语法分析器、语义分析器、代码优化器和代码生成器等模块。(lexical analyzer, Syntax analyzer, Semantic analyzer, Code optimizer, Code generator)<br>\n 汇编器：在两次扫描中完成所有工作。</li>\n<li>输出结果<br>\n编译器：输出的是机器代码的助记符 (Mnemonic) 版本。<br>\n汇编器：输出的是机器代码的二进制版本。</li>\n<li>常见类型<br>\n编译器：如 C、C++、Java 的编译器。<br>\n汇编器：如 GAS（GNU Assembler）、GNU 汇编器</li>\n</ul>\n<ol start=\"3\">\n<li>Two main forms of assembly syntax</li>\n</ol>\n<ul>\n<li>NASM format: <instr> <dest>, <source> &lt;; comment&gt; : mov eax, 10</li>\n<li>AT&amp;T format:  <instr> <source>, <dest> &lt;# comment&gt;: mov $10, %eax<br>\nAT&amp;T format reverses the order of operands, uses a % before registers and a $ before literal values</li>\n</ul>\n<ol start=\"4\">\n<li>Fundamental Data Types</li>\n</ol>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b528c52025.png\" alt=\"img\"></p>\n<ul>\n<li>\n<p>Byte（字节）<br>\n大小：1 字节 = 8 位（bit）。<br>\n示例：图中展示的 5D 是一个 8 位的二进制数（01011101），它可以用一个字节来表示。<br>\n解释：一个字节的二进制位可以表示 0 到 255 之间的整数（无符号），或 -128 到 127 之间的整数（有符号）。</p>\n</li>\n<li>\n<p>Word（字）<br>\n大小：2 字节 = 16 位（bit）。<br>\n示例：图中展示的 8BEC 表示一个 16 位的二进制数，其中：<br>\n高字节（High Byte）：8B<br>\n 低字节（Low Byte）：EC<br>\n 解释：一个 Word 可以表示 0 到 65535 之间的无符号整数，或 -32768 到 32767 之间的有符号整数。</p>\n</li>\n<li>\n<p>Dword（双字）<br>\n大小：4 字节 = 32 位（bit）。<br>\n示例：图中展示的 000136CF 表示一个 32 位的二进制数，其中：<br>\n高字（High Word）：0001<br>\n 低字（Low Word）：36CF<br>\n 解释：一个 Dword 可以表示更大的整数范围，用于存储更大的数值或内存地址。</p>\n</li>\n<li>\n<p>Qword（四字）<br>\n大小：8 字节 = 64 位（bit）。<br>\n示例：图中展示的 CF000136CF 表示一个 64 位的二进制数，其中：<br>\n高双字（High Dword）：CF00<br>\n 低双字（Low Dword）：0136CF<br>\n 解释：一个 Qword 可以表示更大的整数或浮点数范围，常用于 64 位处理器上的运算。</p>\n</li>\n<li>\n<p>Data in Memory<br>\nLittle-endian format: a low-order byte is stored at the lower address<br>\n<img data-src=\"https://img.picui.cn/free/2024/10/25/671b538e3e57f.png\" alt=\"img\"></p>\n</li>\n</ul>\n<h2 id=\"CPU Registers\" class=\"active\"><a class=\"anchor\"  href=\"#CPU Registers\">#</a>CPU Registers</h2>\n<ol>\n<li>CPU 寄存器是 CPU 内部的一小部分数据存储单元，用于暂存指令、数据和状态信息。寄存器是 CPU 中速度最快的存储单元，比其他存储设备（如 RAM、硬盘）快得多，因为它们位于 CPU 内部，能够快速读写数据。<br>\nCPU 寄存器的类型</li>\n</ol>\n<ul>\n<li>通用寄存器（General Registers）<br>\n用途：在程序执行期间由 CPU 使用，用于存储数据、操作数和临时结果。<br>\n功能：可以用于整数运算、地址运算和数据的传输，是最常用的寄存器类型。</li>\n<li>段寄存器（Segment Registers）<br>\n用途：用于管理和跟踪内存的不同段（如代码段、数据段和栈段）。<br>\n功能：帮助 CPU 确定内存访问的具体区域，使得内存分段管理更加高效。</li>\n<li>状态标志（Status Flags）<br>\n用途：存储程序执行的状态信息，例如运算结果是正、负、零，或是否发生溢出等。<br>\n功能：在 CPU 进行条件判断或决策时提供必要的信息支持，决定程序的执行路径。</li>\n<li>指令指针（Instruction Pointers）<br>\n用途：用于跟踪下一条将要执行的指令的地址。<br>\n功能：确保程序的指令按顺序执行，是控制程序流程的关键寄存器。</li>\n</ul>\n<ol start=\"2\">\n<li>x86 Registers\n<ol>\n<li>数据寄存器（Data Registers）\n<ul>\n<li>EAX（累加器）：主要用于输入 / 输出和大多数算术运算。例如，加法、减法、乘法和除法操作时，通常会用到 EAX。</li>\n<li>EBX（基址寄存器）：可用于索引寻址模式，即在访问数组或结构中的元素时，EBX 可以作为基址寄存器使用。</li>\n<li>ECX（计数寄存器）：在循环操作中存储循环计数，通常用于实现迭代操作。</li>\n<li>EDX（数据寄存器）：也用于输入 / 输出操作，有时与 AX 一起使用，例如在某些乘法和除法运算中。</li>\n</ul>\n</li>\n<li>索引寄存器（Index Registers）\n<ul>\n<li>ESI（源索引）：用于字符串操作的源索引，通常在数据的读取操作中使用。</li>\n<li>EDI（目标索引）：用于字符串操作的目标索引，通常在数据的写入操作中使用。</li>\n</ul>\n</li>\n<li>段寄存器（Segment Registers）\n<ul>\n<li>CS（代码段寄存器）：指向包含所有将要执行的指令的代码段。</li>\n<li>DS（数据段寄存器）：指向包含全局数据、常量和工作区的数据段。</li>\n<li>SS（栈段寄存器）：指向包含局部数据和过程或子程序返回地址的栈段。</li>\n<li>其他段寄存器（ES、FS、GS）：提供额外的数据存储段，用于存放其他类型的数据。<br>\n在段内的所有内存位置都相对于段的起始地址。</li>\n</ul>\n</li>\n<li>状态寄存器（Status Register）\n<ul>\n<li>EFLAGS 寄存器：用于存储处理器的状态标志，每个标志位表示不同的状态或条件：</li>\n<li>ZF（零标志）：当运算结果为零时设置。</li>\n<li>CF（进位标志）：当运算结果过大或过小时设置。</li>\n<li>SF（符号标志）：当运算结果为负时设置。</li>\n<li>TF（陷阱标志）：用于调试，设置该标志时，处理器一次只执行一条指令。通常被调试工具（如 GDB）使用。</li>\n</ul>\n</li>\n<li>指令指针（Instruction Pointer, EIP）也称为程序计数器，它包含下一条将被执行的指令的偏移地址。\n<ul>\n<li>EIP 的唯一目的是告诉处理器下一步要执行什么指令。</li>\n<li>当前指令的完整地址为 CS:EIP（代码段寄存器加指令指针）。</li>\n<li>如果攻击者能够控制 EIP，他们就能控制 CPU 的执行流程，因此 EIP 是常见攻击（如缓冲区溢出）的目标。</li>\n</ul>\n</li>\n<li>其他指针寄存器（Other Pointer Registers）\n<ul>\n<li>ESP（栈指针寄存器）：提供程序栈中的偏移值，SS:ESP 表示栈顶（当前数据或地址在程序栈中的位置）。</li>\n<li>EBP（基址指针寄存器）：主要用于引用传递给子程序的参数变量（如函数调用）。SS:EBP 表示当前调用的栈帧 (stack frame)。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"Assembly basics\" class=\"active\"><a class=\"anchor\"  href=\"#Assembly basics\">#</a> Assembly basics</h1>\n<h2 id=\"Simple Instructions\" class=\"active\"><a class=\"anchor\"  href=\"#Simple Instructions\">#</a>Simple Instructions</h2>\n<ol>\n<li>mov instruction</li>\n</ol>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b589f37dc7.png\" alt=\"img\"></p>\n<p>lea (load effective address) instruction puts a memory address into the<br>\ndestination</p>\n<ul>\n<li>e.g. lea eax, [ebx+8] puts EBX+8 into EAX</li>\n<li>e.g. mov eax, [ebx+8] loads the data at the memory address EBX+8</li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b595145504.png\" alt=\"img\"></p>\n<ul>\n<li>mov eax, [ebx+8] places the value 0x20 into EAX</li>\n<li>lea eax, [ebx+8] places the value 0xB30048 into EAX</li>\n</ul>\n<ol start=\"2\">\n<li>Arithmetic</li>\n</ol>\n<ul>\n<li>sub eax, 0x10<br>\n 描述：从寄存器 EAX 中减去 0x10（十六进制的 16）。<br>\n结果：EAX 的值减少 16。</li>\n<li>add eax, ebx<br>\n 描述：将寄存器 EBX 的值加到 EAX 中，并将结果存储在 EAX 中。<br>\n结果：EAX = EAX + EBX。</li>\n<li>inc edx<br>\n 描述：将寄存器 EDX 的值加 1。<br>\n结果：EDX 的值增加 1。</li>\n<li>dec ecx<br>\n 描述：将寄存器 ECX 的值减 1。<br>\n结果：ECX 的值减少 1。</li>\n<li>mul 0x50<br>\n 描述：将寄存器 EAX 的值乘以 0x50（十六进制的 80），并将结果存储在 EDX<br>\n 中。<br>\n结果：EAX 中存储低 32 位的乘积，EDX 中存储高 32 位的乘积。</li>\n<li>div 0x75<br>\n 描述：用寄存器 EDX<br>\n（将 EDX 和 EAX 结合起来，表示 64 位的数值）除以 0x75（十六进制的 117）。<br>\n结果：商存储在 EAX 中，余数存储在 EDX 中。</li>\n</ul>\n<ol start=\"3\">\n<li>Logics</li>\n</ol>\n<ul>\n<li>xor eax, eax<br>\n 描述：将寄存器 EAX 和自身进行异或操作，清除 EAX 中的值（即将 EAX 置为 0）。<br>\n结果：EAX = 0。</li>\n<li>or eax, 0x7575<br>\n 描述：对 EAX 寄存器和 0x7575 进行逻辑或（OR）操作。<br>\n结果：EAX 的每个位都与 0x7575 的相应位进行或操作。</li>\n<li>mov eax, 0xA 和 shl eax, 2<br>\nmov eax, 0xA：将 EAX 设置为 0xA（十六进制的 10）。<br>\nshl eax, 2：将 EAX 寄存器中的值左移 2 位。<br>\n结果：EAX 的值变为 0x28（十六进制的 40），因为二进制的 1010 左移 2 位变为 101000。</li>\n<li>mov bl, 0xA 和 ror bl, 2<br>\nmov bl, 0xA：将 BL 设置为 0xA（十六进制的 10）。<br>\nror bl, 2：将 BL 寄存器中的值右旋 2 位。<br>\n结果：BL 的值变为 10000010，因为二进制的 1010 右旋 2 位变为 10000010。</li>\n</ul>\n<ol start=\"4\">\n<li>nop<br>\n 描述：NOP 指令不执行任何操作，仅仅让处理器继续执行下一条指令。<br>\n作用：NOP 实际上是 xchg eax, eax 的伪指令，因为将 EAX 与自身交换不会改变任何值。<br>\n用途：在缓冲区溢出攻击中，攻击者常使用 NOP 指令来填充攻击代码，使得执行具有一定的缓冲空间。NOP 的操作码是 0x90。</li>\n</ol>\n<h2 id=\"The Stack\" class=\"active\"><a class=\"anchor\"  href=\"#The Stack\">#</a>The Stack</h2>\n<ol>\n<li>栈的基本概念<br>\n栈 是一种 后进先出（LIFO） 的数据结构，这意味着最后放入的数据将是第一个被取出的。<br>\n栈通常用于存储函数调用的参数、局部变量、返回地址和一些控制信息。<br>\n栈的主要寄存器包括：<br>\nESP（栈指针）：指向当前栈顶。<br>\nEBP（基址指针）：跟踪局部变量和函数参数的位置。</li>\n<li>栈指令<br>\n栈操作包括以下几种常见指令：</li>\n</ol>\n<ul>\n<li>push：将数据压入栈中，ESP 会减少（栈向下增长）。</li>\n<li>pop：从栈中弹出数据，ESP 会增加。</li>\n<li>call：调用函数，将当前指令的地址压入栈中，并跳转到指定函数的位置。</li>\n<li>leave：用于函数返回时，将栈恢复到调用者的状态。</li>\n<li>enter：为新函数栈帧分配空间，保存当前的 EBP，并更新 EBP 为新栈帧的起始位置。</li>\n<li>ret：函数返回，将栈顶的返回地址弹出到 EIP 中，恢复程序的执行。</li>\n</ul>\n<ol start=\"3\">\n<li>函数调用的栈操作<br>\n在函数调用过程中，栈的使用通常按照以下步骤进行：</li>\n</ol>\n<ul>\n<li>参数入栈：使用 push 指令将函数的参数依次压入栈中。</li>\n<li>调用函数：使用  <code>call &lt;location&gt;</code>  指令调用函数。当前指令地址（EIP）会被压入栈中，便于函数执行完毕后返回。EIP 将被设置为函数的起始地址（ <code>&lt;location&gt;</code> ）。</li>\n<li>保存局部变量和 EBP：函数调用后，局部变量和调用者的 EBP 被压入栈中，用于为新函数栈帧分配空间。</li>\n<li>执行函数：函数内部执行具体的任务，包括访问局部变量、处理逻辑和修改数据。</li>\n<li>恢复局部变量和调用者的 EBP：使用 leave 指令，将 EBP 和局部变量恢复为调用者的状态。</li>\n<li>恢复 EIP：使用 ret 指令，将栈顶的返回地址弹出到 EIP 中，以继续执行调用函数的程序。</li>\n<li>清理参数：参数在函数返回后可能需要被清理，从而恢复栈的平衡状态。</li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b64bb0713f.png\" alt=\"img\"></p>\n<h2 id=\"Conditionals and Branching\" class=\"active\"><a class=\"anchor\"  href=\"#Conditionals and Branching\">#</a>Conditionals and Branching</h2>\n<ol>\n<li>条件指令（Conditionals）\n<ol>\n<li>test 指令</li>\n</ol>\n<ul>\n<li>功能：test 指令类似于逻辑与（AND）操作，但不会修改操作数，只用于设置标志位。</li>\n<li>标志位：主要设置 ZF（零标志）。如果操作数之间的逻辑与结果为零，则 ZF 被置 1，否则置 0。</li>\n<li>用法：通常用于检查某个位是否被设置，例如判断一个变量是否为零或检测特定位是否为 1。</li>\n</ul>\n<ol start=\"2\">\n<li>cmp 指令</li>\n</ol>\n<ul>\n<li>功能：cmp 指令类似于减法（SUB）操作，但不会改变操作数的值，只用于设置标志位。</li>\n<li>标志位：主要设置 ZF（零标志） 和 CF（进位标志）。</li>\n<li>ZF（零标志）：当两个操作数相等时，ZF 被置 1。</li>\n<li>CF（进位标志）：当目标操作数小于源操作数时，CF 被置 1。</li>\n<li>用法：通常用于比较两个数值大小，以决定下一步的条件跳转。</li>\n</ul>\n<ol start=\"3\">\n<li>cmp 指令的标志位结果<br>\n cmp dst, src 的不同结果下的标志位变化：</li>\n</ol>\n<ul>\n<li>dst = src：ZF = 1, CF = 0（目标操作数等于源操作数）。</li>\n<li>dst &lt; src：ZF = 0, CF = 1（目标操作数小于源操作数）。</li>\n<li>dst &gt; src：ZF = 0, CF = 0（目标操作数大于源操作数）。</li>\n</ul>\n</li>\n<li>分支指令（Branching）<br>\n分支是根据程序的控制流有条件地执行代码序列。分支指令决定程序在特定条件下的跳转。\n<ol>\n<li>无条件跳转（Unconditional Jump）</li>\n</ol>\n<ul>\n<li>jmp <location>：无条件跳转指令会直接跳转到指定的位置（<location>），无论条件是否满足。</li>\n<li>用法：无条件跳转用于改变程序的执行顺序，是一种不依赖标志位的跳转形式。</li>\n</ul>\n<ol start=\"2\">\n<li>条件跳转（Conditional Jump）</li>\n</ol>\n<ul>\n<li>条件跳转指令：使用标志寄存器的值来决定是否进行跳转。常见的条件跳转指令有超过 30 种。</li>\n</ul>\n</li>\n</ol>\n","categories":["课程笔记","Principles of Software Security"],"tags":["C language","Linux","software security","gdb"]}]