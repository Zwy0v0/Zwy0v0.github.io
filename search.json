[{"title":"Hello World","url":"/hello-world/","content":"<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n"},{"title":"第一篇ovo","url":"/dailysharing/%E7%AC%AC%E4%B8%80%E7%AF%87ovo/","content":"<p>这是第一篇~</p>\n","categories":["日常碎碎念"],"tags":["Blog","日常"]},{"title":"JS中的this与相关函数","url":"/study/JS%E4%B8%AD%E7%9A%84this%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/","content":"<h1 id=\"this指向\" class=\"active\"><a class=\"anchor\"  href=\"#this指向\">#</a> this指向</h1>\n在非严格模式下，总是指向一个对象，在严格模式下可以是任意值，开启严格模式可以使用如下两种方式:\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为整个脚本开启严格模式</span></span><br><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span></span><br><span class=\"line\">unction <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 为函数开启严格模式</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;use strict&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n然后就可以根据不同的模式来确认this指向啦，\n\n<ol>\n<li><p>全局执行环境中,指向全局对象(非严格模式、严格模式)</p>\n</li>\n<li><p>函数内部,取决于函数被调用的方式</p>\n<ol>\n<li><p>直接调用的this值:</p>\n<ol>\n<li>非严格模式:全局对象(window)</li>\n<li>严格模式:undefined</li>\n</ol>\n</li>\n<li><p>对象方法调用的this值:<br>调用者</p>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"如何改变this指向\" class=\"active\"><a class=\"anchor\"  href=\"#如何改变this指向\">#</a> 如何改变this指向</h1>\n\n<ol>\n<li><p>调用函数并传入具体的<code>this</code>:</p>\n<ol>\n<li><p><code>call</code>:</p>\n<ol>\n<li>参数1:<code>this</code></li>\n<li>参数2:传递给函数的参数</li>\n</ol>\n</li>\n<li><p><code>apply</code>: 数组作为参数</p>\n<ol>\n<li>参数1:<code>this</code></li>\n<li>参数2:以数组的形式,传递给函数的参数</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>创建绑定<code>this</code>的函数:</p>\n<ol>\n<li>bind:返回一个绑定了<code>this</code>的新函数</li>\n<li>箭头函数:就近向父级找<code>this</code><h1 id=\"手搓call apply bind\" class=\"active\"><a class=\"anchor\"  href=\"#手搓call apply bind\">#</a> 手搓call apply bind</h1>\n  <h2 id=\"手搓call\" class=\"active\"><a class=\"anchor\"  href=\"#手搓call\">#</a> 手搓call</h2></li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbA==\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//手写myCall 任何函数都能调用所以写到构造函数的原型上</span></span><br><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">myCall</span> = <span class=\"keyword\">function</span> (<span class=\"params\">thisArg, ...args</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//使用Symobl产生绝对唯一属性 防止传入对象中含有与新增属性重名的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> z = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;z&#x27;</span>)</span><br><span class=\"line\">  <span class=\"comment\">//this指的是调用myCall的函数 thisArg为传入的需要设置为this的对象</span></span><br><span class=\"line\">  thisArg[z] = <span class=\"variable language_\">this</span></span><br><span class=\"line\">  <span class=\"comment\">//args为传入调用myCall的函数的参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = thisArg[z](...args)</span><br><span class=\"line\">  <span class=\"comment\">//删掉传入对象新增属性z</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span> thisArg[z]</span><br><span class=\"line\">  <span class=\"comment\">//返回myCall调用者的结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"手搓apply\" class=\"active\"><a class=\"anchor\"  href=\"#手搓apply\">#</a> 手搓apply</h2>\n\n\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYXBwbHk=\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//手写myApply</span></span><br><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">myApply</span> = <span class=\"keyword\">function</span> (<span class=\"params\">thisAry, args</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//与myCall唯一的不同就是传入的args参数为数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> w = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">  thisAry[w] = <span class=\"variable language_\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = thisAry[w](...args)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> thisAry[w]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"手搓bind\" class=\"active\"><a class=\"anchor\"  href=\"#手搓bind\">#</a> 手搓bind</h2>\n\n\n<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZA==\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">myBind</span> = <span class=\"keyword\">function</span> (<span class=\"params\">thisArg, ...args</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//this是调用myBind的原函数 要把thisArg设置为新函数的this</span></span><br><span class=\"line\">  <span class=\"comment\">//...args是需要绑定的参数 ...reArgs是新函数需要传入的参数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...reArgs</span>) =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">call</span>(thisArg, ...args, ...reArgs)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","categories":["自学笔记","JavaScript"],"tags":["JavaScript"]},{"title":"js继承","url":"/study/js%E7%BB%A7%E6%89%BF/","content":"<h1 id=\"ES5\" class=\"active\"><a class=\"anchor\"  href=\"#ES5\">#</a> ES5</h1>\n<h2 id=\"ES5 原型链继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 原型链继承\">#</a> ES5 原型链继承</h2>\n\n<ol>\n<li>将父类的实例作为子类的原型实现继承</li>\n<li>这种继承方法的缺点是父类中的引用类型数据会被所有子类共享<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Son</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>(<span class=\"string\">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"ES5 构造函数继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 构造函数继承\">#</a> ES5 构造函数继承</h2>\n\n<ol>\n<li>在子类的构造函数中通过<code>call</code>或者<code>apply</code>调用父类的构造函数</li>\n<li>这种继承方法的缺点是:子类没法使用父类原型上的属性&#x2F;方法<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Son</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"ES5 组合继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 组合继承\">#</a> ES5 组合继承</h2>\n\n<ol>\n<li>组合继承结合上面2种方法的优点:<ol>\n<li>通过原型链继承公共的属性和方法</li>\n<li>通过构造函数继承实例独有的属性和方法</li>\n</ol>\n</li>\n<li>组合继承的特点:调用2次父类的构造函数,浪费性能<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子类构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Son</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用父类构造函数传入this</span></span><br><span class=\"line\">  <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name)</span><br><span class=\"line\">  <span class=\"comment\">// 子类独有的属性和方法单独设置</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 设置子类的原型为 父类实例</span></span><br><span class=\"line\"><span class=\"title class_\">Son</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>()</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"ES5 原型式继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 原型式继承\">#</a> ES5 原型式继承</h2>\n\n<ol>\n<li>直接基于对象实现继承，对某个对象进行浅拷贝,可以通过内置api<code>Object.create</code>实现,不需要调用构造函数即可实现继承,主要针对于继承对象的情况</li>\n<li>原型式继承的缺点是:父类中的引用数据类型，会被所有子类共享<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZQ==\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以用 Object.create替代</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">objectFactory</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">Fun</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  <span class=\"title class_\">Fun</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = obj</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Fun</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parent = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;parent&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">25</span>,</span><br><span class=\"line\">  <span class=\"attr\">friend</span>: [<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"string\">&#x27;aa&#x27;</span>],</span><br><span class=\"line\">  <span class=\"title function_\">sayHi</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">age</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> son1 = <span class=\"title function_\">objectFactory</span>(parent)</span><br><span class=\"line\"><span class=\"comment\">//const son1 = Object.create(parent)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> son2 = <span class=\"title function_\">objectFactory</span>(parent)</span><br><span class=\"line\">son1.<span class=\"property\">friend</span>.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;Gin&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(son2.<span class=\"property\">friend</span>)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"ES5 寄生式继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 寄生式继承\">#</a> ES5 寄生式继承</h2>\n\n<ol>\n<li>寄生式继承的核心步骤是:基于对象创建新对象(可以使用<code>Object.create</code>),并且为新创建的对象增加新的属性和方法,通过定义工厂函数,并在内部:<ol>\n<li>对传入的对象进行浅拷贝(公共属性&#x2F;方法)</li>\n<li>为浅拷贝对象增加属性&#x2F;方法(独有属性&#x2F;方法)</li>\n</ol>\n</li>\n<li>寄生式继承和原型式继承的区别是:创建出来的新对象,会额外的增加新的<strong>属性&#x2F;方法</strong><figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createAnother</span>(<span class=\"params\">origin</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Object.create基于原型创建新对象，对属性进行浅拷贝</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> clone = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(origin)</span><br><span class=\"line\">  <span class=\"comment\">// 为对象增加属性/方法</span></span><br><span class=\"line\">  clone.<span class=\"property\">sayHi</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;你好&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parent = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;parent&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">friend</span>: [<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"string\">&#x27;aa&#x27;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> son1 = <span class=\"title function_\">createAnother</span>(parent)</span><br><span class=\"line\"><span class=\"keyword\">const</span> son2 = <span class=\"title function_\">createAnother</span>(parent)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"ES5 寄生组合式继承\" class=\"active\"><a class=\"anchor\"  href=\"#ES5 寄生组合式继承\">#</a> ES5 寄生组合式继承</h2>\n\n<ol>\n<li>通过构造函数来继承属性,通过原型链来继承方法</li>\n<li>寄生组合式继承和组合式继承的区别是:原型链的继承并没有调用父类的构造函数,而是直接基于父类的原型创建一个新副本实现继承<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承原型函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inheritPrototype</span>(<span class=\"params\">son, parent</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> prototype = object.<span class=\"title function_\">create</span>(parent.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)</span><br><span class=\"line\">    prototype.<span class=\"property\">constructor</span> = son</span><br><span class=\"line\">    son.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = prototype</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Parent</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">friends</span> = [<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"string\">&#x27;aa&#x27;</span>,<span class=\"string\">&#x27;ss&#x27;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Parent</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHi</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>, <span class=\"string\">`My friends are,<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.friends&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类借用父类的构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Son</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name)</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 完成原型继承</span></span><br><span class=\"line\"><span class=\"title function_\">inheritPrototype</span>(<span class=\"title class_\">Son</span>,<span class=\"title class_\">Parent</span>)</span><br><span class=\"line\"><span class=\"comment\">// 可以继续在原型上添加属性/方法</span></span><br><span class=\"line\"><span class=\"title class_\">Son</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayAge</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我的年龄是&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">age</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> son1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>(<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> son2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>(<span class=\"string\">&#x27;hh&#x27;</span>, <span class=\"number\">19</span>)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"ES6\" class=\"active\"><a class=\"anchor\"  href=\"#ES6\">#</a> ES6</h1>\n\n<h2 id=\"class核心语法\" class=\"active\"><a class=\"anchor\"  href=\"#class核心语法\">#</a> class核心语法</h2>\n\n<ol>\n<li>通过<code>class 类名&#123;&#125;</code>的形式来定义类</li>\n<li>内部直接写实例属性,可以设置默认值,</li>\n<li>实例方法的添加方式为<code>方法名()&#123;&#125;</code></li>\n<li>构造函数通过<code>constructor</code>进行添加</li>\n<li>通过<code>new 类名()</code>创建实例,会调用构造函数<code>constructor</code><figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9jbGFzcw==\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Parent</span>&#123;</span><br><span class=\"line\">    name</span><br><span class=\"line\">    friends = [<span class=\"string\">&#x27;zz&#x27;</span>, <span class=\"string\">&#x27;aa&#x27;</span>,<span class=\"string\">&#x27;ss&#x27;</span>]</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"title function_\">sayHi</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;你好,我叫:&#x27;</span>,<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"class实现继承\" class=\"active\"><a class=\"anchor\"  href=\"#class实现继承\">#</a> class实现继承</h2>\n\n<ol>\n<li>子类通过<code>extends</code>继承继承父类</li>\n<li>子类如果需要重新定义构造函数,必须在内部通过<code>super</code>关键字调用父类的构造函数<figure class=\"highlight javascript\"><figcaption><span>(●ˇ∀ˇ●)</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3N1cGVy\">参考链接</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Parent</span> &#123;</span><br><span class=\"line\">  age</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 子类构造函数使用this以前必须调用super</span></span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(name)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加方法</span></span><br><span class=\"line\">  <span class=\"title function_\">sayHey</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`我叫<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>,我今年<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.age&#125;</span>岁`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>(<span class=\"string\">&#x27;yy&#x27;</span>, <span class=\"string\">&#x27;18&#x27;</span>)</span><br><span class=\"line\">s.<span class=\"title function_\">sayHi</span>()</span><br><span class=\"line\">s.<span class=\"title function_\">sayHey</span>()</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"class私有,静态属性和方法\" class=\"active\"><a class=\"anchor\"  href=\"#class私有,静态属性和方法\">#</a> class私有,静态属性和方法</h2>\n\n<ol>\n<li><p>class中私有属性&#x2F;方法</p>\n<ol>\n<li><strong>定义和使用时</strong>需要使用关键字<code>#</code></li>\n<li>私有属性只能在类的内部使用,外部无法使用(代码中)</li>\n<li><strong>Chrome</strong>的控制台中为了方便调试,可以直接访问</li>\n</ol>\n</li>\n<li><p>class中静态属性&#x2F;方法</p>\n<ol>\n<li><strong>定义和使用时</strong>需要使用关键字<code>static</code></li>\n<li>通过类访问</li>\n<li>静态方法中的<code>this</code>是类本身</li>\n</ol>\n</li>\n</ol>\n","categories":["自学笔记","JavaScript"],"tags":["JavaScript"]},{"title":"C language basics and Computer memory","url":"/course/C-language-basics-and-Computer-memory/","content":"<h1 id=\"C language basics\" class=\"active\"><a class=\"anchor\"  href=\"#C language basics\">#</a>C language basics</h1>\n<h2 id=\"input/output\" class=\"active\"><a class=\"anchor\"  href=\"#input/output\">#</a> input/output</h2>\n\n<ol>\n<li>To print output to the terminal screen:</li>\n</ol>\n<ul>\n<li>printf(“Hello\\n”);</li>\n<li>printf(“Hello %s”, “haxor”);  &#x2F;&#x2F; using a format string</li>\n</ul>\n<ol start=\"2\">\n<li>To get input from the user:</li>\n</ol>\n<ul>\n<li>scanf(“%d”, &amp;number);</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>Input/output format symbols</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test\\n&quot;</span>);   <span class=\"comment\">// `\\n`:  Carriage return/new line</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test %d&quot;</span>, <span class=\"number\">123</span>);  <span class=\"comment\">//`%d`:  Decimal value</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test %s&quot;</span>, <span class=\"string\">&quot;123&quot;</span>);  <span class=\"comment\">//`%s`:  String value</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test %x&quot;</span>, <span class=\"number\">0x123</span>);  <span class=\"comment\">//`%x`:  Hex value</span></span><br></pre></td></tr></table></figure>\n\n <figure class=\"highlight c\"><figcaption><span>C Program takes command-line arguments</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//meet.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\">greeting(<span class=\"type\">char</span> *temp1, <span class=\"type\">char</span> *temp2) <span class=\"comment\">// greeting function to say hello</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">400</span>];  <span class=\"comment\">// string variable to hold the name</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(name, temp2);  <span class=\"comment\">// copy function argument to name</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello %s %s\\n&quot;</span>, temp1, name);  <span class=\"comment\">// print out the greeting</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[]) <span class=\"comment\">// note the format for arguments</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    greeting(argv[<span class=\"number\">1</span>], argv[<span class=\"number\">2</span>]);  <span class=\"comment\">// call function, pass title &amp; name</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Bye %s %s\\n&quot;</span>, argv[<span class=\"number\">1</span>], argv[<span class=\"number\">2</span>]);  <span class=\"comment\">// say “bye&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Compiling C programs\" class=\"active\"><a class=\"anchor\"  href=\"#Compiling C programs\">#</a> Compiling C programs</h2>\nCompiling C programs(Linux) Using gcc\n\n<ol>\n<li><p>To compile our <code>meet.c</code> program, type</p>\n <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$gcc</span> -o meet meet.c</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Then to execute the new program, type</p>\n <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./meet zz</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Commonly used gcc flags</p>\n</li>\n</ol>\n<ul>\n<li>-o <filename>: produces compiled binary file with filename (a.out by default).</li>\n<li>-S: produces assembly code in a file; saved with a .s extension</li>\n<li>-g, -ggdb: produces extra debugging information for gdb (GNU debugger)</li>\n<li>-c: compiles without linking; produces object files with an .o extension</li>\n<li>Check out manual by using: man gcc</li>\n</ul>\n<ol start=\"4\">\n<li>32-bit vs 64-bit compilation</li>\n</ol>\n<ul>\n<li>To compile into 32-bit binaries: <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$gcc</span> -m32 hello.c -o hello</span><br></pre></td></tr></table></figure></li>\n<li>install a standard library of  <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$sudo</span> apt install gcc-multilib </span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"C vs C#\" class=\"active\"><a class=\"anchor\"  href=\"#C vs C#\">#</a> C vs C#</h2>\n\n<ol>\n<li>C# is type-safe</li>\n</ol>\n<ul>\n<li>Strong static type system + runtime checks (e.g. bounds, type casts) + automatic memory management</li>\n</ul>\n<ol start=\"2\">\n<li>C is type-unsafe</li>\n</ol>\n<ul>\n<li>Pointers + no runtime check (out-of-bound access, bad type casts), manual memory management<br>Runtime array bounds check in C#</li>\n</ul>\n<p>If the following C# code is executed on .NET:<br> <figure class=\"highlight c#\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"> arr[<span class=\"number\">10</span>] = <span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure><br>An exception will be raised at runtime!</p>\n<p>The length of the array is recorded and checked by the runtime</p>\n<ul>\n<li>The length of an array is fixed once created</li>\n</ul>\n<p>No runtime array bounds check in C, If the same C code is executed:<br> <figure class=\"highlight c\"><figcaption><span>(●ˇ∀ˇ●)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"> arr[<span class=\"number\">10</span>] = <span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure><br>No error, result in a silent buffer overflow!</p>\n<ul>\n<li>Unexpected behaviours such as mysterious crashes depending on what was overwritten</li>\n<li>Attackers may exploit this if they can control the overwritten data</li>\n</ul>\n<ol start=\"3\">\n<li>Automatic memory management in C#</li>\n</ol>\n<p>Programmers do not write code to perform memory management tasks<br>Garbage collector manages the allocation and release of memory<br>C# has no common memory problems such as buffer overflow</p>\n<ol start=\"4\">\n<li>C# strings</li>\n</ol>\n<p>C# strings are <code>objects</code> of the <code>String</code> class</p>\n<ul>\n<li>Similar to an array of chars, but immutable</li>\n<li>The length is stored on the object for bounds checks at runtime</li>\n</ul>\n<p>All string manipulation operations do not modify the original string</p>\n<ul>\n<li>A new string is created upon modification</li>\n<li>For example, <code>str.Trim()</code> returns a new string</li>\n</ul>\n<ol start=\"5\">\n<li>C strings</li>\n</ol>\n<p>C strings are arrays of characters</p>\n<ul>\n<li>Terminated by and including the first occurrence of the null character <code>\\0</code></li>\n</ul>\n<p>String length is not automatically tracked</p>\n<ul>\n<li>It is determined by the number of bytes (character) preceding the null character. </li>\n<li>The memory required to store a string is the number of characters plus one</li>\n</ul>\n<p>A string can be manipulated just like any other arrays</p>\n<ul>\n<li>We usually use some built-in string functions in C libraries <figure class=\"highlight c\"><figcaption><span>copy one string to another</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span>    <span class=\"comment\">// use string library     </span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;Hello, Z&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(str2, str1);  <span class=\"comment\">// copy each character in str1 into str2</span></span><br></pre></td></tr></table></figure>\n The function <code>strcpy</code> copies each character in the source string (a series of characters ending with and including a null character) into the destination string <figure class=\"highlight c\"><figcaption><span>To compare two strings</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"> <span class=\"type\">char</span> str2[] = <span class=\"string\">&quot;haxor&quot;</span>;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(str1, str2) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Strings are the same.\\n&quot;</span>);</span><br><span class=\"line\"> <span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Strings are different.\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n This code prints out: Strings are different.<br> Note that the function <code>strcmp()</code> does not return a <code>boolean</code> result</li>\n<li>Zero represents false, anything else represents true</li>\n<li>No <code>boolean</code> type in C language prior to C99</li>\n</ul>\n<ol start=\"6\">\n<li><strong>Other common string functions</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQ19Qcm9ncmFtbWluZy9TdHJpbmdfbWFuaXB1bGF0aW9u\">More can be found</span><br> <code>strlen</code>: gets the length of a string<br> <code>strncpy</code>: copies one string to another with a bound<br> <code>strcat</code>, <code>strncat</code>: string concatenation<br> <code>gets</code>, <code>fgets</code>: receives input into a string</li>\n</ol>\n<h2 id=\"C strings is error prone\" class=\"active\"><a class=\"anchor\"  href=\"#C strings is error prone\">#</a>C strings is error prone</h2>\n\n<ol>\n<li>Common string manipulation errors:</li>\n</ol>\n<ul>\n<li>Buffer errors</li>\n<li>Heap errors</li>\n<li>Out‐by‐bound errors</li>\n<li>Integer overflows</li>\n<li>Other memory, pointer and type errors</li>\n</ul>\n<p><strong>When data is copied from an unbounded source to a fixed‐length sink</strong><br> <figure class=\"highlight c\"><figcaption><span>Unbounded string copy</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> \t<span class=\"type\">char</span> username[<span class=\"number\">8</span>];</span><br><span class=\"line\"> \t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please enter your username:&quot;</span>);</span><br><span class=\"line\"> \tgets(username);</span><br><span class=\"line\"> \t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Your username is %s\\n&quot;</span>, username);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>Use of <code>gets()</code> Function</li>\n</ul>\n<p>The function <code>gets()</code> reads input from the user into a buffer, but it does not check the length of the input against the buffer’s size.<br>In this code, the <code>username</code> array is only 8 bytes long. However, <code>gets()</code> allows users to enter an input of any length, which means it can write beyond the 8 bytes allocated for <code>username</code>.<br>This can cause a buffer overflow, which can lead to memory corruption, unexpected behavior, or even security vulnerabilities where attackers can execute arbitrary code.</p>\n<ul>\n<li>Fixed-Length Buffer</li>\n</ul>\n<p>The username array is declared to have a size of 8, but we need to reserve one byte for the null-terminator <code>\\0</code>, which marks the end of the string.<br>This means only 7 characters can safely be stored in the username buffer.<br>If the input exceeds this limit, it will overflow into adjacent memory, potentially causing the program to crash or behave unpredictably.<br> <figure class=\"highlight c\"><figcaption><span>Unbounded string copy(fixed)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> username[<span class=\"number\">8</span>];  <span class=\"comment\">// Buffer limited to 8 bytes</span></span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please enter your username:&quot;</span>);</span><br><span class=\"line\">    fgets(username, <span class=\"keyword\">sizeof</span>(username), <span class=\"built_in\">stdin</span>);  <span class=\"comment\">// Limit input size to prevent overflow</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Your username is %s\\n&quot;</span>, username);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">// Standard return type</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>Better string functions from libraries</strong><br> Should use functions that restrict the number of bytes for safer programming</p>\n<ul>\n<li>Use <code>fgets()</code>, instead of <code>gets()</code></li>\n<li>Use <code>strncpy()</code>, instead of <code>strcpy()</code></li>\n<li>Use <code>strncat()</code>, instead of <code>strcat()</code></li>\n<li>Use <code>snprintf()</code>, instead of instead of <code>sprintf()</code></li>\n</ul>\n<p><strong>Null‐termination errors</strong><br> <figure class=\"highlight c\"><figcaption><span>Null‐termination errors</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr, <span class=\"string\">&quot;0123456789&quot;</span>, <span class=\"keyword\">sizeof</span>(arr));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, arr);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>The array is not properly terminated by a null character! </p>\n<ul>\n<li>When there is no null character among the first n character of the source, the string placed in the<br>destination will not be null-terminated!<br>The <code>printf()</code> call prints out all bytes as character till reaching a null!</li>\n</ul>\n<p>To test out, let’s add another array:<br> <figure class=\"highlight c\"><figcaption><span>Null‐termination errors</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr2[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr, <span class=\"string\">&quot;0123456789&quot;</span>, <span class=\"keyword\">sizeof</span>(arr));</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr2, <span class=\"string\">&quot;9876543210&quot;</span>, <span class=\"keyword\">sizeof</span>(arr2));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, arr);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br> The program will print out 01234567899876543210<br> Where the length of source string is the same or greater than the length of target string</p>\n<ul>\n<li>The source string gets truncated</li>\n<li>The target string may not be properly terminated by null!</li>\n</ul>\n<p> How can we fix it?<br> Manually add a null character at the end of the target string:<br> <figure class=\"highlight c\"><figcaption><span>Null‐termination errors(fixed)</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr, <span class=\"string\">&quot;0123456789&quot;</span>, <span class=\"keyword\">sizeof</span>(arr)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tarr[<span class=\"keyword\">sizeof</span>(arr)<span class=\"number\">-1</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, arr);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>The function char <code>*fgets(char *str, int n, FILE *stream)</code> reads <code>(n-1)</code> characters from the specific stream plus the final null character</p>\n<h1 id=\" Computer memory\" class=\"active\"><a class=\"anchor\"  href=\"# Computer memory\">#</a> Computer memory</h1>\n\n<h2 id=\" Intel x86 (32-bit)\" class=\"active\"><a class=\"anchor\"  href=\"# Intel x86 (32-bit)\">#</a> Intel x86 (32-bit)</h2>\n\n<ol>\n<li>von Neumann architecture</li>\n</ol>\n<ul>\n<li><p>Central processing unit (CPU) executes code </p>\n</li>\n<li><p>Main memory of the system (RAM) stores all data and code</p>\n</li>\n<li><p>Input&#x2F;output system (I&#x2F;O) interfaces with devices such as hard drives, keyboards, and monitors</p>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/24/671a56f0c953f.png\" alt=\"img\"></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>CPU</li>\n</ol>\n<p>The <strong>control unit</strong> gets instructions to execute from RAM using the instruction pointer, which stores the address of the instruction to execute<br><strong>Registers</strong> are the CPU’s basic data storage units and are often used to save time so that the CPU doesn’t need to access RAM. </p>\n<p>在 32 位 x86 架构中，主要的通用寄存器包括：</p>\n<ul>\n<li>EAX: 累加器寄存器，用于算术运算和返回值。</li>\n<li>EBX: 基址寄存器，常用于基址存取。</li>\n<li>ECX: 计数器寄存器，常用于循环和移位操作。</li>\n<li>EDX: 数据寄存器，用于 I&#x2F;O 操作和乘除法。</li>\n<li>ESI: 源索引寄存器，常用于指向内存数据源。</li>\n<li>EDI: 目标索引寄存器，常用于指向内存数据目标。</li>\n<li>EBP: 基址指针寄存器，用于栈帧基址指针。</li>\n<li>ESP: 栈指针寄存器，指向当前栈顶</li>\n</ul>\n<p>The <strong>Arithmetic Logic Unit (ALU)</strong> executes an instruction fetched from RAM and places the results in registers or memory</p>\n<p>CPU runs a program by fetching and executing each instruction</p>\n<h2 id=\"Programs in the main memory\" class=\"active\"><a class=\"anchor\"  href=\"#Programs in the main memory\"> #</a>  Programs in the main memory</h2>\n\n<p> Processes are programs loaded into memory, broken into small sections</p>\n<ul>\n<li><p>.text section</p>\n</li>\n<li><p>.data section</p>\n</li>\n<li><p>.bss section</p>\n</li>\n<li><p>Heap section</p>\n</li>\n<li><p>Stack section</p>\n</li>\n<li><p>Environment&#x2F;Arguments section</p>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/24/671a56f09cb3d.png\" alt=\"img\"></p>\n</li>\n</ul>\n<ol>\n<li>.text section</li>\n</ol>\n<p>Correspond to the .text portion of the binary executable file. </p>\n<p>Contain the machine instructions to get the task done</p>\n<ol start=\"2\">\n<li>.data section</li>\n</ol>\n<p>Store global initialised variables such as:</p>\n<ul>\n<li>int a &#x3D; 0;</li>\n</ul>\n<ol start=\"3\">\n<li>.bss section</li>\n</ol>\n<p>Store global uninitialised variables such as:</p>\n<ul>\n<li>int a;</li>\n</ul>\n<ol start=\"4\">\n<li>Heap section</li>\n</ol>\n<p>Store dynamically allocated variables</p>\n<ul>\n<li>Contain the pre-existing value of that memory</li>\n</ul>\n<p>Grows from the lower-addressed memory to the higher-addressed memory</p>\n<ul>\n<li>int *I &#x3D; malloc (sizeof (int));</li>\n</ul>\n<ol start=\"5\">\n<li>Stack section</li>\n</ol>\n<p>Keep track of function calls (recursively)</p>\n<p>Grow from the higher-addressed memory to the lower-addressed memory</p>\n<p>Local variables are in the stack section</p>\n<ol start=\"6\">\n<li>Environment&#x2F;Arguments section</li>\n</ol>\n<p>Store a copy of system-level variables that may be required by the process</p>\n<ul>\n<li>For example, path, shell name, hostname, etc.</li>\n</ul>\n<p>Command-line arguments are stored in this area.</p>\n<h2 id=\" Buffers\" class=\"active\"><a class=\"anchor\"  href=\"# Buffers\">#</a> Buffers</h2>\n\n<p> A storage place used to receive and hold data until it can be handled by a process<br> Each process can have its own set of buffers</p>\n<ul>\n<li>E.g. memory allocated within the .data or .bss section of the process’s memory<br> Buffer is of <strong>fixed length once allocated</strong>.</li>\n<li>Hold any predefined type of data</li>\n</ul>\n<h2 id=\" Pointers\" class=\"active\"><a class=\"anchor\"  href=\"# Pointers\">#</a> Pointers</h2>\n\n<p>Pointers hold the address of other pieces of memory</p>\n<ul>\n<li>Their size is fixed of 4 bytes for 32-bit memory address</li>\n</ul>\n<p>C string can be written as a pointer to character:</p>\n<ul>\n<li>char * str; </li>\n<li>int * point1;</li>\n</ul>\n<p>C#’s reference types implicitly use pointers<br>Use dereference to read the value inside the memory address pointed to by the pointer:</p>\n<ul>\n<li>printf(“%d”, *point1);</li>\n</ul>\n<p>The <code>*</code> symbol dereferences the pointer called point1 and displays the value of the integer using the <code>printf()</code> function</p>\n<ul>\n<li>The type of <code>point1</code> is a pointer</li>\n<li>The type of <code>*point1</code> is an integer <figure class=\"highlight c\"><figcaption><span>Putting the pieces of memory together</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ind = <span class=\"number\">5</span>;                     <span class=\"comment\">// integer stored in .data (initialized)</span></span><br><span class=\"line\"> <span class=\"type\">char</span> *str;                       <span class=\"comment\">// string pointer stored in .bss (uninitialized)</span></span><br><span class=\"line\"> <span class=\"type\">int</span> nothing;                     <span class=\"comment\">// integer stored in .bss (uninitialized)</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">(<span class=\"type\">int</span> c)</span> </span><br><span class=\"line\">&#123;                                              </span><br><span class=\"line\"> \t<span class=\"type\">int</span> i = c;                                  <span class=\"comment\">// stored in stack section</span></span><br><span class=\"line\"> \tstr = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">10</span> * <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>));    <span class=\"comment\">// reserves 10 characters in heap region </span></span><br><span class=\"line\"> \t<span class=\"built_in\">strncpy</span>(str, <span class=\"string\">&quot;abcde&quot;</span>, <span class=\"number\">5</span>);                   <span class=\"comment\">// copies &quot;abcde&quot; into str</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tfun(<span class=\"number\">1</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","categories":["课程笔记","Principles of Software Security"],"tags":["C language","Linux","software security"]}]