{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"vulnerability\" tag",
    "description": "🌸",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/course/Stack-buffer-overflow/",
            "url": "http://example.com/course/Stack-buffer-overflow/",
            "title": "Stack buffer overflow",
            "date_published": "2024-10-26T07:50:30.000Z",
            "content_html": "<h1 id=\"Stack buffer overflow\" class=\"active\"><a class=\"anchor\"  href=\"#Stack buffer overflow\">#</a>Stack buffer overflow</h1>\n\n<ol>\n<li>The Process Stack</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>Sample Process C Code</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">A</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c)</span>  </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">\t<span class=\"type\">char</span> buffer1[<span class=\"number\">5</span>]; </span><br><span class=\"line\">\t<span class=\"type\">char</span> buffer2[<span class=\"number\">10</span>]; </span><br><span class=\"line\">    \t... </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>  </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">\tA(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(...); </span><br><span class=\"line\">   \t ... </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img.picui.cn/free/2024/10/26/671ca1b71cfbb.png\" alt=\"img\"></p>\n<p>在调用函数时，函数参数是按照从右到左的顺序依次压入栈中。这种参数传递方式是 x86 架构的标准做法，用于保证函数参数在栈上的正确顺序。<br>在这个例子中，函数 <code>A(int a, int b, int c)</code> 被调用时，<code>c</code> 首先被压入栈，然后是 <code>b</code>，最后是 <code>a</code>。</p>\n<ol start=\"2\">\n<li>Buffer Overflow</li>\n</ol>\n<ul>\n<li>Occurs when:<br> Input is unconstrained<br> Runs past the end of a buffer, replacing valid (control) data </li>\n<li>Technique that allows:<br>  Your code to be executed by another program<br>  Overflow data area to alter variable values</li>\n<li>Problem: declaration in version of login.c is <code>char name[80], passwd[80], hash[13];</code>. Attack login procedure: <ol>\n<li>User types username, which is stored in name </li>\n<li>Compute hash for the corresponding password </li>\n<li>User types password, pads to 80 chars, and types hash for that password </li>\n<li>The program validates password against user-supplied hash; user is in (with any password)</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Stack Smashing<br>缓冲区溢出攻击的核心是覆盖栈上的 返回地址（ret）。当返回地址被覆盖时，程序在函数返回时不会跳回调用函数的位置，而是跳转到攻击者指定的位置。攻击者可以利用这种技术让程序执行任意代码（如恶意代码或 shellcode），这被称为堆栈破坏。 <figure class=\"highlight c\"><figcaption><span>Stack Smashing</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionA</span><span class=\"params\">(<span class=\"type\">char</span> *str)</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"type\">char</span> buffer[<span class=\"number\">16</span>]; </span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(buffer, str);   <span class=\"comment\">//segmentation fault</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"type\">char</span> large_string[<span class=\"number\">256</span>]; </span><br><span class=\"line\">\t<span class=\"type\">int</span> i; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">255</span>; i++) </span><br><span class=\"line\">       &#123; </span><br><span class=\"line\">\t\tlarge_string[i] = <span class=\"string\">&#x27;A&#x27;</span>; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">\tfunctionA(large_string); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><code>buffer</code>：在 <code>functionA</code> 中声明为 16 字节的字符数组。</li>\n<li><code>strcpy(buffer, str)</code>：使用 <code>strcpy</code> 将外部传入的字符串 str 复制到 buffer 中。由于 <code>strcpy</code> 不检查长度，如果 <code>str</code> 的长度超过 16 字节，会导致缓冲区溢出。</li>\n<li>在 <code>main</code> 中，<code>large_string</code> 是一个 256 字节的数组，它被填充为 255 个 ‘A’。当 <code>large_string</code> 被传递给 <code>functionA</code> 时，<code>buffer</code> 被溢出。</li>\n<li>修复： <code>strcpy(buffer, str)</code> –&gt; <code>strncpy(buffer, str, 16);</code></li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/26/671ca87ccb1e2.png\" alt=\"img\"><br> <code>large_str</code> has overflowed <code>buffer</code> and <code>sfp</code> and <code>ret</code> and <code>*str</code>.Note that <code>ret</code> is the return address!<br>This means we can get the function to return to any point in the code that we specify.</p>\n<ul>\n<li>Buffer overflows allow us to change return address <ol>\n<li>Can point to any function in the library </li>\n<li>Can point to own code</li>\n</ol>\n</li>\n<li>Add code in the overflowed buffer <ol>\n<li>Run at privilege of process (very useful if root!) </li>\n<li>Even a small buffer can invoke a shell using the system call (often called shellcode)</li>\n</ol>\n</li>\n<li>Attacker would like to run shell at root level<ol>\n<li>Make system call to <code>execve</code>, passing <code>/bin/sh</code> </li>\n<li>Needs to be part of the buffer, and in assembly code (以便精确控制其大小和功能)</li>\n<li>Program has to fit in buffer without overwriting return address(如果 shellcode 覆盖了返回地址本身，可能导致程序崩溃而无法执行攻击代码) </li>\n<li>Pad out buffer to return address, and point return address to start of buffer </li>\n<li>Don’t generate core dump (this will cause suspicion)</li>\n</ol>\n</li>\n</ul>\n<ol start=\"4\">\n<li>What do You Need to Hack a Buffer Overflow<ol>\n<li>Address where buffer begins</li>\n</ol>\n<ul>\n<li>Easy to get if you have access to the same type of system being attacked </li>\n<li>Can use Null Operation (NOP) commands to make the target address bigger</li>\n</ul>\n<ol start=\"2\">\n<li>Location where return address is stored</li>\n</ol>\n<ul>\n<li>Can pad out the buffer with return address</li>\n</ul>\n<ol start=\"3\">\n<li>Assembly language program to spawn a shell (shellcode payload)</li>\n</ol>\n<ul>\n<li>Can use gdb to disassemble a program for you</li>\n</ul>\n</li>\n<li>Affected Languages</li>\n</ol>\n<p>Buffer overflows mainly occur in low-level programming languages that allow direct memory access: Assembler, C, C++<br>Note that some high-level languages such as Java, C# and Visual Basic are written in C, C++ or call modules written in these languages</p>\n<ol start=\"6\">\n<li><p>Buffer Overflow Examples<br> Functions that handle arrays but do not check length (checking for termination character is insufficient) In C&#x2F;C++,  <code>gets</code>, <code>strcpy</code>, <code>strcat</code>, <code>sprintf</code></p>\n<ol>\n<li>Example 1</li>\n</ol>\n</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[<span class=\"number\">20</span>]; </span><br><span class=\"line\"> gets(buf);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>char buf[20]</code>：定义了一个长度为 20 的字符数组 <code>buf</code>。</p>\n</li>\n<li><p><code>gets(buf)</code>：使用 <code>gets()</code> 函数从标准输入读取字符串，并存储在 <code>buf</code> 中</p>\n</li>\n<li><p><code>gets()</code> 函数不检查输入的长度，意味着如果输入的字符串长度超过了 <code>buf</code> 的大小（20 字节），则会发生缓冲区溢出。</p>\n</li>\n<li><p>修复： <code>fgets(buf, sizeof(buf), stdin);</code></p>\n<ol start=\"2\">\n<li>Example 2</li>\n</ol>\n</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[<span class=\"number\">20</span>]; </span><br><span class=\"line\"> <span class=\"type\">char</span> prefix[] = <span class=\"string\">&quot;http://&quot;</span>; </span><br><span class=\"line\">   ... </span><br><span class=\"line\">   <span class=\"comment\">// copies the string prefix to buf </span></span><br><span class=\"line\"> <span class=\"built_in\">strcpy</span>(buf, prefix); </span><br><span class=\"line\">   <span class=\"comment\">// concatenates path to the string buf </span></span><br><span class=\"line\"> <span class=\"built_in\">strncat</span>(buf, path, <span class=\"keyword\">sizeof</span>(buf));</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>char buf[20]</code>：定义了一个长度为 20 字节的字符数组 <code>buf</code>。</p>\n</li>\n<li><p><code>char prefix[] = &quot;http://&quot;;</code>：定义了一个包含字符串 <code>&quot;http://&quot;</code> 的字符数组。</p>\n</li>\n<li><p><code>strcpy(buf, prefix)</code>：将字符串 <code>&quot;http://&quot;</code> 复制到 <code>buf</code> 中。</p>\n<ul>\n<li>问题：<code>&quot;http://&quot;</code> 长度为 7 字节（包括终止符 \\0），在复制后，<code>buf</code> 中只剩下 13 个字节可用。</li>\n</ul>\n</li>\n<li><p><code>strncat(buf, path, sizeof(buf))</code>：将字符串 <code>path</code> 连接到 <code>buf</code> 中，指定的最大长度为 <code>sizeof(buf)</code>（即 20 字节）。</p>\n<ul>\n<li>问题：这里的 <code>sizeof(buf)</code> 是 20 字节，但在前面已经用掉了 7 字节（包括终止符）。<code>strncat()</code> 试图追加 <code>path</code> 的内容时，可能会超出 <code>buf</code> 的剩余空间（13 字节），导致缓冲区溢出。</li>\n</ul>\n</li>\n<li><p>修复：<code>strncat(buf, path, sizeof(buf) - strlen(buf) - 1);</code></p>\n<ol start=\"3\">\n<li>Example 3</li>\n</ol>\n</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[<span class=\"number\">32</span>]; </span><br><span class=\"line\"> <span class=\"built_in\">strncpy</span>(buf, data, <span class=\"built_in\">strlen</span>(data)); </span><br></pre></td></tr></table></figure>\n<p><code>strncpy(buf, data, strlen(data))</code>：将字符串 <code>data</code> 复制到 <code>buf</code> 中，复制的长度为 <code>strlen(data)</code>。</p>\n<ul>\n<li><p>缺陷 1：缺少终止符 \\0：<code>strncpy</code> 不会自动添加字符串的终止符 <code>\\0</code>，如果 <code>data</code>的长度等于或大于 32，那么 <code>buf</code> 不会以 <code>\\0</code> 结尾。这可能导致 <code>buf</code> 被当作未终止的字符串处理，带来不确定的行为或安全风险。</p>\n</li>\n<li><p>缺陷 2：可能的缓冲区溢出：如果 <code>strlen(data) &gt; 32</code>，<code>strncpy</code> 将尝试复制超过 <code>buf</code> 大小的内容，导致缓冲区溢出。</p>\n</li>\n<li><p>修复：<code>strncpy(buf, data, sizeof(buf) - 1); buf[sizeof(buf) - 1] = &#39;\\0&#39;;</code></p>\n<ol start=\"4\">\n<li>Example 4</li>\n</ol>\n</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[MAX_PATH]; </span><br><span class=\"line\"> <span class=\"built_in\">sprintf</span>(buf, <span class=\"string\">&quot;%s - %d\\n&quot;</span>, path, errno);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>sprintf(buf, &quot;%s - %d\\n&quot;, path, errno)</code> 会将 <code>path</code> 和 <code>errno</code> 的格式化字符串复制到 <code>buf</code> 中。</li>\n<li><code>sprintf</code> 不检查 <code>buf</code> 的大小是否足以容纳格式化后的结果。如果 <code>path</code> 很长，加上数字 <code>errno</code> 和其他字符，可能会超过 <code>MAX_PATH</code>，导致缓冲区溢出。</li>\n<li>修复： <code>snprintf(buf, sizeof(buf), &quot;%s - %d\\n&quot;, path, errno);</code></li>\n</ul>\n<h1 id=\"Stack buffer overflow prevention\" class=\"active\"><a class=\"anchor\"  href=\"#Stack buffer overflow prevention\">#</a>Stack buffer overflow prevention</h1>\n\n<ol>\n<li>Spotting Buffer Overflows</li>\n</ol>\n<ul>\n<li>Check inputs, whether read from the network, a file, or from the command line </li>\n<li>Check transfer of data from said input to internal structures </li>\n<li>Look for use of unsafe string handling calls </li>\n<li>Look for use of arithmetic to calculate an allocation size or remaining buffer size</li>\n</ul>\n<ol start=\"2\">\n<li>Fixing Buffer Overflows</li>\n</ol>\n<ul>\n<li>Replace dangerous string handling functions </li>\n<li>Replace C string buffers with C++ strings </li>\n<li>Replace static arrays with STL containers </li>\n<li>Use analysis tools, Examples include Fortify, Coverity, PREfast, and Klocwor</li>\n</ul>\n<ol start=\"3\">\n<li>Code Analysis</li>\n</ol>\n<ul>\n<li>Statically check source to detect buffer overflows s </li>\n<li>Several tools exist to automate the review process<br>Stanford:  Engler, et al.  Test trust inconsistency<br>@stake.com  (l0pht.com): SLINT (designed for UNIX)<br>Berkeley:  Wagner, et al.  Test constraint violations </li>\n<li>Find lots of bugs, but not all</li>\n</ul>\n<ol start=\"4\">\n<li>Marking Stack as Non-Execute<br>Basic stack exploit can be prevented by marking stack segment as non-executable<br>Limitations and Problems</li>\n</ol>\n<ul>\n<li>Some apps need executable stack (e.g. LISP interpreters) </li>\n<li>Does not block more general overflow exploits </li>\n<li>Overflow on heap: overflow buffer next to func pointer </li>\n<li>Cannot make all the data segment non-executable </li>\n<li>More recent UNIX and MS windows emit dynamic code into program data for performance optimisations</li>\n</ul>\n<ol start=\"5\">\n<li>Stack Protection and Run-time Checking<br>Many run-time checking techniques <ol>\n<li>Example:  StackGuard (WireX)</li>\n</ol>\n<ul>\n<li>Run time tests for stack integrity </li>\n<li>Code generator for emitting code to set up and tear down functions </li>\n<li>Embeds “canaries” in stack frames and verify their integrity prior to function return</li>\n</ul>\n<ol start=\"2\">\n<li>Libsafe (Avaya Labs)</li>\n</ol>\n<ul>\n<li>Dynamically loaded library </li>\n<li>Intercepts calls to <code>strcpy (dest, src)</code> <ul>\n<li>Validate sufficient space in current stack frame: |framepointer–dest| &gt; strlen(src)  </li>\n<li>If so, does strcpy. Otherwise, terminates application</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Address obfuscation (Stony Brook’03)</li>\n</ol>\n<ul>\n<li>Encrypt return address on stack by XORing with random string. Decrypt just before returning from function </li>\n<li>Attacker needs decryption key to set return address to desired value</li>\n</ul>\n<ol start=\"7\">\n<li>PaX ASLR: Randomise location of libc</li>\n</ol>\n<ul>\n<li>Attacker cannot jump directly to exec function</li>\n</ul>\n",
            "tags": [
                "C",
                "software security",
                "vulnerability"
            ]
        }
    ]
}