<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title> • Posts by &#34;vulnerability&#34; tag</title>
    <link href="http://example.com" />
    <updated>2024-10-26T11:52:22.000Z</updated>
    <category term="C" />
    <category term="software security" />
    <category term="AFL" />
    <category term="Linux" />
    <category term="C language" />
    <category term="vulnerability" />
    <category term="gdb" />
    <category term="JavaScript" />
    <category term="Blog" />
    <category term="日常" />
    <entry>
        <id>http://example.com/course/Format-string-bugs/</id>
        <title>Format string bugs</title>
        <link rel="alternate" href="http://example.com/course/Format-string-bugs/"/>
        <content type="html">&lt;h1 id=&#34;Format Functions&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Format Functions&#34;&gt;#&lt;/a&gt;Format Functions&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Format Functions&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; Output a formatted string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fprintf&lt;/code&gt; Writes the printf to a file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sprintf&lt;/code&gt; Prints into a string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snprintf&lt;/code&gt; Prints into a string checking the length&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vprintf&lt;/code&gt; Prints the argument list to stdout&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vfprintf&lt;/code&gt; Prints the argument list to a file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vsprintf&lt;/code&gt; Prints the argument list to a string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vsnprintf&lt;/code&gt; Prints the argument to a string checking the length&lt;br&gt;总结：&lt;code&gt;printf&lt;/code&gt; 和 &lt;code&gt;fprintf&lt;/code&gt; 用于输出格式化字符串到标准输出或文件。&lt;br&gt;&lt;code&gt;sprintf&lt;/code&gt; 和 &lt;code&gt;snprintf&lt;/code&gt; 用于将格式化字符串写入字符串缓冲区，&lt;code&gt;snprintf&lt;/code&gt; 更安全。&lt;br&gt;&lt;code&gt;vprintf&lt;/code&gt;、&lt;code&gt;vfprintf&lt;/code&gt;、&lt;code&gt;vsprintf&lt;/code&gt; 和 &lt;code&gt;vsnprintf&lt;/code&gt; 用于处理可变参数列表，与前面的函数类似，但专门用于 &lt;code&gt;va_list&lt;/code&gt; 参数的处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Format Strings&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Format String is the argument of format functions that contains format parameters. Format parameters are placeholders to be replaced with user inputs &lt;/li&gt;
&lt;li&gt;For example, the statement will output different sentences, depending on what is contained in the variable name: &lt;code&gt;printf(&amp;quot;Hello, %s.&amp;quot;, &amp;amp;name);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If the variable name contains the string “Zz”, then &lt;code&gt;printf()&lt;/code&gt; will output: Hello, Zz.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Common Parameters Used in Format String Attacks&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;传递方式&lt;/th&gt;
&lt;th&gt;在攻击中的作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;%s&lt;/td&gt;
&lt;td&gt;打印字符串&lt;/td&gt;
&lt;td&gt;引用（指向字符串的指针）&lt;/td&gt;
&lt;td&gt;攻击者可以利用 %s 打印出内存中的任意数据，通过提供特定的内存地址，读取敏感数据（如密码、密钥等）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%d&lt;/td&gt;
&lt;td&gt;打印有符号十进制整数&lt;/td&gt;
&lt;td&gt;整数值&lt;/td&gt;
&lt;td&gt;虽然 %d 通常用于整数显示，但攻击者可以通过它来泄露内存中的整数值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%u&lt;/td&gt;
&lt;td&gt;打印无符号十进制整数&lt;/td&gt;
&lt;td&gt;无符号整数值&lt;/td&gt;
&lt;td&gt;与 %d 类似，但用于无符号整数的显示。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%x&lt;/td&gt;
&lt;td&gt;打印十六进制整数（小写）&lt;/td&gt;
&lt;td&gt;无符号整数值&lt;/td&gt;
&lt;td&gt;攻击者可以通过 %x 逐步读取内存，以十六进制显示地址中的数据内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%c&lt;/td&gt;
&lt;td&gt;打印单个字符&lt;/td&gt;
&lt;td&gt;字符值&lt;/td&gt;
&lt;td&gt;用于显示单个字符，但在攻击中用途有限。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%n&lt;/td&gt;
&lt;td&gt;将已打印的字符数写入指定变量&lt;/td&gt;
&lt;td&gt;引用（指向整数的指针）&lt;/td&gt;
&lt;td&gt;攻击者可以利用 %n 修改任意内存地址的值，这是格式字符串攻击中最危险的参数之一，可能被用来修改程序的控制流。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%%&lt;/td&gt;
&lt;td&gt;打印 % 字符&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;用于输出 % 字符，无特别的攻击价值。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;How Do Format Functions Work?&lt;br&gt; According to the data format dictated by the format parameters, format functions retrieve the arguments from the stack&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;printf(“A is the number %d, B is the string %s”, A, &amp;amp;B);&lt;br&gt;The &lt;code&gt;printf()&lt;/code&gt; function will attempt to retrieve the value of A and the address of string B from the stack&lt;br&gt;在格式化字符串中，每个格式参数（如 &lt;code&gt;%d&lt;/code&gt;、&lt;code&gt;%s&lt;/code&gt;）都告诉 &lt;code&gt;printf()&lt;/code&gt; 如何解释栈中的数据：&lt;code&gt;%d&lt;/code&gt; 表示检索一个 整数值。&lt;code&gt;%s&lt;/code&gt; 表示检索一个 字符串指针（地址），然后根据地址打印对应的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Exploit&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Exploit&#34;&gt;#&lt;/a&gt;Exploit&lt;/h1&gt;
The vulnerability occurs when there is a mismatch between the number of format parameters and the number of function arguments provided to fill those places 
- For example, if an attacker is able to supply more placeholders than there are arguments, he/she can use format functions to read or write the stack! 
Format functions can be exploited when an attacker is given direct control over the format string fed into the function

&lt;ol&gt;
&lt;li&gt;Reading Data from Stack&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;printf(“A is the number &lt;code&gt;%d&lt;/code&gt;, reading stack data: &lt;code&gt;%x&lt;/code&gt;“, A); &lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf()&lt;/code&gt; will attempt to retrieve two values from the stack &lt;/li&gt;
&lt;li&gt;But only one of those is placed on the stack &lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf()&lt;/code&gt; will retrieve the next value on the stack and display it in hex format!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To print the next 20 items on the stack: &lt;ul&gt;
&lt;li&gt;printf(“%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x”);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To print the tenth element next on the stack: &lt;ul&gt;
&lt;li&gt;printf(“%10$x”);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Reading Data at Arbitrary Location &lt;code&gt;%s&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Format functions treat the data on the stack as an address to go fetch a string &lt;ul&gt;
&lt;li&gt;Note that &lt;code&gt;%s&lt;/code&gt; is passed as reference!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;How to control the address accessed by &lt;code&gt;%s&lt;/code&gt;? &lt;ul&gt;
&lt;li&gt;Place an address on the format string (the string is stored on stack) &lt;/li&gt;
&lt;li&gt;Get &lt;code&gt;%s&lt;/code&gt; to dereference it!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To print the string located at address 0x12345678: &lt;ul&gt;
&lt;li&gt;printf(“\x78\x56\x34\x12%x%x%x%s”, A, B, C);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Writing Data at Arbitrary Location &lt;code&gt;%n&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%n&lt;/code&gt; stores the number of characters written so far into the corresponding function argument! For example, the following code put the integer 5 into the variable &lt;code&gt;num_char&lt;/code&gt;   &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; num_char; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;11111%n&amp;quot;&lt;/span&gt;, &amp;amp;num_char); &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
With width-controlling format parameters, the attacker can write arbitrary integers to the location pointed to by the function argument &lt;/li&gt;
&lt;li&gt;Write 10 to num_char using width-controlling format parameter  &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; num_char; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%10d%n&amp;quot;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &amp;amp;num_char);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;Control the amount of data written with length parameter &lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf(&amp;quot;%10d%hn&amp;quot;, 0, &amp;amp;num_char);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Writes 2 bytes (instead of 4 bytes) to &lt;code&gt;&amp;amp;num_char&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Combined with the trick to access arbitrary memory locations, the attacker can write to arbitrary memory locations&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Example &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;512&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     fgets(buf, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(buf), &lt;span class=&#34;built_in&#34;&gt;stdin&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 安全读取输入，不会导致缓冲区溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;The input is:&amp;quot;&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(buf);  &lt;span class=&#34;comment&#34;&gt;// 存在格式化字符串漏洞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf(buf);&lt;/code&gt; 直接使用了用户输入的内容作为格式化字符串。如果 &lt;code&gt;buf&lt;/code&gt; 中包含格式化占位符（如 &lt;code&gt;%s&lt;/code&gt;、&lt;code&gt;%x&lt;/code&gt;、&lt;code&gt;%n&lt;/code&gt; 等），&lt;code&gt;printf()&lt;/code&gt; 会将其解释为格式化指令，从而造成安全隐患。&lt;/li&gt;
&lt;li&gt;修复： &lt;code&gt;printf(&amp;quot;The input is: %s&amp;quot;, buf);&lt;/code&gt;：%s 确保输入内容被当作普通字符串处理，而不是格式化字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Denial of Service Attacks&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Denial of Service Attacks&#34;&gt;#&lt;/a&gt;Denial of Service Attacks&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Crash the program by attempting to access an invalid address &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;%s&lt;/code&gt; to retrieve a value from the stack till encountering an invalid memory location&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The exploit string would look something like this &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;·printf(“%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s”);·&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The more %s used in the format string, the higher the chance of an invalid address&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Format String Attacks Prevention&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Format String Attacks Prevention&#34;&gt;#&lt;/a&gt;Format String Attacks Prevention&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Hard-coded format strings (e.g. no &lt;code&gt;printf(arg)&lt;/code&gt;)  &lt;/li&gt;
&lt;li&gt;Do not use the fancy &lt;code&gt;%n&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;Be careful with pass as references&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;%s&lt;/code&gt; and &lt;code&gt;sprintf&lt;/code&gt; can be used to create disclosure attacks&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Compiler support to match &lt;code&gt;printf&lt;/code&gt; arguments with format string&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;e.g. the &lt;code&gt;gcc&lt;/code&gt; compiler provides options to check format strings&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="C" />
        <category term="software security" />
        <category term="vulnerability" />
        <updated>2024-10-26T11:52:22.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/course/Stack-buffer-overflow/</id>
        <title>Stack buffer overflow</title>
        <link rel="alternate" href="http://example.com/course/Stack-buffer-overflow/"/>
        <content type="html">&lt;h1 id=&#34;Stack buffer overflow&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Stack buffer overflow&#34;&gt;#&lt;/a&gt;Stack buffer overflow&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;The Process Stack&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Sample Process C Code&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; b, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; c)&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer1[&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer2[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    	... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	A(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(...); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   	 ... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/26/671ca1b71cfbb.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在调用函数时，函数参数是按照从右到左的顺序依次压入栈中。这种参数传递方式是 x86 架构的标准做法，用于保证函数参数在栈上的正确顺序。&lt;br&gt;在这个例子中，函数 &lt;code&gt;A(int a, int b, int c)&lt;/code&gt; 被调用时，&lt;code&gt;c&lt;/code&gt; 首先被压入栈，然后是 &lt;code&gt;b&lt;/code&gt;，最后是 &lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Buffer Overflow&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Occurs when:&lt;br&gt; Input is unconstrained&lt;br&gt; Runs past the end of a buffer, replacing valid (control) data &lt;/li&gt;
&lt;li&gt;Technique that allows:&lt;br&gt;  Your code to be executed by another program&lt;br&gt;  Overflow data area to alter variable values&lt;/li&gt;
&lt;li&gt;Problem: declaration in version of login.c is &lt;code&gt;char name[80], passwd[80], hash[13];&lt;/code&gt;. Attack login procedure: &lt;ol&gt;
&lt;li&gt;User types username, which is stored in name &lt;/li&gt;
&lt;li&gt;Compute hash for the corresponding password &lt;/li&gt;
&lt;li&gt;User types password, pads to 80 chars, and types hash for that password &lt;/li&gt;
&lt;li&gt;The program validates password against user-supplied hash; user is in (with any password)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Stack Smashing&lt;br&gt;缓冲区溢出攻击的核心是覆盖栈上的 返回地址（ret）。当返回地址被覆盖时，程序在函数返回时不会跳回调用函数的位置，而是跳转到攻击者指定的位置。攻击者可以利用这种技术让程序执行任意代码（如恶意代码或 shellcode），这被称为堆栈破坏。 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Stack Smashing&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionA&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *str)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer[&lt;span class=&#34;number&#34;&gt;16&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buffer, str);   &lt;span class=&#34;comment&#34;&gt;//segmentation fault&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; large_string[&lt;span class=&#34;number&#34;&gt;256&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;255&lt;/span&gt;; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		large_string[i] = &lt;span class=&#34;string&#34;&gt;&amp;#x27;A&amp;#x27;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	functionA(large_string); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buffer&lt;/code&gt;：在 &lt;code&gt;functionA&lt;/code&gt; 中声明为 16 字节的字符数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcpy(buffer, str)&lt;/code&gt;：使用 &lt;code&gt;strcpy&lt;/code&gt; 将外部传入的字符串 str 复制到 buffer 中。由于 &lt;code&gt;strcpy&lt;/code&gt; 不检查长度，如果 &lt;code&gt;str&lt;/code&gt; 的长度超过 16 字节，会导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;main&lt;/code&gt; 中，&lt;code&gt;large_string&lt;/code&gt; 是一个 256 字节的数组，它被填充为 255 个 ‘A’。当 &lt;code&gt;large_string&lt;/code&gt; 被传递给 &lt;code&gt;functionA&lt;/code&gt; 时，&lt;code&gt;buffer&lt;/code&gt; 被溢出。&lt;/li&gt;
&lt;li&gt;修复： &lt;code&gt;strcpy(buffer, str)&lt;/code&gt; –&amp;gt; &lt;code&gt;strncpy(buffer, str, 16);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/26/671ca87ccb1e2.png&#34; alt=&#34;img&#34;&gt;&lt;br&gt; &lt;code&gt;large_str&lt;/code&gt; has overflowed &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sfp&lt;/code&gt; and &lt;code&gt;ret&lt;/code&gt; and &lt;code&gt;*str&lt;/code&gt;.Note that &lt;code&gt;ret&lt;/code&gt; is the return address!&lt;br&gt;This means we can get the function to return to any point in the code that we specify.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer overflows allow us to change return address &lt;ol&gt;
&lt;li&gt;Can point to any function in the library &lt;/li&gt;
&lt;li&gt;Can point to own code&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Add code in the overflowed buffer &lt;ol&gt;
&lt;li&gt;Run at privilege of process (very useful if root!) &lt;/li&gt;
&lt;li&gt;Even a small buffer can invoke a shell using the system call (often called shellcode)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Attacker would like to run shell at root level&lt;ol&gt;
&lt;li&gt;Make system call to &lt;code&gt;execve&lt;/code&gt;, passing &lt;code&gt;/bin/sh&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;Needs to be part of the buffer, and in assembly code (以便精确控制其大小和功能)&lt;/li&gt;
&lt;li&gt;Program has to fit in buffer without overwriting return address(如果 shellcode 覆盖了返回地址本身，可能导致程序崩溃而无法执行攻击代码) &lt;/li&gt;
&lt;li&gt;Pad out buffer to return address, and point return address to start of buffer &lt;/li&gt;
&lt;li&gt;Don’t generate core dump (this will cause suspicion)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;What do You Need to Hack a Buffer Overflow&lt;ol&gt;
&lt;li&gt;Address where buffer begins&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Easy to get if you have access to the same type of system being attacked &lt;/li&gt;
&lt;li&gt;Can use Null Operation (NOP) commands to make the target address bigger&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Location where return address is stored&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Can pad out the buffer with return address&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Assembly language program to spawn a shell (shellcode payload)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Can use gdb to disassemble a program for you&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Affected Languages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Buffer overflows mainly occur in low-level programming languages that allow direct memory access: Assembler, C, C++&lt;br&gt;Note that some high-level languages such as Java, C# and Visual Basic are written in C, C++ or call modules written in these languages&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;p&gt;Buffer Overflow Examples&lt;br&gt; Functions that handle arrays but do not check length (checking for termination character is insufficient) In C&amp;#x2F;C++,  &lt;code&gt;gets&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Example 1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; gets(buf);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;char buf[20]&lt;/code&gt;：定义了一个长度为 20 的字符数组 &lt;code&gt;buf&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;gets(buf)&lt;/code&gt;：使用 &lt;code&gt;gets()&lt;/code&gt; 函数从标准输入读取字符串，并存储在 &lt;code&gt;buf&lt;/code&gt; 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;gets()&lt;/code&gt; 函数不检查输入的长度，意味着如果输入的字符串长度超过了 &lt;code&gt;buf&lt;/code&gt; 的大小（20 字节），则会发生缓冲区溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修复： &lt;code&gt;fgets(buf, sizeof(buf), stdin);&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Example 2&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; prefix[] = &lt;span class=&#34;string&#34;&gt;&amp;quot;http://&amp;quot;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   ... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &lt;span class=&#34;comment&#34;&gt;// copies the string prefix to buf &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buf, prefix); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &lt;span class=&#34;comment&#34;&gt;// concatenates path to the string buf &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strncat&lt;/span&gt;(buf, path, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(buf));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;char buf[20]&lt;/code&gt;：定义了一个长度为 20 字节的字符数组 &lt;code&gt;buf&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;char prefix[] = &amp;quot;http://&amp;quot;;&lt;/code&gt;：定义了一个包含字符串 &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt; 的字符数组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;strcpy(buf, prefix)&lt;/code&gt;：将字符串 &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt; 复制到 &lt;code&gt;buf&lt;/code&gt; 中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题：&lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt; 长度为 7 字节（包括终止符 \0），在复制后，&lt;code&gt;buf&lt;/code&gt; 中只剩下 13 个字节可用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;strncat(buf, path, sizeof(buf))&lt;/code&gt;：将字符串 &lt;code&gt;path&lt;/code&gt; 连接到 &lt;code&gt;buf&lt;/code&gt; 中，指定的最大长度为 &lt;code&gt;sizeof(buf)&lt;/code&gt;（即 20 字节）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题：这里的 &lt;code&gt;sizeof(buf)&lt;/code&gt; 是 20 字节，但在前面已经用掉了 7 字节（包括终止符）。&lt;code&gt;strncat()&lt;/code&gt; 试图追加 &lt;code&gt;path&lt;/code&gt; 的内容时，可能会超出 &lt;code&gt;buf&lt;/code&gt; 的剩余空间（13 字节），导致缓冲区溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修复：&lt;code&gt;strncat(buf, path, sizeof(buf) - strlen(buf) - 1);&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Example 3&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;32&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(buf, data, &lt;span class=&#34;built_in&#34;&gt;strlen&lt;/span&gt;(data)); &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;strncpy(buf, data, strlen(data))&lt;/code&gt;：将字符串 &lt;code&gt;data&lt;/code&gt; 复制到 &lt;code&gt;buf&lt;/code&gt; 中，复制的长度为 &lt;code&gt;strlen(data)&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;缺陷 1：缺少终止符 \0：&lt;code&gt;strncpy&lt;/code&gt; 不会自动添加字符串的终止符 &lt;code&gt;\0&lt;/code&gt;，如果 &lt;code&gt;data&lt;/code&gt;的长度等于或大于 32，那么 &lt;code&gt;buf&lt;/code&gt; 不会以 &lt;code&gt;\0&lt;/code&gt; 结尾。这可能导致 &lt;code&gt;buf&lt;/code&gt; 被当作未终止的字符串处理，带来不确定的行为或安全风险。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缺陷 2：可能的缓冲区溢出：如果 &lt;code&gt;strlen(data) &amp;gt; 32&lt;/code&gt;，&lt;code&gt;strncpy&lt;/code&gt; 将尝试复制超过 &lt;code&gt;buf&lt;/code&gt; 大小的内容，导致缓冲区溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修复：&lt;code&gt;strncpy(buf, data, sizeof(buf) - 1); buf[sizeof(buf) - 1] = &amp;#39;\0&amp;#39;;&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Example 4&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[MAX_PATH]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;sprintf&lt;/span&gt;(buf, &lt;span class=&#34;string&#34;&gt;&amp;quot;%s - %d\n&amp;quot;&lt;/span&gt;, path, errno);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sprintf(buf, &amp;quot;%s - %d\n&amp;quot;, path, errno)&lt;/code&gt; 会将 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;errno&lt;/code&gt; 的格式化字符串复制到 &lt;code&gt;buf&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sprintf&lt;/code&gt; 不检查 &lt;code&gt;buf&lt;/code&gt; 的大小是否足以容纳格式化后的结果。如果 &lt;code&gt;path&lt;/code&gt; 很长，加上数字 &lt;code&gt;errno&lt;/code&gt; 和其他字符，可能会超过 &lt;code&gt;MAX_PATH&lt;/code&gt;，导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;修复： &lt;code&gt;snprintf(buf, sizeof(buf), &amp;quot;%s - %d\n&amp;quot;, path, errno);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Stack buffer overflow prevention&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Stack buffer overflow prevention&#34;&gt;#&lt;/a&gt;Stack buffer overflow prevention&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Spotting Buffer Overflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Check inputs, whether read from the network, a file, or from the command line &lt;/li&gt;
&lt;li&gt;Check transfer of data from said input to internal structures &lt;/li&gt;
&lt;li&gt;Look for use of unsafe string handling calls &lt;/li&gt;
&lt;li&gt;Look for use of arithmetic to calculate an allocation size or remaining buffer size&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Fixing Buffer Overflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Replace dangerous string handling functions &lt;/li&gt;
&lt;li&gt;Replace C string buffers with C++ strings &lt;/li&gt;
&lt;li&gt;Replace static arrays with STL containers &lt;/li&gt;
&lt;li&gt;Use analysis tools, Examples include Fortify, Coverity, PREfast, and Klocwor&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Code Analysis&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Statically check source to detect buffer overflows s &lt;/li&gt;
&lt;li&gt;Several tools exist to automate the review process&lt;br&gt;Stanford:  Engler, et al.  Test trust inconsistency&lt;br&gt;@stake.com  (l0pht.com): SLINT (designed for UNIX)&lt;br&gt;Berkeley:  Wagner, et al.  Test constraint violations &lt;/li&gt;
&lt;li&gt;Find lots of bugs, but not all&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Marking Stack as Non-Execute&lt;br&gt;Basic stack exploit can be prevented by marking stack segment as non-executable&lt;br&gt;Limitations and Problems&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Some apps need executable stack (e.g. LISP interpreters) &lt;/li&gt;
&lt;li&gt;Does not block more general overflow exploits &lt;/li&gt;
&lt;li&gt;Overflow on heap: overflow buffer next to func pointer &lt;/li&gt;
&lt;li&gt;Cannot make all the data segment non-executable &lt;/li&gt;
&lt;li&gt;More recent UNIX and MS windows emit dynamic code into program data for performance optimisations&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Stack Protection and Run-time Checking&lt;br&gt;Many run-time checking techniques &lt;ol&gt;
&lt;li&gt;Example:  StackGuard (WireX)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Run time tests for stack integrity &lt;/li&gt;
&lt;li&gt;Code generator for emitting code to set up and tear down functions &lt;/li&gt;
&lt;li&gt;Embeds “canaries” in stack frames and verify their integrity prior to function return&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Libsafe (Avaya Labs)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Dynamically loaded library &lt;/li&gt;
&lt;li&gt;Intercepts calls to &lt;code&gt;strcpy (dest, src)&lt;/code&gt; &lt;ul&gt;
&lt;li&gt;Validate sufficient space in current stack frame: |framepointer–dest| &amp;gt; strlen(src)  &lt;/li&gt;
&lt;li&gt;If so, does strcpy. Otherwise, terminates application&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Address obfuscation (Stony Brook’03)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Encrypt return address on stack by XORing with random string. Decrypt just before returning from function &lt;/li&gt;
&lt;li&gt;Attacker needs decryption key to set return address to desired value&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;PaX ASLR: Randomise location of libc&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Attacker cannot jump directly to exec function&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="C" />
        <category term="software security" />
        <category term="vulnerability" />
        <updated>2024-10-26T07:50:30.000Z</updated>
    </entry>
</feed>
