<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title> • Posts by &#34;vulnerability&#34; tag</title>
    <link href="http://example.com" />
    <updated>2024-10-26T07:50:30.000Z</updated>
    <category term="C language" />
    <category term="Linux" />
    <category term="software security" />
    <category term="C" />
    <category term="vulnerability" />
    <category term="gdb" />
    <category term="Blog" />
    <category term="日常" />
    <category term="JavaScript" />
    <entry>
        <id>http://example.com/course/Stack-buffer-overflow/</id>
        <title>Stack buffer overflow</title>
        <link rel="alternate" href="http://example.com/course/Stack-buffer-overflow/"/>
        <content type="html">&lt;h1 id=&#34;Stack buffer overflow&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Stack buffer overflow&#34;&gt;#&lt;/a&gt;Stack buffer overflow&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;The Process Stack&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Sample Process C Code&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; b, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; c)&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer1[&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer2[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    	... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	A(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(...); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   	 ... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/26/671ca1b71cfbb.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在调用函数时，函数参数是按照从右到左的顺序依次压入栈中。这种参数传递方式是 x86 架构的标准做法，用于保证函数参数在栈上的正确顺序。&lt;br&gt;
在这个例子中，函数  &lt;code&gt;A(int a, int b, int c)&lt;/code&gt;  被调用时， &lt;code&gt;c&lt;/code&gt;  首先被压入栈，然后是  &lt;code&gt;b&lt;/code&gt; ，最后是  &lt;code&gt;a&lt;/code&gt; 。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Buffer Overflow&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Occurs when:&lt;br&gt;
Input is unconstrained&lt;br&gt;
Runs past the end of a buffer, replacing valid (control) data&lt;/li&gt;
&lt;li&gt;Technique that allows:&lt;br&gt;
Your code to be executed by another program&lt;br&gt;
Overflow data area to alter variable values&lt;/li&gt;
&lt;li&gt;Problem: declaration in version of login.c is  &lt;code&gt;char name[80], passwd[80], hash[13];&lt;/code&gt; . Attack login procedure:
&lt;ol&gt;
&lt;li&gt;User types username, which is stored in name&lt;/li&gt;
&lt;li&gt;Compute hash for the corresponding password&lt;/li&gt;
&lt;li&gt;User types password, pads to 80 chars, and types hash for that password&lt;/li&gt;
&lt;li&gt;The program validates password against user-supplied hash; user is in (with any password)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Stack Smashing&lt;br&gt;
 缓冲区溢出攻击的核心是覆盖栈上的 返回地址（ret）。当返回地址被覆盖时，程序在函数返回时不会跳回调用函数的位置，而是跳转到攻击者指定的位置。攻击者可以利用这种技术让程序执行任意代码（如恶意代码或 shellcode），这被称为堆栈破坏。&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Stack Smashing&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionA&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *str)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer[&lt;span class=&#34;number&#34;&gt;16&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buffer, str);   &lt;span class=&#34;comment&#34;&gt;//segmentation fault&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; large_string[&lt;span class=&#34;number&#34;&gt;256&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;255&lt;/span&gt;; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		large_string[i] = &lt;span class=&#34;string&#34;&gt;&amp;#x27;A&amp;#x27;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	functionA(large_string); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buffer&lt;/code&gt; ：在  &lt;code&gt;functionA&lt;/code&gt;  中声明为 16 字节的字符数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcpy(buffer, str)&lt;/code&gt; ：使用  &lt;code&gt;strcpy&lt;/code&gt;  将外部传入的字符串 str 复制到 buffer 中。由于  &lt;code&gt;strcpy&lt;/code&gt;  不检查长度，如果  &lt;code&gt;str&lt;/code&gt;  的长度超过 16 字节，会导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;在  &lt;code&gt;main&lt;/code&gt;  中， &lt;code&gt;large_string&lt;/code&gt;  是一个 256 字节的数组，它被填充为 255 个 ‘A’。当  &lt;code&gt;large_string&lt;/code&gt;  被传递给  &lt;code&gt;functionA&lt;/code&gt;  时， &lt;code&gt;buffer&lt;/code&gt;  被溢出。&lt;/li&gt;
&lt;li&gt;修复：  &lt;code&gt;strcpy(buffer, str)&lt;/code&gt;  --&amp;gt;  &lt;code&gt;strncpy(buffer, str, 16);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/26/671ca87ccb1e2.png&#34; alt=&#34;img&#34;&gt;&lt;br&gt;
 &lt;code&gt;large_str&lt;/code&gt;  has overflowed  &lt;code&gt;buffer&lt;/code&gt;  and  &lt;code&gt;sfp&lt;/code&gt;  and  &lt;code&gt;ret&lt;/code&gt;  and  &lt;code&gt;*str&lt;/code&gt; .Note that  &lt;code&gt;ret&lt;/code&gt;  is the return address!&lt;br&gt;
This means we can get the function to return to any point in the code that we specify.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer overflows allow us to change return address
&lt;ol&gt;
&lt;li&gt;Can point to any function in the library&lt;/li&gt;
&lt;li&gt;Can point to own code&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Add code in the overflowed buffer
&lt;ol&gt;
&lt;li&gt;Run at privilege of process (very useful if root!)&lt;/li&gt;
&lt;li&gt;Even a small buffer can invoke a shell using the system call (often called shellcode)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Attacker would like to run shell at root level
&lt;ol&gt;
&lt;li&gt;Make system call to  &lt;code&gt;execve&lt;/code&gt; , passing  &lt;code&gt;/bin/sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Needs to be part of the buffer, and in assembly code (以便精确控制其大小和功能)&lt;/li&gt;
&lt;li&gt;Program has to fit in buffer without overwriting return address (如果 shellcode 覆盖了返回地址本身，可能导致程序崩溃而无法执行攻击代码)&lt;/li&gt;
&lt;li&gt;Pad out buffer to return address, and point return address to start of buffer&lt;/li&gt;
&lt;li&gt;Don’t generate core dump (this will cause suspicion)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;What do You Need to Hack a Buffer Overflow
&lt;ol&gt;
&lt;li&gt;Address where buffer begins&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Easy to get if you have access to the same type of system being attacked&lt;/li&gt;
&lt;li&gt;Can use Null Operation (NOP) commands to make the target address bigger&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Location where return address is stored&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Can pad out the buffer with return address&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Assembly language program to spawn a shell (shellcode payload)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Can use gdb to disassemble a program for you&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Affected Languages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Buffer overflows mainly occur in low-level programming languages that allow direct memory access: Assembler, C, C++&lt;br&gt;
Note that some high-level languages such as Java, C# and Visual Basic are written in C, C++ or call modules written in these languages&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;Buffer Overflow Examples&lt;br&gt;
Functions that handle arrays but do not check length (checking for termination character is insufficient) In C/C++,   &lt;code&gt;gets&lt;/code&gt; ,  &lt;code&gt;strcpy&lt;/code&gt; ,  &lt;code&gt;strcat&lt;/code&gt; ,  &lt;code&gt;sprintf&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Example 1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; gets(buf);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char buf[20]&lt;/code&gt; ：定义了一个长度为 20 的字符数组  &lt;code&gt;buf&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gets(buf)&lt;/code&gt; ：使用  &lt;code&gt;gets()&lt;/code&gt;  函数从标准输入读取字符串，并存储在  &lt;code&gt;buf&lt;/code&gt;  中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gets()&lt;/code&gt;  函数不检查输入的长度，意味着如果输入的字符串长度超过了  &lt;code&gt;buf&lt;/code&gt;  的大小（20 字节），则会发生缓冲区溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复：  &lt;code&gt;fgets(buf, sizeof(buf), stdin);&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Example 2&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; prefix[] = &lt;span class=&#34;string&#34;&gt;&amp;quot;http://&amp;quot;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   ... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &lt;span class=&#34;comment&#34;&gt;// copies the string prefix to buf &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buf, prefix); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &lt;span class=&#34;comment&#34;&gt;// concatenates path to the string buf &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strncat&lt;/span&gt;(buf, path, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(buf));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char buf[20]&lt;/code&gt; ：定义了一个长度为 20 字节的字符数组  &lt;code&gt;buf&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char prefix[] = &amp;quot;http://&amp;quot;;&lt;/code&gt; ：定义了一个包含字符串  &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt;  的字符数组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strcpy(buf, prefix)&lt;/code&gt; ：将字符串  &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt;  复制到  &lt;code&gt;buf&lt;/code&gt;  中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题： &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt;  长度为 7 字节（包括终止符 \0），在复制后， &lt;code&gt;buf&lt;/code&gt;  中只剩下 13 个字节可用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strncat(buf, path, sizeof(buf))&lt;/code&gt; ：将字符串  &lt;code&gt;path&lt;/code&gt;  连接到  &lt;code&gt;buf&lt;/code&gt;  中，指定的最大长度为  &lt;code&gt;sizeof(buf)&lt;/code&gt; （即 20 字节）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题：这里的  &lt;code&gt;sizeof(buf)&lt;/code&gt;  是 20 字节，但在前面已经用掉了 7 字节（包括终止符）。 &lt;code&gt;strncat()&lt;/code&gt;  试图追加  &lt;code&gt;path&lt;/code&gt;  的内容时，可能会超出  &lt;code&gt;buf&lt;/code&gt;  的剩余空间（13 字节），导致缓冲区溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复： &lt;code&gt;strncat(buf, path, sizeof(buf) - strlen(buf) - 1);&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Example 3&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;32&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(buf, data, &lt;span class=&#34;built_in&#34;&gt;strlen&lt;/span&gt;(data)); &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;strncpy(buf, data, strlen(data))&lt;/code&gt; ：将字符串  &lt;code&gt;data&lt;/code&gt;  复制到  &lt;code&gt;buf&lt;/code&gt;  中，复制的长度为  &lt;code&gt;strlen(data)&lt;/code&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缺陷 1：缺少终止符 \0： &lt;code&gt;strncpy&lt;/code&gt;  不会自动添加字符串的终止符  &lt;code&gt;\0&lt;/code&gt; ，如果  &lt;code&gt;data&lt;/code&gt;  的长度等于或大于 32，那么  &lt;code&gt;buf&lt;/code&gt;  不会以  &lt;code&gt;\0&lt;/code&gt;  结尾。这可能导致  &lt;code&gt;buf&lt;/code&gt;  被当作未终止的字符串处理，带来不确定的行为或安全风险。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺陷 2：可能的缓冲区溢出：如果  &lt;code&gt;strlen(data) &amp;gt; 32&lt;/code&gt; ， &lt;code&gt;strncpy&lt;/code&gt;  将尝试复制超过  &lt;code&gt;buf&lt;/code&gt;  大小的内容，导致缓冲区溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复： &lt;code&gt;strncpy(buf, data, sizeof(buf) - 1); buf[sizeof(buf) - 1] = &#39;\0&#39;;&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Example 4&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[MAX_PATH]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;sprintf&lt;/span&gt;(buf, &lt;span class=&#34;string&#34;&gt;&amp;quot;%s - %d\n&amp;quot;&lt;/span&gt;, path, errno);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sprintf(buf, &amp;quot;%s - %d\n&amp;quot;, path, errno)&lt;/code&gt;  会将  &lt;code&gt;path&lt;/code&gt;  和  &lt;code&gt;errno&lt;/code&gt;  的格式化字符串复制到  &lt;code&gt;buf&lt;/code&gt;  中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sprintf&lt;/code&gt;  不检查  &lt;code&gt;buf&lt;/code&gt;  的大小是否足以容纳格式化后的结果。如果  &lt;code&gt;path&lt;/code&gt;  很长，加上数字  &lt;code&gt;errno&lt;/code&gt;  和其他字符，可能会超过  &lt;code&gt;MAX_PATH&lt;/code&gt; ，导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;修复：  &lt;code&gt;snprintf(buf, sizeof(buf), &amp;quot;%s - %d\n&amp;quot;, path, errno);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Stack buffer overflow prevention&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Stack buffer overflow prevention&#34;&gt;#&lt;/a&gt;Stack buffer overflow prevention&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Spotting Buffer Overflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Check inputs, whether read from the network, a file, or from the command line&lt;/li&gt;
&lt;li&gt;Check transfer of data from said input to internal structures&lt;/li&gt;
&lt;li&gt;Look for use of unsafe string handling calls&lt;/li&gt;
&lt;li&gt;Look for use of arithmetic to calculate an allocation size or remaining buffer size&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Fixing Buffer Overflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Replace dangerous string handling functions&lt;/li&gt;
&lt;li&gt;Replace C string buffers with C++ strings&lt;/li&gt;
&lt;li&gt;Replace static arrays with STL containers&lt;/li&gt;
&lt;li&gt;Use analysis tools, Examples include Fortify, Coverity, PREfast, and Klocwor&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Code Analysis&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Statically check source to detect buffer overflows s&lt;/li&gt;
&lt;li&gt;Several tools exist to automate the review process&lt;br&gt;
Stanford:  Engler, et al.  Test trust inconsistency&lt;br&gt;
@stake.com  (&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2wwcGh0LmNvbQ==&#34;&gt;l0pht.com&lt;/span&gt;): SLINT (designed for UNIX)&lt;br&gt;
Berkeley:  Wagner, et al.  Test constraint violations&lt;/li&gt;
&lt;li&gt;Find lots of bugs, but not all&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Marking Stack as Non-Execute&lt;br&gt;
Basic stack exploit can be prevented by marking stack segment as non-executable&lt;br&gt;
Limitations and Problems&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Some apps need executable stack (e.g. LISP interpreters)&lt;/li&gt;
&lt;li&gt;Does not block more general overflow exploits&lt;/li&gt;
&lt;li&gt;Overflow on heap: overflow buffer next to func pointer&lt;/li&gt;
&lt;li&gt;Cannot make all the data segment non-executable&lt;/li&gt;
&lt;li&gt;More recent UNIX and MS windows emit dynamic code into program data for performance optimisations&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Stack Protection and Run-time Checking&lt;br&gt;
Many run-time checking techniques
&lt;ol&gt;
&lt;li&gt;Example:  StackGuard (WireX)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Run time tests for stack integrity&lt;/li&gt;
&lt;li&gt;Code generator for emitting code to set up and tear down functions&lt;/li&gt;
&lt;li&gt;Embeds “canaries” in stack frames and verify their integrity prior to function return&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Libsafe (Avaya Labs)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Dynamically loaded library&lt;/li&gt;
&lt;li&gt;Intercepts calls to  &lt;code&gt;strcpy (dest, src)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Validate sufficient space in current stack frame: |framepointer–dest| &amp;gt; strlen(src)&lt;/li&gt;
&lt;li&gt;If so, does strcpy. Otherwise, terminates application&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Address obfuscation (Stony Brook’03)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Encrypt return address on stack by XORing with random string. Decrypt just before returning from function&lt;/li&gt;
&lt;li&gt;Attacker needs decryption key to set return address to desired value&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;PaX ASLR: Randomise location of libc&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Attacker cannot jump directly to exec function&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="software security" />
        <category term="C" />
        <category term="vulnerability" />
        <updated>2024-10-26T07:50:30.000Z</updated>
    </entry>
</feed>
