<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title> • Posts by &#34;linux&#34; tag</title>
    <link href="http://example.com" />
    <updated>2024-10-25T07:43:11.000Z</updated>
    <category term="JavaScript" />
    <category term="Blog" />
    <category term="日常" />
    <category term="C language" />
    <category term="Linux" />
    <category term="software security" />
    <category term="C" />
    <category term="vulnerability" />
    <category term="gdb" />
    <entry>
        <id>http://example.com/course/x86-architecture-and-Assembly-basics/</id>
        <title>x86 architecture and Assembly basics</title>
        <link rel="alternate" href="http://example.com/course/x86-architecture-and-Assembly-basics/"/>
        <content type="html">&lt;h1 id=&#34; x86 architecture&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;# x86 architecture&#34;&gt;#&lt;/a&gt; x86 architecture&lt;/h1&gt;
&lt;h2 id=&#34;Levels of Abstraction&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Levels of Abstraction&#34;&gt;#&lt;/a&gt; Levels of Abstraction&lt;/h2&gt;
&lt;p&gt;抽象层次（Levels of Abstraction） 是指在计算机系统设计中，将复杂的系统分解为不同的层次，以便于理解、设计和实现。每个抽象层都基于更底层的层次，同时也为更高层次提供基础。这种层次化的设计方式使得复杂系统的开发和维护更加高效。以下是这些抽象层次的具体解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬件层（Hardware Level）&lt;br&gt;
解释：这是最底层的抽象层，主要是由各种电子电路和逻辑门（如 XOR、AND、OR、NOT 门等）组成。这些电路实现了最基本的逻辑运算和数据处理，是计算机所有功能的基础。&lt;br&gt;
特点：这一层是最接近物理硬件的，直接处理电信号和物理开关状态。&lt;/li&gt;
&lt;li&gt;微码层（Microcode Level）/ 固件层（Firmware Level）&lt;br&gt;
解释：微码（或固件）是一种嵌入在硬件中的特殊程序，用来解释机器指令并控制底层硬件的操作。它位于硬件和机器码之间。&lt;br&gt;
特点：微码作为硬件与机器码的桥梁，是指令执行的控制逻辑，可以在不改变硬件的情况下更新或调整计算机的功能。&lt;/li&gt;
&lt;li&gt;机器码层（Machine Code Level）&lt;br&gt;
解释：机器码是计算机直接执行的二进制代码，通常以操作码（opcodes）和十六进制数字形式表示。它由一系列低级指令组成，用于控制计算机的处理器执行任务。&lt;br&gt;
特点：机器码是最底层的可编程语言，只有计算机可以直接执行，由处理器按照指令执行具体操作。&lt;/li&gt;
&lt;li&gt;低级语言层（Low-Level Languages Level）&lt;br&gt;
解释：低级语言是机器码的人类可读版本，例如汇编语言（Assembly Language）。它使用助记符（如 MOV、ADD、JMP 等）来代表机器指令，更易于编程和调试。&lt;br&gt;
特点：低级语言紧密对应计算机的硬件结构，编程者需要了解具体的计算机架构，适合编写操作系统、驱动程序和嵌入式系统。&lt;/li&gt;
&lt;li&gt;高级语言层（High-Level Languages Level）&lt;br&gt;
解释：高级语言（如 C、C++、Java 等）提供了更抽象、更人性化的语法和结构，使得编程者可以更轻松地编写复杂的程序。这些语言中的代码通过编译器转换成机器码。&lt;br&gt;
特点：高级语言通常具有良好的跨平台性和可移植性，编程效率高，适合开发应用程序和大型软件系统。&lt;/li&gt;
&lt;li&gt;解释型语言层（Interpreted Languages Level）&lt;br&gt;
解释：解释型语言（如 Python、JavaScript）不是直接编译成机器码，而是先被翻译成字节码，然后在解释器中执行。&lt;br&gt;
特点：解释型语言更灵活，适合快速开发和原型设计，但执行速度通常比编译型语言慢。&lt;/li&gt;
&lt;li&gt;字节码层（Bytecode Level）&lt;br&gt;
解释：字节码是高级语言在被解释执行之前的中间形式。解释器将字节码翻译为机器可以执行的指令。&lt;br&gt;
特点：字节码的设计通常与硬件无关，可以在不同的平台上被相同的解释器执行，例如 Java 和 Python 的虚拟机（JVM、Python Interpreter）都使用字节码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/25/671b4d8733f64.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Assembly&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Assembly&#34;&gt;#&lt;/a&gt; Assembly&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;汇编语言（Assembly Language） 是一种低级编程语言，它与计算机的机器码有着一一对应的关系，并且比机器码更易于人类理解和编写。以下是对汇编语言及相关概念的详细中文解释：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;汇编语言的定义&lt;br&gt;
汇编语言是最接近机器码的高级语言，它可以将机器指令用人类可读的助记符（如 MOV、ADD、JMP 等）来表示。这使得程序员能够直接控制硬件，同时比直接编写二进制代码更加方便。&lt;/li&gt;
&lt;li&gt;与机器码的关系&lt;br&gt;
汇编语言是最可靠的、可以从机器码中恢复的高级语言。如果高层语言的源代码不可用时，通过反汇编（disassembly），可以将机器码转换回对应的汇编代码。&lt;br&gt;
汇编语言和机器码之间的对应关系使得程序员可以清楚地了解计算机底层的执行逻辑和流程。&lt;/li&gt;
&lt;li&gt;脆弱代码和恶意软件的存储形式&lt;br&gt;
在内存或磁盘中，脆弱代码或恶意软件通常以二进制形式（即机器码）存储。这种形式是计算机直接执行的代码，但对人类而言不可读。&lt;/li&gt;
&lt;li&gt;反汇编器的作用&lt;br&gt;
反汇编器是一种工具，它以二进制代码为输入，并将其翻译成相应的汇编代码输出。通过反汇编，可以将机器码还原为人类可读的汇编语言，有助于分析和调试程序，特别是在逆向工程或安全分析中。&lt;/li&gt;
&lt;li&gt;汇编语言是多种语言的集合&lt;br&gt;
汇编语言实际上是多种语言的集合，因为不同的计算机架构（如 x86、ARM、MIPS 等）有各自独特的指令集和汇编语言格式。&lt;br&gt;
在学习和使用汇编语言时，通常会针对特定的计算机架构进行深入研究。例如，x86 汇编和 ARM 汇编在指令集、寄存器使用和指令格式上都有明显的不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/25/671b4f21f3929.png&#34; alt=&#34;img&#34;&gt;&lt;br&gt;
 整个过程从汇编语言（asm 文件）开始，通过汇编器生成目标文件，再通过链接器将目标文件和库文件结合生成可执行文件，最后将可执行文件加载到内存中运行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汇编器（Assembler）&lt;br&gt;
汇编器的作用是将汇编语言的代码（asm 文件）翻译成目标文件（object file）。目标文件是二进制形式的文件，包含了机器可以理解的指令和数据，但还不是完整的可执行程序。&lt;/li&gt;
&lt;li&gt;链接器（Linker）&lt;br&gt;
链接器的作用是将多个目标文件和库文件（如静态库或动态库）组合起来，生成一个完整的可执行文件（Executable）。&lt;br&gt;
静态库（Static Library）：静态库中的代码在编译期间直接被链接到可执行文件中。&lt;br&gt;
动态库（Dynamic Library）：动态库中的代码在运行时被加载到内存中。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Assembler vs. Compiler&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;编译器 (Compiler) vs. 汇编器 (Assembler)&lt;br&gt;
 编译器：将高级编程语言的代码（如 C、C++、Java 等）转换为机器级代码。&lt;br&gt;
汇编器：将汇编语言的代码转换为机器级代码。&lt;/li&gt;
&lt;li&gt;输入&lt;br&gt;
编译器：以高级语言的源代码为输入。&lt;br&gt;
汇编器：以汇编语言的代码为输入。&lt;/li&gt;
&lt;li&gt;转换方式&lt;br&gt;
编译器：会检查并一次性将整个代码转换为机器代码。&lt;br&gt;
汇编器：一般不一次性转换完整代码，而是分两步处理。&lt;/li&gt;
&lt;li&gt;内部模块&lt;br&gt;
编译器：包含词法分析器、语法分析器、语义分析器、代码优化器和代码生成器等模块。(lexical analyzer, Syntax analyzer, Semantic analyzer, Code optimizer, Code generator)&lt;br&gt;
 汇编器：在两次扫描中完成所有工作。&lt;/li&gt;
&lt;li&gt;输出结果&lt;br&gt;
编译器：输出的是机器代码的助记符 (Mnemonic) 版本。&lt;br&gt;
汇编器：输出的是机器代码的二进制版本。&lt;/li&gt;
&lt;li&gt;常见类型&lt;br&gt;
编译器：如 C、C++、Java 的编译器。&lt;br&gt;
汇编器：如 GAS（GNU Assembler）、GNU 汇编器&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Two main forms of assembly syntax&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;NASM format: &lt;instr&gt; &lt;dest&gt;, &lt;source&gt; &amp;lt;; comment&amp;gt; : mov eax, 10&lt;/li&gt;
&lt;li&gt;AT&amp;amp;T format:  &lt;instr&gt; &lt;source&gt;, &lt;dest&gt; &amp;lt;# comment&amp;gt;: mov $10, %eax&lt;br&gt;
AT&amp;amp;T format reverses the order of operands, uses a % before registers and a $ before literal values&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Fundamental Data Types&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/25/671b528c52025.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Byte（字节）&lt;br&gt;
大小：1 字节 = 8 位（bit）。&lt;br&gt;
示例：图中展示的 5D 是一个 8 位的二进制数（01011101），它可以用一个字节来表示。&lt;br&gt;
解释：一个字节的二进制位可以表示 0 到 255 之间的整数（无符号），或 -128 到 127 之间的整数（有符号）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Word（字）&lt;br&gt;
大小：2 字节 = 16 位（bit）。&lt;br&gt;
示例：图中展示的 8BEC 表示一个 16 位的二进制数，其中：&lt;br&gt;
高字节（High Byte）：8B&lt;br&gt;
 低字节（Low Byte）：EC&lt;br&gt;
 解释：一个 Word 可以表示 0 到 65535 之间的无符号整数，或 -32768 到 32767 之间的有符号整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dword（双字）&lt;br&gt;
大小：4 字节 = 32 位（bit）。&lt;br&gt;
示例：图中展示的 000136CF 表示一个 32 位的二进制数，其中：&lt;br&gt;
高字（High Word）：0001&lt;br&gt;
 低字（Low Word）：36CF&lt;br&gt;
 解释：一个 Dword 可以表示更大的整数范围，用于存储更大的数值或内存地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qword（四字）&lt;br&gt;
大小：8 字节 = 64 位（bit）。&lt;br&gt;
示例：图中展示的 CF000136CF 表示一个 64 位的二进制数，其中：&lt;br&gt;
高双字（High Dword）：CF00&lt;br&gt;
 低双字（Low Dword）：0136CF&lt;br&gt;
 解释：一个 Qword 可以表示更大的整数或浮点数范围，常用于 64 位处理器上的运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Data in Memory&lt;br&gt;
Little-endian format: a low-order byte is stored at the lower address&lt;br&gt;
&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/25/671b538e3e57f.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;CPU Registers&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#CPU Registers&#34;&gt;#&lt;/a&gt;CPU Registers&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CPU 寄存器是 CPU 内部的一小部分数据存储单元，用于暂存指令、数据和状态信息。寄存器是 CPU 中速度最快的存储单元，比其他存储设备（如 RAM、硬盘）快得多，因为它们位于 CPU 内部，能够快速读写数据。&lt;br&gt;
CPU 寄存器的类型&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器（General Registers）&lt;br&gt;
用途：在程序执行期间由 CPU 使用，用于存储数据、操作数和临时结果。&lt;br&gt;
功能：可以用于整数运算、地址运算和数据的传输，是最常用的寄存器类型。&lt;/li&gt;
&lt;li&gt;段寄存器（Segment Registers）&lt;br&gt;
用途：用于管理和跟踪内存的不同段（如代码段、数据段和栈段）。&lt;br&gt;
功能：帮助 CPU 确定内存访问的具体区域，使得内存分段管理更加高效。&lt;/li&gt;
&lt;li&gt;状态标志（Status Flags）&lt;br&gt;
用途：存储程序执行的状态信息，例如运算结果是正、负、零，或是否发生溢出等。&lt;br&gt;
功能：在 CPU 进行条件判断或决策时提供必要的信息支持，决定程序的执行路径。&lt;/li&gt;
&lt;li&gt;指令指针（Instruction Pointers）&lt;br&gt;
用途：用于跟踪下一条将要执行的指令的地址。&lt;br&gt;
功能：确保程序的指令按顺序执行，是控制程序流程的关键寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;x86 Registers
&lt;ol&gt;
&lt;li&gt;数据寄存器（Data Registers）
&lt;ul&gt;
&lt;li&gt;EAX（累加器）：主要用于输入 / 输出和大多数算术运算。例如，加法、减法、乘法和除法操作时，通常会用到 EAX。&lt;/li&gt;
&lt;li&gt;EBX（基址寄存器）：可用于索引寻址模式，即在访问数组或结构中的元素时，EBX 可以作为基址寄存器使用。&lt;/li&gt;
&lt;li&gt;ECX（计数寄存器）：在循环操作中存储循环计数，通常用于实现迭代操作。&lt;/li&gt;
&lt;li&gt;EDX（数据寄存器）：也用于输入 / 输出操作，有时与 AX 一起使用，例如在某些乘法和除法运算中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引寄存器（Index Registers）
&lt;ul&gt;
&lt;li&gt;ESI（源索引）：用于字符串操作的源索引，通常在数据的读取操作中使用。&lt;/li&gt;
&lt;li&gt;EDI（目标索引）：用于字符串操作的目标索引，通常在数据的写入操作中使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;段寄存器（Segment Registers）
&lt;ul&gt;
&lt;li&gt;CS（代码段寄存器）：指向包含所有将要执行的指令的代码段。&lt;/li&gt;
&lt;li&gt;DS（数据段寄存器）：指向包含全局数据、常量和工作区的数据段。&lt;/li&gt;
&lt;li&gt;SS（栈段寄存器）：指向包含局部数据和过程或子程序返回地址的栈段。&lt;/li&gt;
&lt;li&gt;其他段寄存器（ES、FS、GS）：提供额外的数据存储段，用于存放其他类型的数据。&lt;br&gt;
在段内的所有内存位置都相对于段的起始地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态寄存器（Status Register）
&lt;ul&gt;
&lt;li&gt;EFLAGS 寄存器：用于存储处理器的状态标志，每个标志位表示不同的状态或条件：&lt;/li&gt;
&lt;li&gt;ZF（零标志）：当运算结果为零时设置。&lt;/li&gt;
&lt;li&gt;CF（进位标志）：当运算结果过大或过小时设置。&lt;/li&gt;
&lt;li&gt;SF（符号标志）：当运算结果为负时设置。&lt;/li&gt;
&lt;li&gt;TF（陷阱标志）：用于调试，设置该标志时，处理器一次只执行一条指令。通常被调试工具（如 GDB）使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令指针（Instruction Pointer, EIP）也称为程序计数器，它包含下一条将被执行的指令的偏移地址。
&lt;ul&gt;
&lt;li&gt;EIP 的唯一目的是告诉处理器下一步要执行什么指令。&lt;/li&gt;
&lt;li&gt;当前指令的完整地址为 CS:EIP（代码段寄存器加指令指针）。&lt;/li&gt;
&lt;li&gt;如果攻击者能够控制 EIP，他们就能控制 CPU 的执行流程，因此 EIP 是常见攻击（如缓冲区溢出）的目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他指针寄存器（Other Pointer Registers）
&lt;ul&gt;
&lt;li&gt;ESP（栈指针寄存器）：提供程序栈中的偏移值，SS:ESP 表示栈顶（当前数据或地址在程序栈中的位置）。&lt;/li&gt;
&lt;li&gt;EBP（基址指针寄存器）：主要用于引用传递给子程序的参数变量（如函数调用）。SS:EBP 表示当前调用的栈帧 (stack frame)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Assembly basics&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Assembly basics&#34;&gt;#&lt;/a&gt; Assembly basics&lt;/h1&gt;
&lt;h2 id=&#34;Simple Instructions&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Simple Instructions&#34;&gt;#&lt;/a&gt;Simple Instructions&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;mov instruction&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/25/671b589f37dc7.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;lea (load effective address) instruction puts a memory address into the&lt;br&gt;
destination&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.g. lea eax, [ebx+8] puts EBX+8 into EAX&lt;/li&gt;
&lt;li&gt;e.g. mov eax, [ebx+8] loads the data at the memory address EBX+8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/25/671b595145504.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mov eax, [ebx+8] places the value 0x20 into EAX&lt;/li&gt;
&lt;li&gt;lea eax, [ebx+8] places the value 0xB30048 into EAX&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Arithmetic&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;sub eax, 0x10&lt;br&gt;
 描述：从寄存器 EAX 中减去 0x10（十六进制的 16）。&lt;br&gt;
结果：EAX 的值减少 16。&lt;/li&gt;
&lt;li&gt;add eax, ebx&lt;br&gt;
 描述：将寄存器 EBX 的值加到 EAX 中，并将结果存储在 EAX 中。&lt;br&gt;
结果：EAX = EAX + EBX。&lt;/li&gt;
&lt;li&gt;inc edx&lt;br&gt;
 描述：将寄存器 EDX 的值加 1。&lt;br&gt;
结果：EDX 的值增加 1。&lt;/li&gt;
&lt;li&gt;dec ecx&lt;br&gt;
 描述：将寄存器 ECX 的值减 1。&lt;br&gt;
结果：ECX 的值减少 1。&lt;/li&gt;
&lt;li&gt;mul 0x50&lt;br&gt;
 描述：将寄存器 EAX 的值乘以 0x50（十六进制的 80），并将结果存储在 EDX&lt;br&gt;
 中。&lt;br&gt;
结果：EAX 中存储低 32 位的乘积，EDX 中存储高 32 位的乘积。&lt;/li&gt;
&lt;li&gt;div 0x75&lt;br&gt;
 描述：用寄存器 EDX&lt;br&gt;
（将 EDX 和 EAX 结合起来，表示 64 位的数值）除以 0x75（十六进制的 117）。&lt;br&gt;
结果：商存储在 EAX 中，余数存储在 EDX 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Logics&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;xor eax, eax&lt;br&gt;
 描述：将寄存器 EAX 和自身进行异或操作，清除 EAX 中的值（即将 EAX 置为 0）。&lt;br&gt;
结果：EAX = 0。&lt;/li&gt;
&lt;li&gt;or eax, 0x7575&lt;br&gt;
 描述：对 EAX 寄存器和 0x7575 进行逻辑或（OR）操作。&lt;br&gt;
结果：EAX 的每个位都与 0x7575 的相应位进行或操作。&lt;/li&gt;
&lt;li&gt;mov eax, 0xA 和 shl eax, 2&lt;br&gt;
mov eax, 0xA：将 EAX 设置为 0xA（十六进制的 10）。&lt;br&gt;
shl eax, 2：将 EAX 寄存器中的值左移 2 位。&lt;br&gt;
结果：EAX 的值变为 0x28（十六进制的 40），因为二进制的 1010 左移 2 位变为 101000。&lt;/li&gt;
&lt;li&gt;mov bl, 0xA 和 ror bl, 2&lt;br&gt;
mov bl, 0xA：将 BL 设置为 0xA（十六进制的 10）。&lt;br&gt;
ror bl, 2：将 BL 寄存器中的值右旋 2 位。&lt;br&gt;
结果：BL 的值变为 10000010，因为二进制的 1010 右旋 2 位变为 10000010。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;nop&lt;br&gt;
 描述：NOP 指令不执行任何操作，仅仅让处理器继续执行下一条指令。&lt;br&gt;
作用：NOP 实际上是 xchg eax, eax 的伪指令，因为将 EAX 与自身交换不会改变任何值。&lt;br&gt;
用途：在缓冲区溢出攻击中，攻击者常使用 NOP 指令来填充攻击代码，使得执行具有一定的缓冲空间。NOP 的操作码是 0x90。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;The Stack&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#The Stack&#34;&gt;#&lt;/a&gt;The Stack&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;栈的基本概念&lt;br&gt;
栈 是一种 后进先出（LIFO） 的数据结构，这意味着最后放入的数据将是第一个被取出的。&lt;br&gt;
栈通常用于存储函数调用的参数、局部变量、返回地址和一些控制信息。&lt;br&gt;
栈的主要寄存器包括：&lt;br&gt;
ESP（栈指针）：指向当前栈顶。&lt;br&gt;
EBP（基址指针）：跟踪局部变量和函数参数的位置。&lt;/li&gt;
&lt;li&gt;栈指令&lt;br&gt;
栈操作包括以下几种常见指令：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;push：将数据压入栈中，ESP 会减少（栈向下增长）。&lt;/li&gt;
&lt;li&gt;pop：从栈中弹出数据，ESP 会增加。&lt;/li&gt;
&lt;li&gt;call：调用函数，将当前指令的地址压入栈中，并跳转到指定函数的位置。&lt;/li&gt;
&lt;li&gt;leave：用于函数返回时，将栈恢复到调用者的状态。&lt;/li&gt;
&lt;li&gt;enter：为新函数栈帧分配空间，保存当前的 EBP，并更新 EBP 为新栈帧的起始位置。&lt;/li&gt;
&lt;li&gt;ret：函数返回，将栈顶的返回地址弹出到 EIP 中，恢复程序的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;函数调用的栈操作&lt;br&gt;
在函数调用过程中，栈的使用通常按照以下步骤进行：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;参数入栈：使用 push 指令将函数的参数依次压入栈中。&lt;/li&gt;
&lt;li&gt;调用函数：使用  &lt;code&gt;call &amp;lt;location&amp;gt;&lt;/code&gt;  指令调用函数。当前指令地址（EIP）会被压入栈中，便于函数执行完毕后返回。EIP 将被设置为函数的起始地址（ &lt;code&gt;&amp;lt;location&amp;gt;&lt;/code&gt; ）。&lt;/li&gt;
&lt;li&gt;保存局部变量和 EBP：函数调用后，局部变量和调用者的 EBP 被压入栈中，用于为新函数栈帧分配空间。&lt;/li&gt;
&lt;li&gt;执行函数：函数内部执行具体的任务，包括访问局部变量、处理逻辑和修改数据。&lt;/li&gt;
&lt;li&gt;恢复局部变量和调用者的 EBP：使用 leave 指令，将 EBP 和局部变量恢复为调用者的状态。&lt;/li&gt;
&lt;li&gt;恢复 EIP：使用 ret 指令，将栈顶的返回地址弹出到 EIP 中，以继续执行调用函数的程序。&lt;/li&gt;
&lt;li&gt;清理参数：参数在函数返回后可能需要被清理，从而恢复栈的平衡状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/25/671b64bb0713f.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Conditionals and Branching&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Conditionals and Branching&#34;&gt;#&lt;/a&gt;Conditionals and Branching&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;条件指令（Conditionals）
&lt;ol&gt;
&lt;li&gt;test 指令&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;功能：test 指令类似于逻辑与（AND）操作，但不会修改操作数，只用于设置标志位。&lt;/li&gt;
&lt;li&gt;标志位：主要设置 ZF（零标志）。如果操作数之间的逻辑与结果为零，则 ZF 被置 1，否则置 0。&lt;/li&gt;
&lt;li&gt;用法：通常用于检查某个位是否被设置，例如判断一个变量是否为零或检测特定位是否为 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;cmp 指令&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;功能：cmp 指令类似于减法（SUB）操作，但不会改变操作数的值，只用于设置标志位。&lt;/li&gt;
&lt;li&gt;标志位：主要设置 ZF（零标志） 和 CF（进位标志）。&lt;/li&gt;
&lt;li&gt;ZF（零标志）：当两个操作数相等时，ZF 被置 1。&lt;/li&gt;
&lt;li&gt;CF（进位标志）：当目标操作数小于源操作数时，CF 被置 1。&lt;/li&gt;
&lt;li&gt;用法：通常用于比较两个数值大小，以决定下一步的条件跳转。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;cmp 指令的标志位结果&lt;br&gt;
 cmp dst, src 的不同结果下的标志位变化：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;dst = src：ZF = 1, CF = 0（目标操作数等于源操作数）。&lt;/li&gt;
&lt;li&gt;dst &amp;lt; src：ZF = 0, CF = 1（目标操作数小于源操作数）。&lt;/li&gt;
&lt;li&gt;dst &amp;gt; src：ZF = 0, CF = 0（目标操作数大于源操作数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分支指令（Branching）&lt;br&gt;
分支是根据程序的控制流有条件地执行代码序列。分支指令决定程序在特定条件下的跳转。
&lt;ol&gt;
&lt;li&gt;无条件跳转（Unconditional Jump）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;jmp &lt;location&gt;：无条件跳转指令会直接跳转到指定的位置（&lt;location&gt;），无论条件是否满足。&lt;/li&gt;
&lt;li&gt;用法：无条件跳转用于改变程序的执行顺序，是一种不依赖标志位的跳转形式。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;条件跳转（Conditional Jump）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;条件跳转指令：使用标志寄存器的值来决定是否进行跳转。常见的条件跳转指令有超过 30 种。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="C language" />
        <category term="Linux" />
        <category term="software security" />
        <category term="gdb" />
        <updated>2024-10-25T07:43:11.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/course/C-language-basics-and-Computer-memory/</id>
        <title>C language basics and Computer memory</title>
        <link rel="alternate" href="http://example.com/course/C-language-basics-and-Computer-memory/"/>
        <content type="html">&lt;h1 id=&#34;C language basics&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#C language basics&#34;&gt;#&lt;/a&gt;C language basics&lt;/h1&gt;
&lt;h2 id=&#34;input/output&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#input/output&#34;&gt;#&lt;/a&gt; input/output&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;To print output to the terminal screen:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;printf(“Hello\n”);&lt;/li&gt;
&lt;li&gt;printf(“Hello %s”, “haxor”);  // using a format string&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;To get input from the user:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;scanf(&amp;quot;%d&amp;quot;, &amp;amp;number);&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Input/output format symbols&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;test\n&amp;quot;&lt;/span&gt;);   &lt;span class=&#34;comment&#34;&gt;// `\n`:  Carriage return/new line&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;test %d&amp;quot;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;123&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;//`%d`:  Decimal value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;test %s&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;123&amp;quot;&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;//`%s`:  String value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;test %x&amp;quot;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;0x123&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;//`%x`:  Hex value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;C Program takes command-line arguments&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//meet.c&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;greeting(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *temp1, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *temp2) &lt;span class=&#34;comment&#34;&gt;// greeting function to say hello&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; name[&lt;span class=&#34;number&#34;&gt;400&lt;/span&gt;];  &lt;span class=&#34;comment&#34;&gt;// string variable to hold the name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(name, temp2);  &lt;span class=&#34;comment&#34;&gt;// copy function argument to name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Hello %s %s\n&amp;quot;&lt;/span&gt;, temp1, name);  &lt;span class=&#34;comment&#34;&gt;// print out the greeting&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;main(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *argv[]) &lt;span class=&#34;comment&#34;&gt;// note the format for arguments&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    greeting(argv[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;], argv[&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;]);  &lt;span class=&#34;comment&#34;&gt;// call function, pass title &amp;amp; name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Bye %s %s\n&amp;quot;&lt;/span&gt;, argv[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;], argv[&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;]);  &lt;span class=&#34;comment&#34;&gt;// say “bye&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;Compiling C programs&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Compiling C programs&#34;&gt;#&lt;/a&gt; Compiling C programs&lt;/h2&gt;
Compiling C programs(Linux) Using gcc
&lt;ol&gt;
&lt;li&gt;To compile our  &lt;code&gt;meet.c&lt;/code&gt;  program, type&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable&#34;&gt;$gcc&lt;/span&gt; -o meet meet.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Then to execute the new program, type&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ ./meet zz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Commonly used gcc flags&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;-o &lt;filename&gt;: produces compiled binary file with filename (a.out by default).&lt;/li&gt;
&lt;li&gt;-S: produces assembly code in a file; saved with a .s extension&lt;/li&gt;
&lt;li&gt;-g, -ggdb: produces extra debugging information for gdb (GNU debugger)&lt;/li&gt;
&lt;li&gt;-c: compiles without linking; produces object files with an .o extension&lt;/li&gt;
&lt;li&gt;Check out manual by using: man gcc&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;32-bit vs 64-bit compilation&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;To compile into 32-bit binaries:&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable&#34;&gt;$gcc&lt;/span&gt; -m32 hello.c -o hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;install a standard library of&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable&#34;&gt;$sudo&lt;/span&gt; apt install gcc-multilib &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;C vs C#&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#C vs C#&#34;&gt;#&lt;/a&gt; C vs C#&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;C# is type-safe&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Strong static type system + runtime checks (e.g. bounds, type casts) + automatic memory management&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;C is type-unsafe&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Pointers + no runtime check (out-of-bound access, bad type casts), manual memory management&lt;br&gt;
Runtime array bounds check in C#&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If the following C# code is executed on .NET:&lt;/p&gt;
 &lt;figure class=&#34;highlight c#&#34;&gt;&lt;figcaption&gt;&lt;span&gt;(●ˇ∀ˇ●)&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt; arr[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; arr[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;An exception will be raised at runtime!&lt;/p&gt;
&lt;p&gt;The length of the array is recorded and checked by the runtime&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of an array is fixed once created&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No runtime array bounds check in C, If the same C code is executed:&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;(●ˇ∀ˇ●)&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; arr[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; arr[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;No error, result in a silent buffer overflow!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unexpected behaviours such as mysterious crashes depending on what was overwritten&lt;/li&gt;
&lt;li&gt;Attackers may exploit this if they can control the overwritten data&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Automatic memory management in C#&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Programmers do not write code to perform memory management tasks&lt;br&gt;
Garbage collector manages the allocation and release of memory&lt;br&gt;
C# has no common memory problems such as buffer overflow&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;C# strings&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C# strings are  &lt;code&gt;objects&lt;/code&gt;  of the  &lt;code&gt;String&lt;/code&gt;  class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Similar to an array of chars, but immutable&lt;/li&gt;
&lt;li&gt;The length is stored on the object for bounds checks at runtime&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All string manipulation operations do not modify the original string&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A new string is created upon modification&lt;/li&gt;
&lt;li&gt;For example,  &lt;code&gt;str.Trim()&lt;/code&gt;  returns a new string&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;C strings&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C strings are arrays of characters&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Terminated by and including the first occurrence of the null character  &lt;code&gt;\0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;String length is not automatically tracked&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is determined by the number of bytes (character) preceding the null character.&lt;/li&gt;
&lt;li&gt;The memory required to store a string is the number of characters plus one&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A string can be manipulated just like any other arrays&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We usually use some built-in string functions in C libraries&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;copy one string to another&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;    &lt;span class=&#34;comment&#34;&gt;// use string library     &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; str1[] = &lt;span class=&#34;string&#34;&gt;&amp;quot;Hello, Z&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; str2[&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(str2, str1);  &lt;span class=&#34;comment&#34;&gt;// copy each character in str1 into str2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The function  &lt;code&gt;strcpy&lt;/code&gt;  copies each character in the source string (a series of characters ending with and including a null character) into the destination string&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;To compare two strings&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; str1[] = &lt;span class=&#34;string&#34;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; str2[] = &lt;span class=&#34;string&#34;&gt;&amp;quot;haxor&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;built_in&#34;&gt;strcmp&lt;/span&gt;(str1, str2) == &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Strings are the same.\n&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Strings are different.\n&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;This code prints out: Strings are different.&lt;br&gt;
Note that the function  &lt;code&gt;strcmp()&lt;/code&gt;  does not return a  &lt;code&gt;boolean&lt;/code&gt;  result&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zero represents false, anything else represents true&lt;/li&gt;
&lt;li&gt;No  &lt;code&gt;boolean&lt;/code&gt;  type in C language prior to C99&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;Other common string functions&lt;/strong&gt; &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQ19Qcm9ncmFtbWluZy9TdHJpbmdfbWFuaXB1bGF0aW9u&#34;&gt;More can be found&lt;/span&gt;&lt;br&gt;
 &lt;code&gt;strlen&lt;/code&gt; : gets the length of a string&lt;br&gt;
 &lt;code&gt;strncpy&lt;/code&gt; : copies one string to another with a bound&lt;br&gt;
 &lt;code&gt;strcat&lt;/code&gt; ,  &lt;code&gt;strncat&lt;/code&gt; : string concatenation&lt;br&gt;
 &lt;code&gt;gets&lt;/code&gt; ,  &lt;code&gt;fgets&lt;/code&gt; : receives input into a string&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;C strings is error prone&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#C strings is error prone&#34;&gt;#&lt;/a&gt;C strings is error prone&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Common string manipulation errors:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Buffer errors&lt;/li&gt;
&lt;li&gt;Heap errors&lt;/li&gt;
&lt;li&gt;Out‐by‐bound errors&lt;/li&gt;
&lt;li&gt;Integer overflows&lt;/li&gt;
&lt;li&gt;Other memory, pointer and type errors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;When data is copied from an unbounded source to a fixed‐length sink&lt;/strong&gt;&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Unbounded string copy&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; username[&lt;span class=&#34;number&#34;&gt;8&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;built_in&#34;&gt;puts&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Please enter your username:&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	gets(username);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Your username is %s\n&amp;quot;&lt;/span&gt;, username);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Use of  &lt;code&gt;gets()&lt;/code&gt;  Function&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The function  &lt;code&gt;gets()&lt;/code&gt;  reads input from the user into a buffer, but it does not check the length of the input against the buffer’s size.&lt;br&gt;
In this code, the  &lt;code&gt;username&lt;/code&gt;  array is only 8 bytes long. However,  &lt;code&gt;gets()&lt;/code&gt;  allows users to enter an input of any length, which means it can write beyond the 8 bytes allocated for  &lt;code&gt;username&lt;/code&gt; .&lt;br&gt;
This can cause a buffer overflow, which can lead to memory corruption, unexpected behavior, or even security vulnerabilities where attackers can execute arbitrary code.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fixed-Length Buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The username array is declared to have a size of 8, but we need to reserve one byte for the null-terminator  &lt;code&gt;\0&lt;/code&gt; , which marks the end of the string.&lt;br&gt;
This means only 7 characters can safely be stored in the username buffer.&lt;br&gt;
If the input exceeds this limit, it will overflow into adjacent memory, potentially causing the program to crash or behave unpredictably.&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Unbounded string copy(fixed)&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; username[&lt;span class=&#34;number&#34;&gt;8&lt;/span&gt;];  &lt;span class=&#34;comment&#34;&gt;// Buffer limited to 8 bytes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;puts&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Please enter your username:&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    fgets(username, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(username), &lt;span class=&#34;built_in&#34;&gt;stdin&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;// Limit input size to prevent overflow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Your username is %s\n&amp;quot;&lt;/span&gt;, username);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;// Standard return type&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Better string functions from libraries&lt;/strong&gt;&lt;br&gt;
Should use functions that restrict the number of bytes for safer programming&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use  &lt;code&gt;fgets()&lt;/code&gt; , instead of  &lt;code&gt;gets()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use  &lt;code&gt;strncpy()&lt;/code&gt; , instead of  &lt;code&gt;strcpy()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use  &lt;code&gt;strncat()&lt;/code&gt; , instead of  &lt;code&gt;strcat()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use  &lt;code&gt;snprintf()&lt;/code&gt; , instead of instead of  &lt;code&gt;sprintf()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Null‐termination errors&lt;/strong&gt;&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Null‐termination errors&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; arr[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(arr, &lt;span class=&#34;string&#34;&gt;&amp;quot;0123456789&amp;quot;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(arr));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%s\n&amp;quot;&lt;/span&gt;, arr);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The array is not properly terminated by a null character!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When there is no null character among the first n character of the source, the string placed in the&lt;br&gt;
destination will not be null-terminated!&lt;br&gt;
The  &lt;code&gt;printf()&lt;/code&gt;  call prints out all bytes as character till reaching a null!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To test out, let’s add another array:&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Null‐termination errors&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; arr[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; arr2[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(arr, &lt;span class=&#34;string&#34;&gt;&amp;quot;0123456789&amp;quot;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(arr));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(arr2, &lt;span class=&#34;string&#34;&gt;&amp;quot;9876543210&amp;quot;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(arr2));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%s\n&amp;quot;&lt;/span&gt;, arr);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The program will print out 01234567899876543210&lt;br&gt;
Where the length of source string is the same or greater than the length of target string&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The source string gets truncated&lt;/li&gt;
&lt;li&gt;The target string may not be properly terminated by null!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How can we fix it?&lt;br&gt;
Manually add a null character at the end of the target string:&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Null‐termination errors(fixed)&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; arr[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(arr, &lt;span class=&#34;string&#34;&gt;&amp;quot;0123456789&amp;quot;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(arr)&lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	arr[&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(arr)&lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt;] = &lt;span class=&#34;string&#34;&gt;&amp;#x27;\0&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%s\n&amp;quot;&lt;/span&gt;, arr);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The function char  &lt;code&gt;*fgets(char *str, int n, FILE *stream)&lt;/code&gt;  reads  &lt;code&gt;(n-1)&lt;/code&gt;  characters from the specific stream plus the final null character&lt;/p&gt;
&lt;h1 id=&#34; Computer memory&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;# Computer memory&#34;&gt;#&lt;/a&gt; Computer memory&lt;/h1&gt;
&lt;h2 id=&#34; Intel x86 (32-bit)&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;# Intel x86 (32-bit)&#34;&gt;#&lt;/a&gt; Intel x86 (32-bit)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;von Neumann architecture&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Central processing unit (CPU) executes code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Main memory of the system (RAM) stores all data and code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Input/output system (I/O) interfaces with devices such as hard drives, keyboards, and monitors&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/24/671a56f0c953f.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The &lt;strong&gt;control unit&lt;/strong&gt; gets instructions to execute from RAM using the instruction pointer, which stores the address of the instruction to execute&lt;br&gt;
&lt;strong&gt;Registers&lt;/strong&gt; are the CPU’s basic data storage units and are often used to save time so that the CPU doesn’t need to access RAM.&lt;/p&gt;
&lt;p&gt;在 32 位 x86 架构中，主要的通用寄存器包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EAX: 累加器寄存器，用于算术运算和返回值。&lt;/li&gt;
&lt;li&gt;EBX: 基址寄存器，常用于基址存取。&lt;/li&gt;
&lt;li&gt;ECX: 计数器寄存器，常用于循环和移位操作。&lt;/li&gt;
&lt;li&gt;EDX: 数据寄存器，用于 I/O 操作和乘除法。&lt;/li&gt;
&lt;li&gt;ESI: 源索引寄存器，常用于指向内存数据源。&lt;/li&gt;
&lt;li&gt;EDI: 目标索引寄存器，常用于指向内存数据目标。&lt;/li&gt;
&lt;li&gt;EBP: 基址指针寄存器，用于栈帧基址指针。&lt;/li&gt;
&lt;li&gt;ESP: 栈指针寄存器，指向当前栈顶&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;strong&gt;Arithmetic Logic Unit (ALU)&lt;/strong&gt; executes an instruction fetched from RAM and places the results in registers or memory&lt;/p&gt;
&lt;p&gt;CPU runs a program by fetching and executing each instruction&lt;/p&gt;
&lt;h2 id=&#34;Programs in the main memory&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Programs in the main memory&#34;&gt; #&lt;/a&gt;  Programs in the main memory&lt;/h2&gt;
&lt;p&gt;Processes are programs loaded into memory, broken into small sections&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;.text section&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.data section&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.bss section&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Heap section&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stack section&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Environment/Arguments section&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/24/671a56f09cb3d.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;.text section&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Correspond to the .text portion of the binary executable file.&lt;/p&gt;
&lt;p&gt;Contain the machine instructions to get the task done&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;.data section&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Store global initialised variables such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int a = 0;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;.bss section&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Store global uninitialised variables such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int a;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Heap section&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Store dynamically allocated variables&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Contain the pre-existing value of that memory&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Grows from the lower-addressed memory to the higher-addressed memory&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int *I = malloc (sizeof (int));&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Stack section&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Keep track of function calls (recursively)&lt;/p&gt;
&lt;p&gt;Grow from the higher-addressed memory to the lower-addressed memory&lt;/p&gt;
&lt;p&gt;Local variables are in the stack section&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Environment/Arguments section&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Store a copy of system-level variables that may be required by the process&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For example, path, shell name, hostname, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Command-line arguments are stored in this area.&lt;/p&gt;
&lt;h2 id=&#34; Buffers&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;# Buffers&#34;&gt;#&lt;/a&gt; Buffers&lt;/h2&gt;
&lt;p&gt;A storage place used to receive and hold data until it can be handled by a process&lt;br&gt;
Each process can have its own set of buffers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E.g. memory allocated within the .data or .bss section of the process’s memory&lt;br&gt;
Buffer is of &lt;strong&gt;fixed length once allocated&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Hold any predefined type of data&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34; Pointers&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;# Pointers&#34;&gt;#&lt;/a&gt; Pointers&lt;/h2&gt;
&lt;p&gt;Pointers hold the address of other pieces of memory&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Their size is fixed of 4 bytes for 32-bit memory address&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C string can be written as a pointer to character:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;char * str;&lt;/li&gt;
&lt;li&gt;int * point1;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C#’s reference types implicitly use pointers&lt;br&gt;
Use dereference to read the value inside the memory address pointed to by the pointer:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;printf(&amp;quot;%d&amp;quot;, *point1);&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The  &lt;code&gt;*&lt;/code&gt;  symbol dereferences the pointer called point1 and displays the value of the integer using the  &lt;code&gt;printf()&lt;/code&gt;  function&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The type of  &lt;code&gt;point1&lt;/code&gt;  is a pointer&lt;/li&gt;
&lt;li&gt;The type of  &lt;code&gt;*point1&lt;/code&gt;  is an integer&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Putting the pieces of memory together&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; ind = &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;;                     &lt;span class=&#34;comment&#34;&gt;// integer stored in .data (initialized)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *str;                       &lt;span class=&#34;comment&#34;&gt;// string pointer stored in .bss (uninitialized)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; nothing;                     &lt;span class=&#34;comment&#34;&gt;// integer stored in .bss (uninitialized)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i = c;                                  &lt;span class=&#34;comment&#34;&gt;// stored in stack section&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	str = (&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt; * &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt;));    &lt;span class=&#34;comment&#34;&gt;// reserves 10 characters in heap region &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(str, &lt;span class=&#34;string&#34;&gt;&amp;quot;abcde&amp;quot;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;);                   &lt;span class=&#34;comment&#34;&gt;// copies &amp;quot;abcde&amp;quot; into str&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	fun(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
        <category term="C language" />
        <category term="Linux" />
        <category term="software security" />
        <updated>2024-10-24T11:00:05.000Z</updated>
    </entry>
</feed>
