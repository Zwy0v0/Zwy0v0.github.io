{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"gdb\" tag",
    "description": "🌸",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/course/x86-architecture-and-Assembly-basics/",
            "url": "http://example.com/course/x86-architecture-and-Assembly-basics/",
            "title": "x86 architecture and Assembly basics",
            "date_published": "2024-10-25T07:43:11.000Z",
            "content_html": "<h1 id=\" x86 architecture\" class=\"active\"><a class=\"anchor\"  href=\"# x86 architecture\">#</a> x86 architecture</h1>\n<h2 id=\"Levels of Abstraction\" class=\"active\"><a class=\"anchor\"  href=\"#Levels of Abstraction\">#</a> Levels of Abstraction</h2>\n<p>抽象层次（Levels of Abstraction） 是指在计算机系统设计中，将复杂的系统分解为不同的层次，以便于理解、设计和实现。每个抽象层都基于更底层的层次，同时也为更高层次提供基础。这种层次化的设计方式使得复杂系统的开发和维护更加高效。以下是这些抽象层次的具体解释：</p>\n<ol>\n<li>硬件层（Hardware Level）<br>\n解释：这是最底层的抽象层，主要是由各种电子电路和逻辑门（如 XOR、AND、OR、NOT 门等）组成。这些电路实现了最基本的逻辑运算和数据处理，是计算机所有功能的基础。<br>\n特点：这一层是最接近物理硬件的，直接处理电信号和物理开关状态。</li>\n<li>微码层（Microcode Level）/ 固件层（Firmware Level）<br>\n解释：微码（或固件）是一种嵌入在硬件中的特殊程序，用来解释机器指令并控制底层硬件的操作。它位于硬件和机器码之间。<br>\n特点：微码作为硬件与机器码的桥梁，是指令执行的控制逻辑，可以在不改变硬件的情况下更新或调整计算机的功能。</li>\n<li>机器码层（Machine Code Level）<br>\n解释：机器码是计算机直接执行的二进制代码，通常以操作码（opcodes）和十六进制数字形式表示。它由一系列低级指令组成，用于控制计算机的处理器执行任务。<br>\n特点：机器码是最底层的可编程语言，只有计算机可以直接执行，由处理器按照指令执行具体操作。</li>\n<li>低级语言层（Low-Level Languages Level）<br>\n解释：低级语言是机器码的人类可读版本，例如汇编语言（Assembly Language）。它使用助记符（如 MOV、ADD、JMP 等）来代表机器指令，更易于编程和调试。<br>\n特点：低级语言紧密对应计算机的硬件结构，编程者需要了解具体的计算机架构，适合编写操作系统、驱动程序和嵌入式系统。</li>\n<li>高级语言层（High-Level Languages Level）<br>\n解释：高级语言（如 C、C++、Java 等）提供了更抽象、更人性化的语法和结构，使得编程者可以更轻松地编写复杂的程序。这些语言中的代码通过编译器转换成机器码。<br>\n特点：高级语言通常具有良好的跨平台性和可移植性，编程效率高，适合开发应用程序和大型软件系统。</li>\n<li>解释型语言层（Interpreted Languages Level）<br>\n解释：解释型语言（如 Python、JavaScript）不是直接编译成机器码，而是先被翻译成字节码，然后在解释器中执行。<br>\n特点：解释型语言更灵活，适合快速开发和原型设计，但执行速度通常比编译型语言慢。</li>\n<li>字节码层（Bytecode Level）<br>\n解释：字节码是高级语言在被解释执行之前的中间形式。解释器将字节码翻译为机器可以执行的指令。<br>\n特点：字节码的设计通常与硬件无关，可以在不同的平台上被相同的解释器执行，例如 Java 和 Python 的虚拟机（JVM、Python Interpreter）都使用字节码。</li>\n</ol>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b4d8733f64.png\" alt=\"img\"></p>\n<h2 id=\"Assembly\" class=\"active\"><a class=\"anchor\"  href=\"#Assembly\">#</a> Assembly</h2>\n<ol>\n<li>汇编语言（Assembly Language） 是一种低级编程语言，它与计算机的机器码有着一一对应的关系，并且比机器码更易于人类理解和编写。以下是对汇编语言及相关概念的详细中文解释：</li>\n</ol>\n<ul>\n<li>汇编语言的定义<br>\n汇编语言是最接近机器码的高级语言，它可以将机器指令用人类可读的助记符（如 MOV、ADD、JMP 等）来表示。这使得程序员能够直接控制硬件，同时比直接编写二进制代码更加方便。</li>\n<li>与机器码的关系<br>\n汇编语言是最可靠的、可以从机器码中恢复的高级语言。如果高层语言的源代码不可用时，通过反汇编（disassembly），可以将机器码转换回对应的汇编代码。<br>\n汇编语言和机器码之间的对应关系使得程序员可以清楚地了解计算机底层的执行逻辑和流程。</li>\n<li>脆弱代码和恶意软件的存储形式<br>\n在内存或磁盘中，脆弱代码或恶意软件通常以二进制形式（即机器码）存储。这种形式是计算机直接执行的代码，但对人类而言不可读。</li>\n<li>反汇编器的作用<br>\n反汇编器是一种工具，它以二进制代码为输入，并将其翻译成相应的汇编代码输出。通过反汇编，可以将机器码还原为人类可读的汇编语言，有助于分析和调试程序，特别是在逆向工程或安全分析中。</li>\n<li>汇编语言是多种语言的集合<br>\n汇编语言实际上是多种语言的集合，因为不同的计算机架构（如 x86、ARM、MIPS 等）有各自独特的指令集和汇编语言格式。<br>\n在学习和使用汇编语言时，通常会针对特定的计算机架构进行深入研究。例如，x86 汇编和 ARM 汇编在指令集、寄存器使用和指令格式上都有明显的不同。</li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b4f21f3929.png\" alt=\"img\"><br>\n 整个过程从汇编语言（asm 文件）开始，通过汇编器生成目标文件，再通过链接器将目标文件和库文件结合生成可执行文件，最后将可执行文件加载到内存中运行</p>\n<ul>\n<li>汇编器（Assembler）<br>\n汇编器的作用是将汇编语言的代码（asm 文件）翻译成目标文件（object file）。目标文件是二进制形式的文件，包含了机器可以理解的指令和数据，但还不是完整的可执行程序。</li>\n<li>链接器（Linker）<br>\n链接器的作用是将多个目标文件和库文件（如静态库或动态库）组合起来，生成一个完整的可执行文件（Executable）。<br>\n静态库（Static Library）：静态库中的代码在编译期间直接被链接到可执行文件中。<br>\n动态库（Dynamic Library）：动态库中的代码在运行时被加载到内存中。</li>\n</ul>\n<ol start=\"2\">\n<li>Assembler vs. Compiler</li>\n</ol>\n<ul>\n<li>编译器 (Compiler) vs. 汇编器 (Assembler)<br>\n 编译器：将高级编程语言的代码（如 C、C++、Java 等）转换为机器级代码。<br>\n汇编器：将汇编语言的代码转换为机器级代码。</li>\n<li>输入<br>\n编译器：以高级语言的源代码为输入。<br>\n汇编器：以汇编语言的代码为输入。</li>\n<li>转换方式<br>\n编译器：会检查并一次性将整个代码转换为机器代码。<br>\n汇编器：一般不一次性转换完整代码，而是分两步处理。</li>\n<li>内部模块<br>\n编译器：包含词法分析器、语法分析器、语义分析器、代码优化器和代码生成器等模块。(lexical analyzer, Syntax analyzer, Semantic analyzer, Code optimizer, Code generator)<br>\n 汇编器：在两次扫描中完成所有工作。</li>\n<li>输出结果<br>\n编译器：输出的是机器代码的助记符 (Mnemonic) 版本。<br>\n汇编器：输出的是机器代码的二进制版本。</li>\n<li>常见类型<br>\n编译器：如 C、C++、Java 的编译器。<br>\n汇编器：如 GAS（GNU Assembler）、GNU 汇编器</li>\n</ul>\n<ol start=\"3\">\n<li>Two main forms of assembly syntax</li>\n</ol>\n<ul>\n<li>NASM format: <instr> <dest>, <source> &lt;; comment&gt; : mov eax, 10</li>\n<li>AT&amp;T format:  <instr> <source>, <dest> &lt;# comment&gt;: mov $10, %eax<br>\nAT&amp;T format reverses the order of operands, uses a % before registers and a $ before literal values</li>\n</ul>\n<ol start=\"4\">\n<li>Fundamental Data Types</li>\n</ol>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b528c52025.png\" alt=\"img\"></p>\n<ul>\n<li>\n<p>Byte（字节）<br>\n大小：1 字节 = 8 位（bit）。<br>\n示例：图中展示的 5D 是一个 8 位的二进制数（01011101），它可以用一个字节来表示。<br>\n解释：一个字节的二进制位可以表示 0 到 255 之间的整数（无符号），或 -128 到 127 之间的整数（有符号）。</p>\n</li>\n<li>\n<p>Word（字）<br>\n大小：2 字节 = 16 位（bit）。<br>\n示例：图中展示的 8BEC 表示一个 16 位的二进制数，其中：<br>\n高字节（High Byte）：8B<br>\n 低字节（Low Byte）：EC<br>\n 解释：一个 Word 可以表示 0 到 65535 之间的无符号整数，或 -32768 到 32767 之间的有符号整数。</p>\n</li>\n<li>\n<p>Dword（双字）<br>\n大小：4 字节 = 32 位（bit）。<br>\n示例：图中展示的 000136CF 表示一个 32 位的二进制数，其中：<br>\n高字（High Word）：0001<br>\n 低字（Low Word）：36CF<br>\n 解释：一个 Dword 可以表示更大的整数范围，用于存储更大的数值或内存地址。</p>\n</li>\n<li>\n<p>Qword（四字）<br>\n大小：8 字节 = 64 位（bit）。<br>\n示例：图中展示的 CF000136CF 表示一个 64 位的二进制数，其中：<br>\n高双字（High Dword）：CF00<br>\n 低双字（Low Dword）：0136CF<br>\n 解释：一个 Qword 可以表示更大的整数或浮点数范围，常用于 64 位处理器上的运算。</p>\n</li>\n<li>\n<p>Data in Memory<br>\nLittle-endian format: a low-order byte is stored at the lower address<br>\n<img data-src=\"https://img.picui.cn/free/2024/10/25/671b538e3e57f.png\" alt=\"img\"></p>\n</li>\n</ul>\n<h2 id=\"CPU Registers\" class=\"active\"><a class=\"anchor\"  href=\"#CPU Registers\">#</a>CPU Registers</h2>\n<ol>\n<li>CPU 寄存器是 CPU 内部的一小部分数据存储单元，用于暂存指令、数据和状态信息。寄存器是 CPU 中速度最快的存储单元，比其他存储设备（如 RAM、硬盘）快得多，因为它们位于 CPU 内部，能够快速读写数据。<br>\nCPU 寄存器的类型</li>\n</ol>\n<ul>\n<li>通用寄存器（General Registers）<br>\n用途：在程序执行期间由 CPU 使用，用于存储数据、操作数和临时结果。<br>\n功能：可以用于整数运算、地址运算和数据的传输，是最常用的寄存器类型。</li>\n<li>段寄存器（Segment Registers）<br>\n用途：用于管理和跟踪内存的不同段（如代码段、数据段和栈段）。<br>\n功能：帮助 CPU 确定内存访问的具体区域，使得内存分段管理更加高效。</li>\n<li>状态标志（Status Flags）<br>\n用途：存储程序执行的状态信息，例如运算结果是正、负、零，或是否发生溢出等。<br>\n功能：在 CPU 进行条件判断或决策时提供必要的信息支持，决定程序的执行路径。</li>\n<li>指令指针（Instruction Pointers）<br>\n用途：用于跟踪下一条将要执行的指令的地址。<br>\n功能：确保程序的指令按顺序执行，是控制程序流程的关键寄存器。</li>\n</ul>\n<ol start=\"2\">\n<li>x86 Registers\n<ol>\n<li>数据寄存器（Data Registers）\n<ul>\n<li>EAX（累加器）：主要用于输入 / 输出和大多数算术运算。例如，加法、减法、乘法和除法操作时，通常会用到 EAX。</li>\n<li>EBX（基址寄存器）：可用于索引寻址模式，即在访问数组或结构中的元素时，EBX 可以作为基址寄存器使用。</li>\n<li>ECX（计数寄存器）：在循环操作中存储循环计数，通常用于实现迭代操作。</li>\n<li>EDX（数据寄存器）：也用于输入 / 输出操作，有时与 AX 一起使用，例如在某些乘法和除法运算中。</li>\n</ul>\n</li>\n<li>索引寄存器（Index Registers）\n<ul>\n<li>ESI（源索引）：用于字符串操作的源索引，通常在数据的读取操作中使用。</li>\n<li>EDI（目标索引）：用于字符串操作的目标索引，通常在数据的写入操作中使用。</li>\n</ul>\n</li>\n<li>段寄存器（Segment Registers）\n<ul>\n<li>CS（代码段寄存器）：指向包含所有将要执行的指令的代码段。</li>\n<li>DS（数据段寄存器）：指向包含全局数据、常量和工作区的数据段。</li>\n<li>SS（栈段寄存器）：指向包含局部数据和过程或子程序返回地址的栈段。</li>\n<li>其他段寄存器（ES、FS、GS）：提供额外的数据存储段，用于存放其他类型的数据。<br>\n在段内的所有内存位置都相对于段的起始地址。</li>\n</ul>\n</li>\n<li>状态寄存器（Status Register）\n<ul>\n<li>EFLAGS 寄存器：用于存储处理器的状态标志，每个标志位表示不同的状态或条件：</li>\n<li>ZF（零标志）：当运算结果为零时设置。</li>\n<li>CF（进位标志）：当运算结果过大或过小时设置。</li>\n<li>SF（符号标志）：当运算结果为负时设置。</li>\n<li>TF（陷阱标志）：用于调试，设置该标志时，处理器一次只执行一条指令。通常被调试工具（如 GDB）使用。</li>\n</ul>\n</li>\n<li>指令指针（Instruction Pointer, EIP）也称为程序计数器，它包含下一条将被执行的指令的偏移地址。\n<ul>\n<li>EIP 的唯一目的是告诉处理器下一步要执行什么指令。</li>\n<li>当前指令的完整地址为 CS:EIP（代码段寄存器加指令指针）。</li>\n<li>如果攻击者能够控制 EIP，他们就能控制 CPU 的执行流程，因此 EIP 是常见攻击（如缓冲区溢出）的目标。</li>\n</ul>\n</li>\n<li>其他指针寄存器（Other Pointer Registers）\n<ul>\n<li>ESP（栈指针寄存器）：提供程序栈中的偏移值，SS:ESP 表示栈顶（当前数据或地址在程序栈中的位置）。</li>\n<li>EBP（基址指针寄存器）：主要用于引用传递给子程序的参数变量（如函数调用）。SS:EBP 表示当前调用的栈帧 (stack frame)。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"Assembly basics\" class=\"active\"><a class=\"anchor\"  href=\"#Assembly basics\">#</a> Assembly basics</h1>\n<h2 id=\"Simple Instructions\" class=\"active\"><a class=\"anchor\"  href=\"#Simple Instructions\">#</a>Simple Instructions</h2>\n<ol>\n<li>mov instruction</li>\n</ol>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b589f37dc7.png\" alt=\"img\"></p>\n<p>lea (load effective address) instruction puts a memory address into the<br>\ndestination</p>\n<ul>\n<li>e.g. lea eax, [ebx+8] puts EBX+8 into EAX</li>\n<li>e.g. mov eax, [ebx+8] loads the data at the memory address EBX+8</li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b595145504.png\" alt=\"img\"></p>\n<ul>\n<li>mov eax, [ebx+8] places the value 0x20 into EAX</li>\n<li>lea eax, [ebx+8] places the value 0xB30048 into EAX</li>\n</ul>\n<ol start=\"2\">\n<li>Arithmetic</li>\n</ol>\n<ul>\n<li>sub eax, 0x10<br>\n 描述：从寄存器 EAX 中减去 0x10（十六进制的 16）。<br>\n结果：EAX 的值减少 16。</li>\n<li>add eax, ebx<br>\n 描述：将寄存器 EBX 的值加到 EAX 中，并将结果存储在 EAX 中。<br>\n结果：EAX = EAX + EBX。</li>\n<li>inc edx<br>\n 描述：将寄存器 EDX 的值加 1。<br>\n结果：EDX 的值增加 1。</li>\n<li>dec ecx<br>\n 描述：将寄存器 ECX 的值减 1。<br>\n结果：ECX 的值减少 1。</li>\n<li>mul 0x50<br>\n 描述：将寄存器 EAX 的值乘以 0x50（十六进制的 80），并将结果存储在 EDX<br>\n 中。<br>\n结果：EAX 中存储低 32 位的乘积，EDX 中存储高 32 位的乘积。</li>\n<li>div 0x75<br>\n 描述：用寄存器 EDX<br>\n（将 EDX 和 EAX 结合起来，表示 64 位的数值）除以 0x75（十六进制的 117）。<br>\n结果：商存储在 EAX 中，余数存储在 EDX 中。</li>\n</ul>\n<ol start=\"3\">\n<li>Logics</li>\n</ol>\n<ul>\n<li>xor eax, eax<br>\n 描述：将寄存器 EAX 和自身进行异或操作，清除 EAX 中的值（即将 EAX 置为 0）。<br>\n结果：EAX = 0。</li>\n<li>or eax, 0x7575<br>\n 描述：对 EAX 寄存器和 0x7575 进行逻辑或（OR）操作。<br>\n结果：EAX 的每个位都与 0x7575 的相应位进行或操作。</li>\n<li>mov eax, 0xA 和 shl eax, 2<br>\nmov eax, 0xA：将 EAX 设置为 0xA（十六进制的 10）。<br>\nshl eax, 2：将 EAX 寄存器中的值左移 2 位。<br>\n结果：EAX 的值变为 0x28（十六进制的 40），因为二进制的 1010 左移 2 位变为 101000。</li>\n<li>mov bl, 0xA 和 ror bl, 2<br>\nmov bl, 0xA：将 BL 设置为 0xA（十六进制的 10）。<br>\nror bl, 2：将 BL 寄存器中的值右旋 2 位。<br>\n结果：BL 的值变为 10000010，因为二进制的 1010 右旋 2 位变为 10000010。</li>\n</ul>\n<ol start=\"4\">\n<li>nop<br>\n 描述：NOP 指令不执行任何操作，仅仅让处理器继续执行下一条指令。<br>\n作用：NOP 实际上是 xchg eax, eax 的伪指令，因为将 EAX 与自身交换不会改变任何值。<br>\n用途：在缓冲区溢出攻击中，攻击者常使用 NOP 指令来填充攻击代码，使得执行具有一定的缓冲空间。NOP 的操作码是 0x90。</li>\n</ol>\n<h2 id=\"The Stack\" class=\"active\"><a class=\"anchor\"  href=\"#The Stack\">#</a>The Stack</h2>\n<ol>\n<li>栈的基本概念<br>\n栈 是一种 后进先出（LIFO） 的数据结构，这意味着最后放入的数据将是第一个被取出的。<br>\n栈通常用于存储函数调用的参数、局部变量、返回地址和一些控制信息。<br>\n栈的主要寄存器包括：<br>\nESP（栈指针）：指向当前栈顶。<br>\nEBP（基址指针）：跟踪局部变量和函数参数的位置。</li>\n<li>栈指令<br>\n栈操作包括以下几种常见指令：</li>\n</ol>\n<ul>\n<li>push：将数据压入栈中，ESP 会减少（栈向下增长）。</li>\n<li>pop：从栈中弹出数据，ESP 会增加。</li>\n<li>call：调用函数，将当前指令的地址压入栈中，并跳转到指定函数的位置。</li>\n<li>leave：用于函数返回时，将栈恢复到调用者的状态。</li>\n<li>enter：为新函数栈帧分配空间，保存当前的 EBP，并更新 EBP 为新栈帧的起始位置。</li>\n<li>ret：函数返回，将栈顶的返回地址弹出到 EIP 中，恢复程序的执行。</li>\n</ul>\n<ol start=\"3\">\n<li>函数调用的栈操作<br>\n在函数调用过程中，栈的使用通常按照以下步骤进行：</li>\n</ol>\n<ul>\n<li>参数入栈：使用 push 指令将函数的参数依次压入栈中。</li>\n<li>调用函数：使用  <code>call &lt;location&gt;</code>  指令调用函数。当前指令地址（EIP）会被压入栈中，便于函数执行完毕后返回。EIP 将被设置为函数的起始地址（ <code>&lt;location&gt;</code> ）。</li>\n<li>保存局部变量和 EBP：函数调用后，局部变量和调用者的 EBP 被压入栈中，用于为新函数栈帧分配空间。</li>\n<li>执行函数：函数内部执行具体的任务，包括访问局部变量、处理逻辑和修改数据。</li>\n<li>恢复局部变量和调用者的 EBP：使用 leave 指令，将 EBP 和局部变量恢复为调用者的状态。</li>\n<li>恢复 EIP：使用 ret 指令，将栈顶的返回地址弹出到 EIP 中，以继续执行调用函数的程序。</li>\n<li>清理参数：参数在函数返回后可能需要被清理，从而恢复栈的平衡状态。</li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/25/671b64bb0713f.png\" alt=\"img\"></p>\n<h2 id=\"Conditionals and Branching\" class=\"active\"><a class=\"anchor\"  href=\"#Conditionals and Branching\">#</a>Conditionals and Branching</h2>\n<ol>\n<li>条件指令（Conditionals）\n<ol>\n<li>test 指令</li>\n</ol>\n<ul>\n<li>功能：test 指令类似于逻辑与（AND）操作，但不会修改操作数，只用于设置标志位。</li>\n<li>标志位：主要设置 ZF（零标志）。如果操作数之间的逻辑与结果为零，则 ZF 被置 1，否则置 0。</li>\n<li>用法：通常用于检查某个位是否被设置，例如判断一个变量是否为零或检测特定位是否为 1。</li>\n</ul>\n<ol start=\"2\">\n<li>cmp 指令</li>\n</ol>\n<ul>\n<li>功能：cmp 指令类似于减法（SUB）操作，但不会改变操作数的值，只用于设置标志位。</li>\n<li>标志位：主要设置 ZF（零标志） 和 CF（进位标志）。</li>\n<li>ZF（零标志）：当两个操作数相等时，ZF 被置 1。</li>\n<li>CF（进位标志）：当目标操作数小于源操作数时，CF 被置 1。</li>\n<li>用法：通常用于比较两个数值大小，以决定下一步的条件跳转。</li>\n</ul>\n<ol start=\"3\">\n<li>cmp 指令的标志位结果<br>\n cmp dst, src 的不同结果下的标志位变化：</li>\n</ol>\n<ul>\n<li>dst = src：ZF = 1, CF = 0（目标操作数等于源操作数）。</li>\n<li>dst &lt; src：ZF = 0, CF = 1（目标操作数小于源操作数）。</li>\n<li>dst &gt; src：ZF = 0, CF = 0（目标操作数大于源操作数）。</li>\n</ul>\n</li>\n<li>分支指令（Branching）<br>\n分支是根据程序的控制流有条件地执行代码序列。分支指令决定程序在特定条件下的跳转。\n<ol>\n<li>无条件跳转（Unconditional Jump）</li>\n</ol>\n<ul>\n<li>jmp <location>：无条件跳转指令会直接跳转到指定的位置（<location>），无论条件是否满足。</li>\n<li>用法：无条件跳转用于改变程序的执行顺序，是一种不依赖标志位的跳转形式。</li>\n</ul>\n<ol start=\"2\">\n<li>条件跳转（Conditional Jump）</li>\n</ol>\n<ul>\n<li>条件跳转指令：使用标志寄存器的值来决定是否进行跳转。常见的条件跳转指令有超过 30 种。</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "software security",
                "Linux",
                "C language",
                "gdb"
            ]
        }
    ]
}