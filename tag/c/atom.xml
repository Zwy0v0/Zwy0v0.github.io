<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title> • Posts by &#34;c&#34; tag</title>
    <link href="http://example.com" />
    <updated>2024-10-28T11:57:22.000Z</updated>
    <category term="C language" />
    <category term="Linux" />
    <category term="software security" />
    <category term="C" />
    <category term="vulnerability" />
    <category term="AFL" />
    <category term="SQL" />
    <category term="HTTP" />
    <category term="OSI" />
    <category term="gdb" />
    <category term="JavaScript" />
    <category term="Blog" />
    <category term="日常" />
    <entry>
        <id>http://example.com/course/Heap-buffer-overflow/</id>
        <title>Heap buffer overflow</title>
        <link rel="alternate" href="http://example.com/course/Heap-buffer-overflow/"/>
        <content type="html">&lt;h1 id=&#34;Heap allocation&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Heap allocation&#34;&gt;#&lt;/a&gt;Heap allocation&lt;/h1&gt;
&lt;h2 id=&#34;Memory Allocation&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Memory Allocation&#34;&gt;#&lt;/a&gt;Memory Allocation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Static memory&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Store global variables, permanent for the entire lifetime of the process&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Automatic memory&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Stack stores local variables, stackframes are added or removed for functional calls&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Dynamic memory&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Heap stores shared data structures in a large pool of memory&lt;/li&gt;
&lt;li&gt;Not allocated in contiguous order 由程序员管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Stack Allocation&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Stack Allocation&#34;&gt;#&lt;/a&gt;Stack Allocation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Stack is contiguous blocks of memory managed by OS&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Cannot be modified&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Stack grows and shrinks as functions are called and exited&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Usually has an upper bound, may raise exceptions&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Variables are allocated and freed automatically&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Only exist when the function that created them is active on the stack&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Heap Allocation&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Heap Allocation&#34;&gt;#&lt;/a&gt;Heap Allocation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Heap is noncontiguous blocks of memory managed by the programmer&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Can be modified programatically&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Heap is large and boundless, usually limited by only the physical memory available&lt;/li&gt;
&lt;li&gt;Variables are allocated and freed by using library functions or build-in language constructs&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;C calls standard library functions, e.g. malloc, realloc, calloc and free&lt;/li&gt;
&lt;li&gt;C++ also uses these functions, but adds build-in operators new and delete&lt;/li&gt;
&lt;li&gt;Pointers are required to access data on the heap&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Memory Allocation Example&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; x;  &lt;span class=&#34;comment&#34;&gt;// 静态变量，存储在静态内存区，生命周期与进程相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; y;          &lt;span class=&#34;comment&#34;&gt;// 栈变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *str;      &lt;span class=&#34;comment&#34;&gt;// 指向堆内存的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     y = &lt;span class=&#34;number&#34;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;stack memory: %d\n&amp;quot;&lt;/span&gt;, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;// 分配 100 个字符的堆内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     str = &lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;100&lt;/span&gt; * &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     str[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;] = &lt;span class=&#34;string&#34;&gt;&amp;#x27;m&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;heap memory: %c\n&amp;quot;&lt;/span&gt;, str[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;// 释放分配的堆内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;// 栈上的局部变量 y 和 str 会在这里被自动释放&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/28/671f7e7bed371.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Stack&lt;/th&gt;
&lt;th&gt;Heap&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Basic&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Memory is allocated in a contiguous block&lt;/td&gt;
&lt;td&gt;Memory is allocated in any random order&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Allocation and Deallocation&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Automatic by compiler instructions&lt;/td&gt;
&lt;td&gt;Manual by programmer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Cost&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Less&lt;/td&gt;
&lt;td&gt;More&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Implementation&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Hard&lt;/td&gt;
&lt;td&gt;Easy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Access time&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Faster&lt;/td&gt;
&lt;td&gt;Slower&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Main Issue&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Shortage of memory&lt;/td&gt;
&lt;td&gt;Memory fragmentation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Locality of reference&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Excellent&lt;/td&gt;
&lt;td&gt;Adequate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Flexibility&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Fixed size&lt;/td&gt;
&lt;td&gt;Resizing is possible&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Data type structure&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Linear&lt;/td&gt;
&lt;td&gt;Hierarchical&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;Heap buffer overflow&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Heap buffer overflow&#34;&gt;#&lt;/a&gt;Heap buffer overflow&lt;/h1&gt;
&lt;h2 id=&#34;Dereference&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Dereference&#34;&gt;#&lt;/a&gt;Dereference&lt;/h2&gt;
&lt;p&gt;Much harder to exploit heap overflows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heap memory is not flat or contiguous&lt;/li&gt;
&lt;li&gt;There is no return address saved on the heap&lt;/li&gt;
&lt;li&gt;The address to overwrite is hard to find&lt;/li&gt;
&lt;li&gt;General exploitation techniques manipulate the metadata used by memory allocator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To read/write the value inside the memory address pointed to by the pointer&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Dereference a Pointer&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; x; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *p; &lt;span class=&#34;comment&#34;&gt;// p 是一个指向整数的指针  *p is an integer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; x = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;// x 现在等于 0 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; p = &amp;amp;x; &lt;span class=&#34;comment&#34;&gt;// p 指向 x 的地址   now *p == 0, since *p == x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; *p = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 相当于 x = 1，因为 p == &amp;amp;x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	     &lt;span class=&#34;comment&#34;&gt;// 现在 *p 和 x 都等于 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;A C-language structure is a basic data structure that holds multiple fields&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Dereference a Structure Pointer&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;MY_STRUCT&lt;/span&gt; &amp;#123;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; my_int; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;float&lt;/span&gt; my_float; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; MY_STRUCT_T; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; MY_STRUCT_T info = &amp;#123;&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3.141593F&lt;/span&gt;&amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; MY_STRUCT_T *instance = &amp;amp;info; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a = info.my_int;        &lt;span class=&#34;comment&#34;&gt;// 使用 &amp;#x27;.&amp;#x27; 操作符选择字段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; b = (*instance).my_int; &lt;span class=&#34;comment&#34;&gt;// 解引用后选择字段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; c = instance-&amp;gt;my_int;   &lt;span class=&#34;comment&#34;&gt;// &amp;#x27;-&amp;gt;&amp;#x27; 是前一种情况的语法糖&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;访问结构体字段的三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;info.my_int&lt;/code&gt; ：使用  &lt;code&gt;.&lt;/code&gt;  操作符直接访问结构体变量  &lt;code&gt;info&lt;/code&gt;  中的字段  &lt;code&gt;my_int&lt;/code&gt; 。这是最简单的访问方式，因为  &lt;code&gt;info&lt;/code&gt;  是结构体变量，不是指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*instance&lt;/code&gt; ：解引用指针  &lt;code&gt;instance&lt;/code&gt; ，获取它指向的结构体  &lt;code&gt;info&lt;/code&gt; 。 &lt;code&gt;(*instance)&lt;/code&gt;  代表结构体本身。&lt;br&gt;
 &lt;code&gt;(*instance).my_int&lt;/code&gt; ：在解引用后使用 &lt;code&gt;.&lt;/code&gt;  操作符访问结构体字段  &lt;code&gt;my_int&lt;/code&gt; 。这种方式相当于对 info 变量的直接访问，只不过是通过指针来完成的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance-&amp;gt;my_int&lt;/code&gt; ： &lt;code&gt;-&amp;gt;&lt;/code&gt;  是一种简便写法（语法糖），用于访问指针指向的结构体的字段。这相当于  &lt;code&gt;(*instance).my_int&lt;/code&gt; ，但写法更加简洁。 &lt;code&gt;-&amp;gt;&lt;/code&gt;  只能用于指针，而  &lt;code&gt;.&lt;/code&gt;  用于直接的结构体变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Heap Overflow&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Heap Overflow&#34;&gt;#&lt;/a&gt;Heap Overflow&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Simple Heap Overflow&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Simple Heap Overflow&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;target&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;];        &lt;span class=&#34;comment&#34;&gt;// 易受攻击的缓冲区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; (*fun)(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *);  &lt;span class=&#34;comment&#34;&gt;// 函数指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;span class=&#34;type&#34;&gt;target_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *buf)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;comment&#34;&gt;// 目标函数，可能被攻击者控制的数据替换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;target_t&lt;/span&gt; *rec = &lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;target_t&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// 动态分配结构体内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     rec-&amp;gt;fun = foo; &lt;span class=&#34;comment&#34;&gt;// 将函数指针初始化为 foo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     gets(rec-&amp;gt;buf); &lt;span class=&#34;comment&#34;&gt;// 易受攻击的函数，可能导致缓冲区溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     rec-&amp;gt;fun(&lt;span class=&#34;string&#34;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 调用函数指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;结构体定义&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;target&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;];        &lt;span class=&#34;comment&#34;&gt;// 缓冲区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; (*fun)(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *);  &lt;span class=&#34;comment&#34;&gt;// 函数指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;span class=&#34;type&#34;&gt;target_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结构体  &lt;code&gt;target&lt;/code&gt;  包含两个字段：&lt;br&gt;
 &lt;code&gt;buf&lt;/code&gt; ：一个大小为 100 字节的字符数组，是易受攻击的缓冲区。&lt;br&gt;
 &lt;code&gt;fun&lt;/code&gt; ：一个函数指针，指向接受一个字符指针参数的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓冲区溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;gets(rec-&amp;gt;buf);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;gets()&lt;/code&gt;  是一个危险的函数，它从标准输入读取数据并存储到指定的缓冲区  &lt;code&gt;buf&lt;/code&gt;  中。&lt;br&gt;
 &lt;code&gt;gets()&lt;/code&gt;  不会检查输入数据的长度，如果输入超过了  &lt;code&gt;buf&lt;/code&gt;  的 100 字节大小限制，就会导致缓冲区溢出。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用堆溢出&lt;br&gt;
当攻击者提供的输入长度超过 100 字节时，超出的数据将会覆盖  &lt;code&gt;fun&lt;/code&gt;  函数指针。&lt;br&gt;
攻击者可以利用这种情况，将  &lt;code&gt;fun&lt;/code&gt;  指针重写为攻击者控制的地址，从而在程序中执行任意代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Difficult to Overwrite Non-Contiguous Memory&lt;br&gt;
Heap buffers are not adjacent, there may some extra space&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;It may be possible to calculate the extra space to craft an exploit&lt;/li&gt;
&lt;li&gt;But the exploit will be application-specific!
&lt;ol&gt;
&lt;li&gt;堆内存的分散性
&lt;ul&gt;
&lt;li&gt;堆上的缓冲区并不总是相邻的，因为它们根据内存分配器的策略进行分配。&lt;/li&gt;
&lt;li&gt;不同分配之间可能存在空隙（padding）或元数据（metadata），使得直接覆盖非连续内存变得困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存分配器的元数据
&lt;ul&gt;
&lt;li&gt;堆内存中分配的每个块通常带有元数据（如大小、状态、指向下一个块的指针等），用于管理内存块的分配和释放。&lt;/li&gt;
&lt;li&gt;攻击者在试图覆盖非连续内存时，还需要考虑这些元数据的存在，否则可能导致分配器崩溃或异常，暴露攻击的痕迹。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Heap Allocator&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Heap Allocator&#34;&gt;#&lt;/a&gt;Heap Allocator&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;How heap memory is allocated?&lt;br&gt;
Heap allocator maintains a &lt;strong&gt;doubly-linked list&lt;/strong&gt; of allocated and free chunks (blocks of memory)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;malloc()&lt;/code&gt;  and  &lt;code&gt;free()&lt;/code&gt;  add or remove chunks from this list&lt;br&gt;
Chunk management information is stored together with user data in memory&lt;/li&gt;
&lt;li&gt;Writing data past the end of a chunk boundary may overwrite the management fields&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Chunk Record&lt;br&gt;
Heap blocks are C records (i.e. struct) that have a few fields along with the chunk of memory
&lt;ul&gt;
&lt;li&gt;fd: the pointer to the next block&lt;/li&gt;
&lt;li&gt;bk: the pointer to the previous block&lt;/li&gt;
&lt;li&gt;ps: the size of the previous chunk&lt;/li&gt;
&lt;li&gt;sz: the size of the current chunk&lt;/li&gt;
&lt;li&gt;Other fields such as free flag to indicate if the current chunk is in the freelis&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unlink a Chunk&lt;br&gt;
 &lt;code&gt;free()&lt;/code&gt;  removes a chunk from allocated list&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/28/671f8d584507c.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unlink performs the following two writes on the list’s fields:
&lt;ul&gt;
&lt;li&gt;chunk2‐&amp;gt;bk‐&amp;gt;fd = chunk2‐&amp;gt;fd&lt;/li&gt;
&lt;li&gt;chunk2‐&amp;gt;fd‐&amp;gt;bk = chunk2‐&amp;gt;bk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;By overflowing  &lt;code&gt;chunk2&lt;/code&gt; , attacker can take control of  &lt;code&gt;chunk2‐&amp;gt;fd&lt;/code&gt;  and  &lt;code&gt;chunk2‐&amp;gt;bk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Suppose the attacker wants to write  &lt;code&gt;value&lt;/code&gt;  to memory address  &lt;code&gt;addr&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Attacker sets  &lt;code&gt;chunk2‐&amp;gt;fd&lt;/code&gt;  to be  &lt;code&gt;value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Attacker sets  &lt;code&gt;chunk2‐&amp;gt;bk&lt;/code&gt;  to be  &lt;code&gt;(addr - offset_fd)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;offset_fd&lt;/code&gt;  is the offset of the fd field in the record&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The attacker can write arbitrary value to arbitrary memory address in this way&lt;/li&gt;
&lt;li&gt;The first unlink write achieves the attacker’s goal:  &lt;code&gt;chunk2‐&amp;gt;bk‐&amp;gt;fd = chunk2‐&amp;gt;fd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The first write effectively becomes:  &lt;code&gt;(addr - offset_fb)‐&amp;gt;fd = value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;This is the same as  &lt;code&gt;*addr = value&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Fields are selected by offsets&lt;/li&gt;
&lt;li&gt;&lt;code&gt;offset_fd&lt;/code&gt;  cancels out  &lt;code&gt;fd&lt;/code&gt; &lt;br&gt;
Attackers can use hundreds of writes to copy the shellcode into memory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Prevention&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Prevention&#34;&gt;#&lt;/a&gt;Prevention&lt;/h2&gt;
&lt;p&gt;Very hard to detect and prevent due to the dynamic nature of the heap&lt;br&gt;
Possible ways to protect against heap overflow&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prevent execution of the payload by separating the code and data&lt;/li&gt;
&lt;li&gt;Introduce randomisation so the heap is not found at a fixed offset&lt;/li&gt;
&lt;li&gt;Introduce sanity checks into the heap allocator&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Pointer-related heap errors &#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Pointer-related heap errors &#34;&gt;#&lt;/a&gt;Pointer-related heap errors &lt;/h1&gt;
&lt;h2 id=&#34;Use After Free&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Use After Free&#34;&gt;#&lt;/a&gt;Use After Free&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;A memory is accessed after it is freed (and re-allocated)
&lt;ul&gt;
&lt;li&gt;Can cause a program to crash, use unexpected values, or execute code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Attackers may overwrite the re-allocated memory including metadata
&lt;ul&gt;
&lt;li&gt;May result in the same effect as some heap overflow vulnerabilities&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Use After Free Example&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *buf1, *buf2; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    buf1 = (&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(BUFSIZE1); &lt;span class=&#34;comment&#34;&gt;// 为 buf1 分配 BUFSIZE1 大小的内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 释放 buf1，使其分配的内存可被重用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;(buf1); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 可能在 buf1 释放的内存区域内分配 buf2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    buf2 = (&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(BUFSIZE2); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 攻击者可能会通过覆盖 buf2 及其元数据来利用漏洞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(buf1, argv[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;], BUFSIZE1&lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Example Problems
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;free(buf1)&lt;/code&gt;  的影响
&lt;ul&gt;
&lt;li&gt;当  &lt;code&gt;buf1&lt;/code&gt;  被释放后，其对应的内存区域变得可供再次分配。&lt;/li&gt;
&lt;li&gt;因为  &lt;code&gt;free()&lt;/code&gt;  并不会立即将内存清零或使指针失效，所以  &lt;code&gt;buf1&lt;/code&gt;  仍然指向被释放的内存区域。&lt;/li&gt;
&lt;li&gt;在这段代码中， &lt;code&gt;buf2&lt;/code&gt;  可能会被分配到  &lt;code&gt;buf1&lt;/code&gt;  释放的内存区域（这取决于堆分配器的实现和内存布局）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strncpy(buf1, argv[1], BUFSIZE1-1)&lt;/code&gt;  的问题
&lt;ul&gt;
&lt;li&gt;即使  &lt;code&gt;buf1&lt;/code&gt;  已被释放，程序仍然在此处试图使用  &lt;code&gt;buf1&lt;/code&gt;  进行写操作。&lt;/li&gt;
&lt;li&gt;由于  &lt;code&gt;buf1&lt;/code&gt;  被释放后可能被  &lt;code&gt;buf2&lt;/code&gt;  重新使用， &lt;code&gt;buf1&lt;/code&gt;  和  &lt;code&gt;buf2&lt;/code&gt;  可能指向相同的内存区域。这意味着通过  &lt;code&gt;strncpy()&lt;/code&gt;  对  &lt;code&gt;buf1&lt;/code&gt;  的写入可能会影响  &lt;code&gt;buf2&lt;/code&gt; ，甚至覆盖  &lt;code&gt;buf2&lt;/code&gt;  的元数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Double Free&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Double Free&#34;&gt;#&lt;/a&gt;Double Free&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;A memory address is freed (i.e.  &lt;code&gt;free()&lt;/code&gt; ) twice
&lt;ul&gt;
&lt;li&gt;Can also cause a program to crash, use unexpected values, or execute code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Attackers may corrupt metadata of new memory allocated at the address
&lt;ul&gt;
&lt;li&gt;May also result in the same effect as some heap overflow vulnerabilities&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Double Free Example&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *buf1, *buf2; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    buf1 = (&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(BUFSIZE1);  &lt;span class=&#34;comment&#34;&gt;// 为 buf1 分配 BUFSIZE1 大小的内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;(buf1);  &lt;span class=&#34;comment&#34;&gt;// 释放 buf1，内存可供重用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// buf2 可能被分配到 buf1 释放的内存区域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    buf2 = (&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(BUFSIZE2);  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// buf2 可能包含攻击者提供的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(buf2, argv[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;], BUFSIZE2&lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// buf1 被再次释放（双重释放）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;(buf1); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 释放 buf2（使用了可能被攻击者修改的元数据）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;(buf2);  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Example Problems
&lt;ol&gt;
&lt;li&gt;第一次释放  &lt;code&gt;buf1&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;通过  &lt;code&gt;free(buf1)&lt;/code&gt; ， &lt;code&gt;buf1&lt;/code&gt;  所占用的内存被释放，成为可供重用的内存区域。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf2&lt;/code&gt;  可能分配到  &lt;code&gt;buf1&lt;/code&gt;  的内存区域&lt;/li&gt;
&lt;li&gt;因为  &lt;code&gt;buf1&lt;/code&gt;  已被释放，内存分配器可能会将  &lt;code&gt;buf2&lt;/code&gt;  分配到之前  &lt;code&gt;buf1&lt;/code&gt;  占用的内存区域。&lt;/li&gt;
&lt;li&gt;攻击者可能通过覆盖  &lt;code&gt;buf2&lt;/code&gt;  中的内容来修改元数据&lt;/li&gt;
&lt;li&gt;使用  &lt;code&gt;strncpy()&lt;/code&gt;  函数将用户输入复制到  &lt;code&gt;buf2&lt;/code&gt;  中，这可能导致覆盖  &lt;code&gt;buf2&lt;/code&gt;  的元数据（如堆链表指针或其他关键数据）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二次释放  &lt;code&gt;buf1&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;free(buf1)&lt;/code&gt;  导致双重释放，因为  &lt;code&gt;buf1&lt;/code&gt;  已经在第一次释放后被重用，现在与  &lt;code&gt;buf2&lt;/code&gt;  指向相同的内存区域。&lt;/li&gt;
&lt;li&gt;此时，内存分配器可能会使用被攻击者修改的元数据，从而导致不安全的内存操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;释放  &lt;code&gt;buf2&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当  &lt;code&gt;buf2&lt;/code&gt;  被释放时，内存分配器可能会再次处理被攻击者修改的元数据，进一步导致内存覆盖或异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Prevention and Detection of Pointer Errors&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Prevention and Detection of Pointer Errors&#34;&gt;#&lt;/a&gt;Prevention and Detection of Pointer Errors&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Difficult to detect all of them by either dynamic or static analysis&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Complex runtime states&lt;/li&gt;
&lt;li&gt;E.g. memory may be allocated, freed and used in different functions via aliases (pointers)&lt;/li&gt;
&lt;li&gt;Fuzzing may detect some in executed paths when they crash the program&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;The simplest prevention is to set all freed pointers to NULL&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Trigger null pointer dereference errors when accessed&lt;/li&gt;
&lt;li&gt;Most operating systems provide built-in defence against null-pointer dereference&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="software security" />
        <category term="C" />
        <updated>2024-10-28T11:57:22.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/course/AFL/</id>
        <title>AFL</title>
        <link rel="alternate" href="http://example.com/course/AFL/"/>
        <content type="html">&lt;h1 id=&#34;American Fuzzy Lop&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#American Fuzzy Lop&#34;&gt;#&lt;/a&gt; American Fuzzy Lop&lt;/h1&gt;
&lt;h2 id=&#34;Definition&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Definition&#34;&gt;#&lt;/a&gt;Definition&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;A security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. Currently state-of-the-practice at fuzzing (together with forks)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;A type of coverage-based fuzzing: Instrument target programs to track test coverage&lt;/li&gt;
&lt;li&gt;A type of evolutionary/genetic fuzzing: Attempt to generate inputs based on the response of the program&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Why AFL&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;The best general purpose fuzzer
&lt;ul&gt;
&lt;li&gt;For C/C++/Objective C programs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Effective and well-engineered with lots of heuristics
&lt;ul&gt;
&lt;li&gt;Fast – lots of test cases per second&lt;/li&gt;
&lt;li&gt;Clever – test cases are well chosen&lt;/li&gt;
&lt;li&gt;Easy to use (Linux and other platforms)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Deliver out-of-the-box performance far superior to mutation fuzzing or coverage-only tools&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;AFL Approach
&lt;ol&gt;
&lt;li&gt;Load user-supplied initial test cases into the queue&lt;/li&gt;
&lt;li&gt;Take next input file from the queue&lt;/li&gt;
&lt;li&gt;Attempt to trim the test case to the smallest size&lt;/li&gt;
&lt;li&gt;Repeatedly mutate the file using traditional fuzzing strategies&lt;/li&gt;
&lt;li&gt;If any of the generated mutations resulted in a new state transition recorded by the instrumentation, add mutated output as a new entry in the queue&lt;/li&gt;
&lt;li&gt;Go to 2&lt;br&gt;
&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/28/671f221b5c7ee.png&#34; alt=&#34;img&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Fuzzing Through AFL&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Fuzzing Through AFL&#34;&gt;#&lt;/a&gt;Fuzzing Through AFL&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Instrumenting Programs for AFL&lt;br&gt;
Compile through AFL wrappers to generate an instrumented executable for fuzzing
&lt;ul&gt;
&lt;li&gt;Basically, replace  &lt;code&gt;gcc&lt;/code&gt;  with  &lt;code&gt;afl‐gcc&lt;/code&gt;  or  &lt;code&gt;afl-clang&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For simple compilation,  &lt;code&gt;afl‐gcc test.c ‐o test&lt;/code&gt; &lt;br&gt;
For larger projects that use the make build system, add to the Makefile:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CC=path-to/afl-gcc&lt;/code&gt;  or  &lt;code&gt;CC=path-to/afl-clang&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;This allows to build instrumented target program with the AFL wrappers&lt;br&gt;
For C++ code, use the C++ wrappers  &lt;code&gt;afl-g++&lt;/code&gt;  or  &lt;code&gt;afl-clang++&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For example in the Makefile:  &lt;code&gt;CXX=path-to/afl-g++&lt;/code&gt;  or  &lt;code&gt;CXX=path-to/afl-clang++&lt;/code&gt; &lt;br&gt;
AFL 会在编译时插装目标程序的代码，以便在执行期间跟踪路径覆盖情况。插装后的二进制文件包含对 &lt;code&gt; __afl_maybe_log&lt;/code&gt;  的调用，该函数记录程序的执行状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fuzzing Through AFL&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Start fuzzing with AFL   &lt;code&gt;afl‐fuzz ‐i testcase ‐o output ./test @@&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Test cases are under testcase&lt;/li&gt;
&lt;li&gt;The output produced by  goes to the output directory&lt;/li&gt;
&lt;li&gt;The special symbols  &lt;code&gt;@@&lt;/code&gt;  tell AFL to take the file names under test case and feed it to test. Not needed if the program takes input from stdin&lt;/li&gt;
&lt;li&gt;Other common options:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt;  sets timeout for the executed process&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m&lt;/code&gt;  sets memory limit for the executed process&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Initial Test Cases&lt;br&gt;
Don’t waste too much time trying to synthesise your target’s input format&lt;br&gt;
Find some real inputs that exercise as much of the target as possible&lt;br&gt;
From the AFL user guide:
&lt;ul&gt;
&lt;li&gt;Keep the files small. Under 1 kB is ideal, although not strictly necessary&lt;/li&gt;
&lt;li&gt;Use multiple test cases only if they are functionally different from each other&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When To Stop&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Never, as fuzzing is part of continuous integration&lt;/li&gt;
&lt;li&gt;hen the  &lt;code&gt;cycles counter&lt;/code&gt;  is green
&lt;ul&gt;
&lt;li&gt;Last new path was found many cycles ago&lt;/li&gt;
&lt;li&gt;Pending paths is zero&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When the cycles counter is blue
&lt;ul&gt;
&lt;li&gt;Last new path was found over a cycle ago&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If you want to stop earlier, press Ctrl-C
&lt;ul&gt;
&lt;li&gt;E.g. it’s been running for a while (hours + millions of executions + at least 2 cycles&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;AFL Output&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;File  &lt;code&gt;fuzzer_stats&lt;/code&gt;  provides summary of stats UI&lt;/li&gt;
&lt;li&gt;File  &lt;code&gt;plot_data&lt;/code&gt;  shows the progress of fuzzer&lt;/li&gt;
&lt;li&gt;Directory  &lt;code&gt;queue&lt;/code&gt;  shows inputs that led to paths&lt;/li&gt;
&lt;li&gt;Directory  &lt;code&gt;crashes&lt;/code&gt;  contains input that caused crash&lt;/li&gt;
&lt;li&gt;Directory  &lt;code&gt;hangs&lt;/code&gt;  contains input that caused hang&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;AFL Crashes&lt;br&gt;
Unique if the associated execution paths involve any state transitions not seen previously. A single bug may be reached in multiple ways, but AFL can usually recognise&lt;br&gt;
Crashes may be caused by failed assertions - as they abort&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Compiler-supported sanitizers&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Compiler-supported sanitizers&#34;&gt;#&lt;/a&gt;Compiler-supported sanitizers&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Sanitisers 和加固措施&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Sanitisers（内存清理器）：通过在二进制文件中插入额外的代码，检查不良的运行条件。提高模糊测试效果。&lt;/li&gt;
&lt;li&gt;Common compiler-supported sanitisers: ASan, MSan, UBSan, TSan&lt;/li&gt;
&lt;li&gt;加固选项：使内存错误的检测更容易。 &lt;code&gt;AFL_HARDEN=1&lt;/code&gt; ：AFL 的硬化选项，用于检测更多的内存错误。&lt;/li&gt;
&lt;li&gt;注意：Sanitisers 通常不兼容，因此建议：
&lt;ul&gt;
&lt;li&gt;大多数模糊测试运行时启用  &lt;code&gt;AFL_HARDEN&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;小部分测试运行时分别启用每个 Sanitisers，以覆盖不同类型的内存错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;ASan（Address Sanitizer）Compile with  &lt;code&gt;-fsanitize=address&lt;/code&gt; &lt;br&gt;
 检测内容：
&lt;ul&gt;
&lt;li&gt;堆、栈和全局变量的越界访问。&lt;/li&gt;
&lt;li&gt;Use-after-free、double-free、invalid free。&lt;/li&gt;
&lt;li&gt;内存泄漏。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;性能影响：大约 2 倍的运行时间开销。&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;ASan Example1&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;define&lt;/span&gt; N 10 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; s[N] = &lt;span class=&#34;string&#34;&gt;&amp;quot;123456789&amp;quot;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt;= N; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%c&amp;quot;&lt;/span&gt;, s[i]); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Loop bound goes past the end of the array, cannot assess  &lt;code&gt;s[10]&lt;/code&gt;&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;ASan Example2&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *a = &lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;) * &lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;(a); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; a[&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The array is dereferenced after it is free&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;ASan Example3&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *s = &lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt;) * &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;(s); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;, s);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The array is double-freed&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;MSan（Memory Sanitizer） Compile with  &lt;code&gt;-fsanitize=memory&lt;/code&gt; &lt;br&gt;
 检测未初始化的内存使用。&lt;br&gt;
性能影响：大约 3 倍的运行时间开销。&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;MSan Example1&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     a[&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (a[argc]) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;print something\n&amp;quot;&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The array is allocated on &lt;strong&gt;stack&lt;/strong&gt;, but only partially initialised&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;MSan Example2&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a = &lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;) * &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     a[&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (a[argc]) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;print something\n&amp;quot;&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;free&lt;/span&gt;(a); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The array is allocated on &lt;strong&gt;heap&lt;/strong&gt;, but only partially initialised&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;UBSan（Undefined Behavior Sanitizer） Compile with  &lt;code&gt;-fsanitize=undefined&lt;/code&gt; &lt;br&gt;
 检测：
&lt;ul&gt;
&lt;li&gt;解引用空指针。&lt;/li&gt;
&lt;li&gt;有符号整数溢出。&lt;br&gt;
性能影响：大约 20% 的运行时间开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;UBSan Example1&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; n = &lt;span class=&#34;number&#34;&gt;65&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; m = n / (n - n); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Division-by-zero is undefined&lt;/p&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;UBSan Example2&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;foo&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt; &amp;#123;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a, b; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;foo&lt;/span&gt; *&lt;span class=&#34;title&#34;&gt;x&lt;/span&gt; =&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;NULL&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; m = x-&amp;gt;a;  &lt;span class=&#34;comment&#34;&gt;// 访问空指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Accessing a null pointer is undefined&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;TSan（Thread Sanitizer）&lt;br&gt;
检测数据竞争（data races）。&lt;br&gt;
性能影响：运行时间开销约为 5-15 倍，内存开销约为 5-10 倍。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Others&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Others&#34;&gt;#&lt;/a&gt;Others&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Parallel Fuzzing(High performance fuzzing)&lt;br&gt;
Run concurrent fuzzing jobs on multicore systems&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One master instance, one slave per core&lt;/li&gt;
&lt;li&gt;Use the afl-gotcpu tool to measure per-core pre-emption rate&lt;br&gt;
Run the master (-M) like this:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01&lt;/code&gt; &lt;br&gt;
Then, run the slaves (-S) instances like this:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fuzzer Dictionaries(Improve fuzzer mutations)&lt;br&gt;
By default, AFL mutation engine is optimised for compact data formats&lt;br&gt;
Custom dictionaries can help the fuzzer access paths it otherwise wouldn’t  &lt;code&gt;afl-fuzz -x mydict&lt;/code&gt; &lt;br&gt;
Get them from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dictionaries&lt;/code&gt;  directory in AFL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libtokencap&lt;/code&gt;  directory in AFL
&lt;ul&gt;
&lt;li&gt;Create a dictionary by intercepting calls like  &lt;code&gt;strcmp&lt;/code&gt;  and  &lt;code&gt;memcmp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy8rL21hc3Rlci90ZXN0aW5nL2xpYmZ1enplci9mdXp6ZXJzL2RpY3Rz&#34;&gt;Online resource&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Limitations of Fuzzing&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Hard to tell when to stop&lt;/li&gt;
&lt;li&gt;Test the target in the exact configuration you provided, on the input source you set up&lt;/li&gt;
&lt;li&gt;Can get stuck (e.g. checksums)&lt;/li&gt;
&lt;li&gt;Crashes only (typical of most fuzzers). Only notice problems that can be automatically detected&lt;/li&gt;
&lt;li&gt;Need to build target from source&lt;/li&gt;
&lt;li&gt;stdin or file input only&lt;/li&gt;
&lt;li&gt;Coverage-based instrumentation won’t guide it towards all crashes
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x = 1/(input – 1234)&lt;/code&gt;  ：在这种情况下，AFL 可能难以找到输入 1234，从而导致无法检测到除零错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No automatic parallelisation&lt;/li&gt;
&lt;li&gt;Linux/macOS only&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;libFuzzer: Guided Fuzzing for APIs&lt;br&gt;
The other top general purpose fuzzer
&lt;ul&gt;
&lt;li&gt;Use similar algorithms to AFL&lt;/li&gt;
&lt;li&gt;Build it with special compiler instrumentation (LLVM)&lt;br&gt;
Targets functions rather than programs&lt;/li&gt;
&lt;li&gt;Testers have to write a harness&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Linux" />
        <category term="software security" />
        <category term="C" />
        <category term="AFL" />
        <updated>2024-10-28T04:45:49.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/course/Format-string-bugs/</id>
        <title>Format string bugs</title>
        <link rel="alternate" href="http://example.com/course/Format-string-bugs/"/>
        <content type="html">&lt;h1 id=&#34;Format Functions&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Format Functions&#34;&gt;#&lt;/a&gt;Format Functions&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Format Functions&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt;  Output a formatted string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fprintf&lt;/code&gt;  Writes the printf to a file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sprintf&lt;/code&gt;  Prints into a string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snprintf&lt;/code&gt;  Prints into a string checking the length&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vprintf&lt;/code&gt;  Prints the argument list to stdout&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vfprintf&lt;/code&gt;  Prints the argument list to a file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vsprintf&lt;/code&gt;  Prints the argument list to a string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vsnprintf&lt;/code&gt;  Prints the argument to a string checking the length&lt;br&gt;
 总结： &lt;code&gt;printf&lt;/code&gt;  和  &lt;code&gt;fprintf&lt;/code&gt;  用于输出格式化字符串到标准输出或文件。&lt;br&gt;
 &lt;code&gt;sprintf&lt;/code&gt;  和  &lt;code&gt;snprintf&lt;/code&gt;  用于将格式化字符串写入字符串缓冲区， &lt;code&gt;snprintf&lt;/code&gt;  更安全。&lt;br&gt;
 &lt;code&gt;vprintf&lt;/code&gt; 、 &lt;code&gt;vfprintf&lt;/code&gt; 、 &lt;code&gt;vsprintf&lt;/code&gt;  和  &lt;code&gt;vsnprintf&lt;/code&gt;  用于处理可变参数列表，与前面的函数类似，但专门用于  &lt;code&gt;va_list&lt;/code&gt;  参数的处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Format Strings&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Format String is the argument of format functions that contains format parameters. Format parameters are placeholders to be replaced with user inputs&lt;/li&gt;
&lt;li&gt;For example, the statement will output different sentences, depending on what is contained in the variable name:  &lt;code&gt;printf(&amp;quot;Hello, %s.&amp;quot;, &amp;amp;name);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If the variable name contains the string “Zz”, then  &lt;code&gt;printf()&lt;/code&gt;  will output: Hello, Zz.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Common Parameters Used in Format String Attacks&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;传递方式&lt;/th&gt;
&lt;th&gt;在攻击中的作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;%s&lt;/td&gt;
&lt;td&gt;打印字符串&lt;/td&gt;
&lt;td&gt;引用（指向字符串的指针）&lt;/td&gt;
&lt;td&gt;攻击者可以利用 % s 打印出内存中的任意数据，通过提供特定的内存地址，读取敏感数据（如密码、密钥等）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%d&lt;/td&gt;
&lt;td&gt;打印有符号十进制整数&lt;/td&gt;
&lt;td&gt;整数值&lt;/td&gt;
&lt;td&gt;虽然 % d 通常用于整数显示，但攻击者可以通过它来泄露内存中的整数值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%u&lt;/td&gt;
&lt;td&gt;打印无符号十进制整数&lt;/td&gt;
&lt;td&gt;无符号整数值&lt;/td&gt;
&lt;td&gt;与 % d 类似，但用于无符号整数的显示。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%x&lt;/td&gt;
&lt;td&gt;打印十六进制整数（小写）&lt;/td&gt;
&lt;td&gt;无符号整数值&lt;/td&gt;
&lt;td&gt;攻击者可以通过 % x 逐步读取内存，以十六进制显示地址中的数据内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%c&lt;/td&gt;
&lt;td&gt;打印单个字符&lt;/td&gt;
&lt;td&gt;字符值&lt;/td&gt;
&lt;td&gt;用于显示单个字符，但在攻击中用途有限。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%n&lt;/td&gt;
&lt;td&gt;将已打印的字符数写入指定变量&lt;/td&gt;
&lt;td&gt;引用（指向整数的指针）&lt;/td&gt;
&lt;td&gt;攻击者可以利用 % n 修改任意内存地址的值，这是格式字符串攻击中最危险的参数之一，可能被用来修改程序的控制流。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%%&lt;/td&gt;
&lt;td&gt;打印 % 字符&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;用于输出 % 字符，无特别的攻击价值。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;How Do Format Functions Work?&lt;br&gt;
According to the data format dictated by the format parameters, format functions retrieve the arguments from the stack&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;printf(“A is the number %d, B is the string %s”, A, &amp;amp;B);&lt;br&gt;
The  &lt;code&gt;printf()&lt;/code&gt;  function will attempt to retrieve the value of A and the address of string B from the stack&lt;br&gt;
 在格式化字符串中，每个格式参数（如  &lt;code&gt;%d&lt;/code&gt; 、 &lt;code&gt;%s&lt;/code&gt; ）都告诉  &lt;code&gt;printf()&lt;/code&gt;  如何解释栈中的数据： &lt;code&gt;%d&lt;/code&gt;  表示检索一个 整数值。 &lt;code&gt;%s&lt;/code&gt;  表示检索一个 字符串指针（地址），然后根据地址打印对应的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Exploit&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Exploit&#34;&gt;#&lt;/a&gt;Exploit&lt;/h1&gt;
The vulnerability occurs when there is a mismatch between the number of format parameters and the number of function arguments provided to fill those places 
- For example, if an attacker is able to supply more placeholders than there are arguments, he/she can use format functions to read or write the stack! 
Format functions can be exploited when an attacker is given direct control over the format string fed into the function
&lt;ol&gt;
&lt;li&gt;Reading Data from Stack&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;printf(&amp;quot;A is the number  &lt;code&gt;%d&lt;/code&gt; , reading stack data:  &lt;code&gt;%x&lt;/code&gt; &amp;quot;, A);
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf()&lt;/code&gt;  will attempt to retrieve two values from the stack&lt;/li&gt;
&lt;li&gt;But only one of those is placed on the stack&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf()&lt;/code&gt;  will retrieve the next value on the stack and display it in hex format!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To print the next 20 items on the stack:
&lt;ul&gt;
&lt;li&gt;printf(&amp;quot;%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x&amp;quot;);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To print the tenth element next on the stack:
&lt;ul&gt;
&lt;li&gt;printf(&amp;quot;%10$x&amp;quot;);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Reading Data at Arbitrary Location  &lt;code&gt;%s&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Format functions treat the data on the stack as an address to go fetch a string
&lt;ul&gt;
&lt;li&gt;Note that  &lt;code&gt;%s&lt;/code&gt;  is passed as reference!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;How to control the address accessed by  &lt;code&gt;%s&lt;/code&gt; ?
&lt;ul&gt;
&lt;li&gt;Place an address on the format string (the string is stored on stack)&lt;/li&gt;
&lt;li&gt;Get  &lt;code&gt;%s&lt;/code&gt;  to dereference it!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To print the string located at address 0x12345678:
&lt;ul&gt;
&lt;li&gt;printf(&amp;quot;\x78\x56\x34\x12%x%x%x%s&amp;quot;, A, B, C);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Writing Data at Arbitrary Location  &lt;code&gt;%n&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%n&lt;/code&gt;  stores the number of characters written so far into the corresponding function argument! For example, the following code put the integer 5 into the variable  &lt;code&gt;num_char&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; num_char; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;11111%n&amp;quot;&lt;/span&gt;, &amp;amp;num_char); &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;With width-controlling format parameters, the attacker can write arbitrary integers to the location pointed to by the function argument&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write 10 to num_char using width-controlling format parameter&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; num_char; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%10d%n&amp;quot;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &amp;amp;num_char);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Control the amount of data written with length parameter
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf(&amp;quot;%10d%hn&amp;quot;, 0, &amp;amp;num_char);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Writes 2 bytes (instead of 4 bytes) to  &lt;code&gt;&amp;amp;num_char&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Combined with the trick to access arbitrary memory locations, the attacker can write to arbitrary memory locations&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Example&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;512&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     fgets(buf, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(buf), &lt;span class=&#34;built_in&#34;&gt;stdin&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 安全读取输入，不会导致缓冲区溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;The input is:&amp;quot;&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(buf);  &lt;span class=&#34;comment&#34;&gt;// 存在格式化字符串漏洞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf(buf);&lt;/code&gt;  直接使用了用户输入的内容作为格式化字符串。如果  &lt;code&gt;buf&lt;/code&gt;  中包含格式化占位符（如  &lt;code&gt;%s&lt;/code&gt; 、 &lt;code&gt;%x&lt;/code&gt; 、 &lt;code&gt;%n&lt;/code&gt;  等）， &lt;code&gt;printf()&lt;/code&gt;  会将其解释为格式化指令，从而造成安全隐患。&lt;/li&gt;
&lt;li&gt;修复：  &lt;code&gt;printf(&amp;quot;The input is: %s&amp;quot;, buf);&lt;/code&gt; ：% s 确保输入内容被当作普通字符串处理，而不是格式化字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Denial of Service Attacks&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Denial of Service Attacks&#34;&gt;#&lt;/a&gt;Denial of Service Attacks&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Crash the program by attempting to access an invalid address&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use  &lt;code&gt;%s&lt;/code&gt;  to retrieve a value from the stack till encountering an invalid memory location&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The exploit string would look something like this&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;·printf(&amp;quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&amp;quot;);·&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The more %s used in the format string, the higher the chance of an invalid address&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Format String Attacks Prevention&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Format String Attacks Prevention&#34;&gt;#&lt;/a&gt;Format String Attacks Prevention&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Hard-coded format strings (e.g. no  &lt;code&gt;printf(arg)&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;Do not use the fancy  &lt;code&gt;%n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Be careful with pass as references&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;e.g.  &lt;code&gt;%s&lt;/code&gt;  and  &lt;code&gt;sprintf&lt;/code&gt;  can be used to create disclosure attacks&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Compiler support to match  &lt;code&gt;printf&lt;/code&gt;  arguments with format string&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;e.g. the  &lt;code&gt;gcc&lt;/code&gt;  compiler provides options to check format strings&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="software security" />
        <category term="C" />
        <category term="vulnerability" />
        <updated>2024-10-26T11:52:22.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/course/Integer-overflow/</id>
        <title>Integer overflow</title>
        <link rel="alternate" href="http://example.com/course/Integer-overflow/"/>
        <content type="html">&lt;h1 id=&#34;Integer overflow&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Integer overflow&#34;&gt;#&lt;/a&gt;Integer overflow&lt;/h1&gt;
 When the result of an integer operation does not fit within the allocated memory space. All common languages are affected 
&lt;ol&gt;
&lt;li&gt;How Does an Integer Overflow Happen?
&lt;ol&gt;
&lt;li&gt;无符号整数溢出：例如，一个 32 位无符号整数的范围是 0 到 4,294,967,295（即 2**32 − 1 或 0xffffffff）。如果我们执行计算 4,294,967,295 + 1，则会导致溢出，因为结果超出了无符号整数的范围&lt;/li&gt;
&lt;li&gt;有符号整数溢出&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;符号位的溢出&lt;br&gt;
当一个整数运算的结果超过有符号整数的范围时，符号位（最高位）可能会被覆盖，从而引发溢出。&lt;br&gt;
有符号整数的符号位：在有符号整数中，最高位用来表示数值的正负。例如，32 位有符号整数的最高位是第 31 位（第 0 位到第 30 位是数值位）。溢出导致符号变化：如果运算结果超出正数范围，符号位会被设置为 1，这会导致数值被解释为负数。例如，在 32 位有符号整数中，+2,147,483,647 + 1 会导致数值变成 -2,147,483,648，因为符号位被改变。&lt;/li&gt;
&lt;li&gt;向下类型转换（Downcasting）和数值截断（Truncation）
&lt;ul&gt;
&lt;li&gt;向下类型转换：指将一个高精度的数据类型转换为低精度的数据类型。例如，将 long 类型转换为 int 时，如果原始值超过 int 的范围，可能会导致数值截断。&lt;/li&gt;
&lt;li&gt;数值截断可能导致溢出：截断发生时，较高位的数值会被忽略，只保留低位部分。这可能导致数值错误，甚至触发整数溢出。例如，如果一个 64 位的 long 类型被转换为 32 位的 int 类型，而其数值超过了 32 位整数的最大值，那么高位将被截断，只保留低 32 位，可能导致溢出或错误的计算结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Risks of Integer Overflow&lt;br&gt;
Mostly lead to program errors, but can have severe consequences&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Buffer overflow occurs when an integer overflow happens in calculating the length of the buffer&lt;/li&gt;
&lt;li&gt;Erroneous program behaviours in mission critical software Incorrect financial calculations&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Real-World Examples&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Real-World Examples&#34;&gt;#&lt;/a&gt;Real-World Examples&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Integer Overflow Leads to Buffer Overflow in OpenSSH 3.3&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;nresp = packet_get_int(); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (nresp &amp;gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	response = xmalloc(nresp * &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *)); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; nresp; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 		response[i] = packet_get_string(&lt;span class=&#34;literal&#34;&gt;NULL&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;When  &lt;code&gt;nresp&lt;/code&gt;  is 1073741824 (1073741824*4=4294967296=2**32), results in an overflow&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xmalloc()&lt;/code&gt;  receives and allocates a 0-byte buffer&lt;/li&gt;
&lt;li&gt;The subsequent loop causes a heap buffer overflow (当循环试图将数据写入到  &lt;code&gt;response&lt;/code&gt;  时，由于  &lt;code&gt;response&lt;/code&gt;  并未真正分配内存，写入操作会覆盖其他内存区域，导致程序崩溃或被攻击者利用。)&lt;/li&gt;
&lt;li&gt;fixed:  &lt;code&gt;if (nresp &amp;gt; 0 &amp;amp;&amp;amp; nresp &amp;lt;= SIZE_MAX / sizeof(char *))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;A Real-World Vulnerability in the Handling JPEG Files&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getComment&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; len, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *src)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; size; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	size = len ‐ &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *comment = (&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(size + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;built_in&#34;&gt;memcpy&lt;/span&gt;(comment, src, size); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;整数下溢&lt;br&gt;
在这段代码中，变量  &lt;code&gt;len&lt;/code&gt;  和  &lt;code&gt;size&lt;/code&gt;  被声明为无符号整数（unsigned int），这意味着它们的值不能是负数。&lt;br&gt;
当  &lt;code&gt;len&lt;/code&gt;  小于 2 时，计算  &lt;code&gt;size = len - 2&lt;/code&gt;  会导致 整数下溢：&lt;br&gt;
例如， &lt;code&gt;len&lt;/code&gt;  为 1 时， &lt;code&gt;size&lt;/code&gt;  将变为 0xffffffff（4294967295），即无符号整数的最大值。&lt;br&gt;
下溢的原因在于无符号整数的运算特性，当减法结果为负时，会回绕（wrap around）到最大值。&lt;/li&gt;
&lt;li&gt;0 字节内存分配&lt;br&gt;
在下溢的情况下，当  &lt;code&gt;size&lt;/code&gt;  被设置为 0xffffffff 时，表达式  &lt;code&gt;size + 1&lt;/code&gt;  变为 0。&lt;br&gt;
这会导致  &lt;code&gt;malloc(0)&lt;/code&gt; ，即分配一个 0 字节的缓冲区。&lt;br&gt;
在许多系统中，0 字节的  &lt;code&gt;malloc()&lt;/code&gt;  是合法的，它会返回一个指针，但该指针不能被写入任何数据。&lt;/li&gt;
&lt;li&gt;堆缓冲区溢出&lt;br&gt;
 &lt;code&gt;memcpy(comment, src, size)&lt;/code&gt;  将从  &lt;code&gt;src&lt;/code&gt;  复制  &lt;code&gt;size&lt;/code&gt;  个字节到  &lt;code&gt;comment&lt;/code&gt; ，其中  &lt;code&gt;size&lt;/code&gt;  的值为 0xffffffff。&lt;br&gt;
由于  &lt;code&gt;comment&lt;/code&gt;  是一个 0 字节的缓冲区，这将导致 堆缓冲区溢出，可能覆盖其他堆内存区域，从而导致程序崩溃或被攻击者利用。&lt;/li&gt;
&lt;li&gt;修复&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (len &amp;lt;= &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; size = len - &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Example 3&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;CopyStructs&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(InputFile* pInFile, &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; count)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     m_pStructs = new Structs[count]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!ReadFromFile(pInFile, &amp;amp;(m_pStructs[i]))) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;             &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The C++’s  &lt;code&gt;new[]&lt;/code&gt;  operator, it is similar to  &lt;code&gt;malloc(count*sizeof(Structs))&lt;/code&gt; &lt;br&gt;
Allocate a buffer smaller than we need, the attacker is able to write over the buffer&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;By &lt;strong&gt;overflowing the multiplication operation&lt;/strong&gt; internally&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Example 4&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;define&lt;/span&gt; MAX_BUF 256&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;BadCode&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *input)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;short&lt;/span&gt; len; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[MAX_BUF]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     len = &lt;span class=&#34;built_in&#34;&gt;strlen&lt;/span&gt;(input); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (len &amp;lt; MAX_BUF) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         &lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buf, input); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;strlen()&lt;/code&gt;  返回无符号整数&lt;br&gt;
 &lt;code&gt;strlen()&lt;/code&gt;  返回的是无符号整数类型 &lt;code&gt;size_t&lt;/code&gt; ，通常是一个 32 位或 64 位无符号整数。&lt;br&gt;
 &lt;code&gt;len&lt;/code&gt;  被定义为一个 16 位有符号短整型 &lt;code&gt;short&lt;/code&gt; ，其范围是 -32,768 到 32,767。&lt;/li&gt;
&lt;li&gt;类型截断和符号翻转&lt;br&gt;
当  &lt;code&gt;strlen(input)&lt;/code&gt;  返回的长度超过  &lt;code&gt;32,767&lt;/code&gt;  时，赋值给  &lt;code&gt;short len&lt;/code&gt;  时会发生 类型截断，导致溢出。&lt;br&gt;
例如，如果  &lt;code&gt;strlen(input)&lt;/code&gt;  返回 40,000，那么赋值后， &lt;code&gt;len&lt;/code&gt;  的值将会变成 -25,536（溢出后的值），因为  &lt;code&gt;short&lt;/code&gt;  类型的最大正值只能到 32,767。&lt;br&gt;
这会将一个本应是大于 256 的值变成一个负数。&lt;/li&gt;
&lt;li&gt;缓冲区溢出风险&lt;br&gt;
在类型截断后， &lt;code&gt;len&lt;/code&gt;  可能是负数。条件  &lt;code&gt;if (len &amp;lt; MAX_BUF)&lt;/code&gt;  将会成立，因为负数小于 256。&lt;br&gt;
这意味着，即使输入字符串的实际长度超过了 256 字节， &lt;code&gt;strcpy(buf, input)&lt;/code&gt;  仍会被执行，导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;修复&lt;br&gt;
 &lt;code&gt;len = strnlen(input, MAX_BUF);&lt;/code&gt; : The  &lt;code&gt;strnlen()&lt;/code&gt;  function returns an integer value capped by  &lt;code&gt;MAX_BUF&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Integer Overflow Prevention&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Integer Overflow Prevention&#34;&gt;#&lt;/a&gt;Integer Overflow Prevention&lt;/h1&gt;
Integer overflow is very hard to discover and prevent
&lt;ol&gt;
&lt;li&gt;Runtime checks&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ubsan instruments binaries to be executed and checks the results of arithmetic operations&lt;/li&gt;
&lt;li&gt;Microsoft Visual C++ 2005 and later automatically catch calls to operator new that overflow&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Library support&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;SafeInt class performs safe operations&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Static analysis tools and formal verification techniques&lt;br&gt;
 在程序编译前对源代码进行分析，寻找潜在的整数溢出问题。这些工具可以检测代码中的常见整数运算错误，包括加减乘除溢出、类型转换溢出等&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="software security" />
        <category term="C" />
        <updated>2024-10-26T10:33:32.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/course/Stack-buffer-overflow/</id>
        <title>Stack buffer overflow</title>
        <link rel="alternate" href="http://example.com/course/Stack-buffer-overflow/"/>
        <content type="html">&lt;h1 id=&#34;Stack buffer overflow&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Stack buffer overflow&#34;&gt;#&lt;/a&gt;Stack buffer overflow&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;The Process Stack&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Sample Process C Code&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; b, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; c)&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer1[&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer2[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    	... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	A(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(...); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   	 ... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/26/671ca1b71cfbb.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在调用函数时，函数参数是按照从右到左的顺序依次压入栈中。这种参数传递方式是 x86 架构的标准做法，用于保证函数参数在栈上的正确顺序。&lt;br&gt;
在这个例子中，函数  &lt;code&gt;A(int a, int b, int c)&lt;/code&gt;  被调用时， &lt;code&gt;c&lt;/code&gt;  首先被压入栈，然后是  &lt;code&gt;b&lt;/code&gt; ，最后是  &lt;code&gt;a&lt;/code&gt; 。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Buffer Overflow&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Occurs when:&lt;br&gt;
Input is unconstrained&lt;br&gt;
Runs past the end of a buffer, replacing valid (control) data&lt;/li&gt;
&lt;li&gt;Technique that allows:&lt;br&gt;
Your code to be executed by another program&lt;br&gt;
Overflow data area to alter variable values&lt;/li&gt;
&lt;li&gt;Problem: declaration in version of login.c is  &lt;code&gt;char name[80], passwd[80], hash[13];&lt;/code&gt; . Attack login procedure:
&lt;ol&gt;
&lt;li&gt;User types username, which is stored in name&lt;/li&gt;
&lt;li&gt;Compute hash for the corresponding password&lt;/li&gt;
&lt;li&gt;User types password, pads to 80 chars, and types hash for that password&lt;/li&gt;
&lt;li&gt;The program validates password against user-supplied hash; user is in (with any password)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Stack Smashing&lt;br&gt;
 缓冲区溢出攻击的核心是覆盖栈上的 返回地址（ret）。当返回地址被覆盖时，程序在函数返回时不会跳回调用函数的位置，而是跳转到攻击者指定的位置。攻击者可以利用这种技术让程序执行任意代码（如恶意代码或 shellcode），这被称为堆栈破坏。&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Stack Smashing&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionA&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *str)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer[&lt;span class=&#34;number&#34;&gt;16&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buffer, str);   &lt;span class=&#34;comment&#34;&gt;//segmentation fault&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; large_string[&lt;span class=&#34;number&#34;&gt;256&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;255&lt;/span&gt;; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		large_string[i] = &lt;span class=&#34;string&#34;&gt;&amp;#x27;A&amp;#x27;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	functionA(large_string); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buffer&lt;/code&gt; ：在  &lt;code&gt;functionA&lt;/code&gt;  中声明为 16 字节的字符数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcpy(buffer, str)&lt;/code&gt; ：使用  &lt;code&gt;strcpy&lt;/code&gt;  将外部传入的字符串 str 复制到 buffer 中。由于  &lt;code&gt;strcpy&lt;/code&gt;  不检查长度，如果  &lt;code&gt;str&lt;/code&gt;  的长度超过 16 字节，会导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;在  &lt;code&gt;main&lt;/code&gt;  中， &lt;code&gt;large_string&lt;/code&gt;  是一个 256 字节的数组，它被填充为 255 个 ‘A’。当  &lt;code&gt;large_string&lt;/code&gt;  被传递给  &lt;code&gt;functionA&lt;/code&gt;  时， &lt;code&gt;buffer&lt;/code&gt;  被溢出。&lt;/li&gt;
&lt;li&gt;修复：  &lt;code&gt;strcpy(buffer, str)&lt;/code&gt;  --&amp;gt;  &lt;code&gt;strncpy(buffer, str, 16);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/26/671ca87ccb1e2.png&#34; alt=&#34;img&#34;&gt;&lt;br&gt;
 &lt;code&gt;large_str&lt;/code&gt;  has overflowed  &lt;code&gt;buffer&lt;/code&gt;  and  &lt;code&gt;sfp&lt;/code&gt;  and  &lt;code&gt;ret&lt;/code&gt;  and  &lt;code&gt;*str&lt;/code&gt; .Note that  &lt;code&gt;ret&lt;/code&gt;  is the return address!&lt;br&gt;
This means we can get the function to return to any point in the code that we specify.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer overflows allow us to change return address
&lt;ol&gt;
&lt;li&gt;Can point to any function in the library&lt;/li&gt;
&lt;li&gt;Can point to own code&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Add code in the overflowed buffer
&lt;ol&gt;
&lt;li&gt;Run at privilege of process (very useful if root!)&lt;/li&gt;
&lt;li&gt;Even a small buffer can invoke a shell using the system call (often called shellcode)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Attacker would like to run shell at root level
&lt;ol&gt;
&lt;li&gt;Make system call to  &lt;code&gt;execve&lt;/code&gt; , passing  &lt;code&gt;/bin/sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Needs to be part of the buffer, and in assembly code (以便精确控制其大小和功能)&lt;/li&gt;
&lt;li&gt;Program has to fit in buffer without overwriting return address (如果 shellcode 覆盖了返回地址本身，可能导致程序崩溃而无法执行攻击代码)&lt;/li&gt;
&lt;li&gt;Pad out buffer to return address, and point return address to start of buffer&lt;/li&gt;
&lt;li&gt;Don’t generate core dump (this will cause suspicion)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;What do You Need to Hack a Buffer Overflow
&lt;ol&gt;
&lt;li&gt;Address where buffer begins&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Easy to get if you have access to the same type of system being attacked&lt;/li&gt;
&lt;li&gt;Can use Null Operation (NOP) commands to make the target address bigger&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Location where return address is stored&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Can pad out the buffer with return address&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Assembly language program to spawn a shell (shellcode payload)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Can use gdb to disassemble a program for you&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Affected Languages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Buffer overflows mainly occur in low-level programming languages that allow direct memory access: Assembler, C, C++&lt;br&gt;
Note that some high-level languages such as Java, C# and Visual Basic are written in C, C++ or call modules written in these languages&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;Buffer Overflow Examples&lt;br&gt;
Functions that handle arrays but do not check length (checking for termination character is insufficient) In C/C++,   &lt;code&gt;gets&lt;/code&gt; ,  &lt;code&gt;strcpy&lt;/code&gt; ,  &lt;code&gt;strcat&lt;/code&gt; ,  &lt;code&gt;sprintf&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Example 1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; gets(buf);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char buf[20]&lt;/code&gt; ：定义了一个长度为 20 的字符数组  &lt;code&gt;buf&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gets(buf)&lt;/code&gt; ：使用  &lt;code&gt;gets()&lt;/code&gt;  函数从标准输入读取字符串，并存储在  &lt;code&gt;buf&lt;/code&gt;  中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gets()&lt;/code&gt;  函数不检查输入的长度，意味着如果输入的字符串长度超过了  &lt;code&gt;buf&lt;/code&gt;  的大小（20 字节），则会发生缓冲区溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复：  &lt;code&gt;fgets(buf, sizeof(buf), stdin);&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Example 2&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; prefix[] = &lt;span class=&#34;string&#34;&gt;&amp;quot;http://&amp;quot;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   ... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &lt;span class=&#34;comment&#34;&gt;// copies the string prefix to buf &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buf, prefix); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &lt;span class=&#34;comment&#34;&gt;// concatenates path to the string buf &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strncat&lt;/span&gt;(buf, path, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(buf));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char buf[20]&lt;/code&gt; ：定义了一个长度为 20 字节的字符数组  &lt;code&gt;buf&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char prefix[] = &amp;quot;http://&amp;quot;;&lt;/code&gt; ：定义了一个包含字符串  &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt;  的字符数组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strcpy(buf, prefix)&lt;/code&gt; ：将字符串  &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt;  复制到  &lt;code&gt;buf&lt;/code&gt;  中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题： &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt;  长度为 7 字节（包括终止符 \0），在复制后， &lt;code&gt;buf&lt;/code&gt;  中只剩下 13 个字节可用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strncat(buf, path, sizeof(buf))&lt;/code&gt; ：将字符串  &lt;code&gt;path&lt;/code&gt;  连接到  &lt;code&gt;buf&lt;/code&gt;  中，指定的最大长度为  &lt;code&gt;sizeof(buf)&lt;/code&gt; （即 20 字节）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题：这里的  &lt;code&gt;sizeof(buf)&lt;/code&gt;  是 20 字节，但在前面已经用掉了 7 字节（包括终止符）。 &lt;code&gt;strncat()&lt;/code&gt;  试图追加  &lt;code&gt;path&lt;/code&gt;  的内容时，可能会超出  &lt;code&gt;buf&lt;/code&gt;  的剩余空间（13 字节），导致缓冲区溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复： &lt;code&gt;strncat(buf, path, sizeof(buf) - strlen(buf) - 1);&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Example 3&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;32&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(buf, data, &lt;span class=&#34;built_in&#34;&gt;strlen&lt;/span&gt;(data)); &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;strncpy(buf, data, strlen(data))&lt;/code&gt; ：将字符串  &lt;code&gt;data&lt;/code&gt;  复制到  &lt;code&gt;buf&lt;/code&gt;  中，复制的长度为  &lt;code&gt;strlen(data)&lt;/code&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缺陷 1：缺少终止符 \0： &lt;code&gt;strncpy&lt;/code&gt;  不会自动添加字符串的终止符  &lt;code&gt;\0&lt;/code&gt; ，如果  &lt;code&gt;data&lt;/code&gt;  的长度等于或大于 32，那么  &lt;code&gt;buf&lt;/code&gt;  不会以  &lt;code&gt;\0&lt;/code&gt;  结尾。这可能导致  &lt;code&gt;buf&lt;/code&gt;  被当作未终止的字符串处理，带来不确定的行为或安全风险。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺陷 2：可能的缓冲区溢出：如果  &lt;code&gt;strlen(data) &amp;gt; 32&lt;/code&gt; ， &lt;code&gt;strncpy&lt;/code&gt;  将尝试复制超过  &lt;code&gt;buf&lt;/code&gt;  大小的内容，导致缓冲区溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复： &lt;code&gt;strncpy(buf, data, sizeof(buf) - 1); buf[sizeof(buf) - 1] = &#39;\0&#39;;&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Example 4&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[MAX_PATH]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;sprintf&lt;/span&gt;(buf, &lt;span class=&#34;string&#34;&gt;&amp;quot;%s - %d\n&amp;quot;&lt;/span&gt;, path, errno);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sprintf(buf, &amp;quot;%s - %d\n&amp;quot;, path, errno)&lt;/code&gt;  会将  &lt;code&gt;path&lt;/code&gt;  和  &lt;code&gt;errno&lt;/code&gt;  的格式化字符串复制到  &lt;code&gt;buf&lt;/code&gt;  中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sprintf&lt;/code&gt;  不检查  &lt;code&gt;buf&lt;/code&gt;  的大小是否足以容纳格式化后的结果。如果  &lt;code&gt;path&lt;/code&gt;  很长，加上数字  &lt;code&gt;errno&lt;/code&gt;  和其他字符，可能会超过  &lt;code&gt;MAX_PATH&lt;/code&gt; ，导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;修复：  &lt;code&gt;snprintf(buf, sizeof(buf), &amp;quot;%s - %d\n&amp;quot;, path, errno);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Stack buffer overflow prevention&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Stack buffer overflow prevention&#34;&gt;#&lt;/a&gt;Stack buffer overflow prevention&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Spotting Buffer Overflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Check inputs, whether read from the network, a file, or from the command line&lt;/li&gt;
&lt;li&gt;Check transfer of data from said input to internal structures&lt;/li&gt;
&lt;li&gt;Look for use of unsafe string handling calls&lt;/li&gt;
&lt;li&gt;Look for use of arithmetic to calculate an allocation size or remaining buffer size&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Fixing Buffer Overflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Replace dangerous string handling functions&lt;/li&gt;
&lt;li&gt;Replace C string buffers with C++ strings&lt;/li&gt;
&lt;li&gt;Replace static arrays with STL containers&lt;/li&gt;
&lt;li&gt;Use analysis tools, Examples include Fortify, Coverity, PREfast, and Klocwor&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Code Analysis&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Statically check source to detect buffer overflows s&lt;/li&gt;
&lt;li&gt;Several tools exist to automate the review process&lt;br&gt;
Stanford:  Engler, et al.  Test trust inconsistency&lt;br&gt;
@stake.com  (&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2wwcGh0LmNvbQ==&#34;&gt;l0pht.com&lt;/span&gt;): SLINT (designed for UNIX)&lt;br&gt;
Berkeley:  Wagner, et al.  Test constraint violations&lt;/li&gt;
&lt;li&gt;Find lots of bugs, but not all&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Marking Stack as Non-Execute&lt;br&gt;
Basic stack exploit can be prevented by marking stack segment as non-executable&lt;br&gt;
Limitations and Problems&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Some apps need executable stack (e.g. LISP interpreters)&lt;/li&gt;
&lt;li&gt;Does not block more general overflow exploits&lt;/li&gt;
&lt;li&gt;Overflow on heap: overflow buffer next to func pointer&lt;/li&gt;
&lt;li&gt;Cannot make all the data segment non-executable&lt;/li&gt;
&lt;li&gt;More recent UNIX and MS windows emit dynamic code into program data for performance optimisations&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Stack Protection and Run-time Checking&lt;br&gt;
Many run-time checking techniques
&lt;ol&gt;
&lt;li&gt;Example:  StackGuard (WireX)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Run time tests for stack integrity&lt;/li&gt;
&lt;li&gt;Code generator for emitting code to set up and tear down functions&lt;/li&gt;
&lt;li&gt;Embeds “canaries” in stack frames and verify their integrity prior to function return&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Libsafe (Avaya Labs)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Dynamically loaded library&lt;/li&gt;
&lt;li&gt;Intercepts calls to  &lt;code&gt;strcpy (dest, src)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Validate sufficient space in current stack frame: |framepointer–dest| &amp;gt; strlen(src)&lt;/li&gt;
&lt;li&gt;If so, does strcpy. Otherwise, terminates application&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Address obfuscation (Stony Brook’03)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Encrypt return address on stack by XORing with random string. Decrypt just before returning from function&lt;/li&gt;
&lt;li&gt;Attacker needs decryption key to set return address to desired value&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;PaX ASLR: Randomise location of libc&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Attacker cannot jump directly to exec function&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="software security" />
        <category term="C" />
        <category term="vulnerability" />
        <updated>2024-10-26T07:50:30.000Z</updated>
    </entry>
</feed>
