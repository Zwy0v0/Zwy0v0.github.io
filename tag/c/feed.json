{
    "version": "https://jsonfeed.org/version/1",
    "title": "null â€¢ All posts by \"c\" tag",
    "description": "ğŸŒ¸",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/course/Heap-buffer-overflow/",
            "url": "http://example.com/course/Heap-buffer-overflow/",
            "title": "Heap buffer overflow",
            "date_published": "2024-10-28T11:57:22.000Z",
            "content_html": "<h1 id=\"Heap allocation\" class=\"active\"><a class=\"anchor\"  href=\"#Heap allocation\">#</a>Heap allocation</h1>\n<h2 id=\"Memory Allocation\" class=\"active\"><a class=\"anchor\"  href=\"#Memory Allocation\">#</a>Memory Allocation</h2>\n<ol>\n<li>Static memory</li>\n</ol>\n<ul>\n<li>Store global variables, permanent for the entire lifetime of the process</li>\n</ul>\n<ol start=\"2\">\n<li>Automatic memory</li>\n</ol>\n<ul>\n<li>Stack stores local variables, stackframes are added or removed for functional calls</li>\n</ul>\n<ol start=\"3\">\n<li>Dynamic memory</li>\n</ol>\n<ul>\n<li>Heap stores shared data structures in a large pool of memory</li>\n<li>Not allocated in contiguous order ç”±ç¨‹åºå‘˜ç®¡ç†</li>\n</ul>\n<h2 id=\"Stack Allocation\" class=\"active\"><a class=\"anchor\"  href=\"#Stack Allocation\">#</a>Stack Allocation</h2>\n<ol>\n<li>Stack is contiguous blocks of memory managed by OS</li>\n</ol>\n<ul>\n<li>Cannot be modified</li>\n</ul>\n<ol start=\"2\">\n<li>Stack grows and shrinks as functions are called and exited</li>\n</ol>\n<ul>\n<li>Usually has an upper bound, may raise exceptions</li>\n</ul>\n<ol start=\"3\">\n<li>Variables are allocated and freed automatically</li>\n</ol>\n<ul>\n<li>Only exist when the function that created them is active on the stack</li>\n</ul>\n<h2 id=\"Heap Allocation\" class=\"active\"><a class=\"anchor\"  href=\"#Heap Allocation\">#</a>Heap Allocation</h2>\n<ol>\n<li>Heap is noncontiguous blocks of memory managed by the programmer</li>\n</ol>\n<ul>\n<li>Can be modified programatically</li>\n</ul>\n<ol start=\"2\">\n<li>Heap is large and boundless, usually limited by only the physical memory available</li>\n<li>Variables are allocated and freed by using library functions or build-in language constructs</li>\n</ol>\n<ul>\n<li>C calls standard library functions, e.g. malloc, realloc, calloc and free</li>\n<li>C++ also uses these functions, but adds build-in operators new and delete</li>\n<li>Pointers are required to access data on the heap</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>Memory Allocation Example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"> <span class=\"type\">int</span> x;  <span class=\"comment\">// é™æ€å˜é‡ï¼Œå­˜å‚¨åœ¨é™æ€å†…å­˜åŒºï¼Œç”Ÿå‘½å‘¨æœŸä¸è¿›ç¨‹ç›¸åŒ</span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"type\">int</span> y;          <span class=\"comment\">// æ ˆå˜é‡</span></span><br><span class=\"line\">     <span class=\"type\">char</span> *str;      <span class=\"comment\">// æŒ‡å‘å †å†…å­˜çš„æŒ‡é’ˆ</span></span><br><span class=\"line\"> </span><br><span class=\"line\">     y = <span class=\"number\">4</span>;</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;stack memory: %d\\n&quot;</span>, y);</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"comment\">// åˆ†é… 100 ä¸ªå­—ç¬¦çš„å †å†…å­˜</span></span><br><span class=\"line\">     str = <span class=\"built_in\">malloc</span>(<span class=\"number\">100</span> * <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>));</span><br><span class=\"line\">     str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;m&#x27;</span>;</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;heap memory: %c\\n&quot;</span>, str[<span class=\"number\">0</span>]);</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"comment\">// é‡Šæ”¾åˆ†é…çš„å †å†…å­˜</span></span><br><span class=\"line\">     <span class=\"built_in\">free</span>(str);</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">// æ ˆä¸Šçš„å±€éƒ¨å˜é‡ y å’Œ str ä¼šåœ¨è¿™é‡Œè¢«è‡ªåŠ¨é‡Šæ”¾</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/28/671f7e7bed371.png\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Stack</th>\n<th>Heap</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Basic</strong></td>\n<td>Memory is allocated in a contiguous block</td>\n<td>Memory is allocated in any random order</td>\n</tr>\n<tr>\n<td><strong>Allocation and Deallocation</strong></td>\n<td>Automatic by compiler instructions</td>\n<td>Manual by programmer</td>\n</tr>\n<tr>\n<td><strong>Cost</strong></td>\n<td>Less</td>\n<td>More</td>\n</tr>\n<tr>\n<td><strong>Implementation</strong></td>\n<td>Hard</td>\n<td>Easy</td>\n</tr>\n<tr>\n<td><strong>Access time</strong></td>\n<td>Faster</td>\n<td>Slower</td>\n</tr>\n<tr>\n<td><strong>Main Issue</strong></td>\n<td>Shortage of memory</td>\n<td>Memory fragmentation</td>\n</tr>\n<tr>\n<td><strong>Locality of reference</strong></td>\n<td>Excellent</td>\n<td>Adequate</td>\n</tr>\n<tr>\n<td><strong>Flexibility</strong></td>\n<td>Fixed size</td>\n<td>Resizing is possible</td>\n</tr>\n<tr>\n<td><strong>Data type structure</strong></td>\n<td>Linear</td>\n<td>Hierarchical</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Heap buffer overflow\" class=\"active\"><a class=\"anchor\"  href=\"#Heap buffer overflow\">#</a>Heap buffer overflow</h1>\n<h2 id=\"Dereference\" class=\"active\"><a class=\"anchor\"  href=\"#Dereference\">#</a>Dereference</h2>\n<p>Much harder to exploit heap overflows:</p>\n<ul>\n<li>Heap memory is not flat or contiguous</li>\n<li>There is no return address saved on the heap</li>\n<li>The address to overwrite is hard to find</li>\n<li>General exploitation techniques manipulate the metadata used by memory allocator</li>\n</ul>\n<p>To read/write the value inside the memory address pointed to by the pointer</p>\n<figure class=\"highlight c\"><figcaption><span>Dereference a Pointer</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x; </span><br><span class=\"line\"> <span class=\"type\">int</span> *p; <span class=\"comment\">// p æ˜¯ä¸€ä¸ªæŒ‡å‘æ•´æ•°çš„æŒ‡é’ˆ  *p is an integer</span></span><br><span class=\"line\"> x = <span class=\"number\">0</span>;  <span class=\"comment\">// x ç°åœ¨ç­‰äº 0 </span></span><br><span class=\"line\"> p = &amp;x; <span class=\"comment\">// p æŒ‡å‘ x çš„åœ°å€   now *p == 0, since *p == x</span></span><br><span class=\"line\"> *p = <span class=\"number\">1</span>; <span class=\"comment\">// ç›¸å½“äº x = 1ï¼Œå› ä¸º p == &amp;x</span></span><br><span class=\"line\">\t     <span class=\"comment\">// ç°åœ¨ *p å’Œ x éƒ½ç­‰äº 1</span></span><br></pre></td></tr></table></figure>\n<p>A C-language structure is a basic data structure that holds multiple fields</p>\n<figure class=\"highlight c\"><figcaption><span>Dereference a Structure Pointer</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MY_STRUCT</span> &#123;</span> </span><br><span class=\"line\">     <span class=\"type\">int</span> my_int; </span><br><span class=\"line\">     <span class=\"type\">float</span> my_float; </span><br><span class=\"line\"> &#125; MY_STRUCT_T; </span><br><span class=\"line\"></span><br><span class=\"line\"> MY_STRUCT_T info = &#123;<span class=\"number\">1</span>, <span class=\"number\">3.141593F</span>&#125;; </span><br><span class=\"line\"> MY_STRUCT_T *instance = &amp;info; </span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">int</span> a = info.my_int;        <span class=\"comment\">// ä½¿ç”¨ &#x27;.&#x27; æ“ä½œç¬¦é€‰æ‹©å­—æ®µ</span></span><br><span class=\"line\"> <span class=\"type\">int</span> b = (*instance).my_int; <span class=\"comment\">// è§£å¼•ç”¨åé€‰æ‹©å­—æ®µ</span></span><br><span class=\"line\"> <span class=\"type\">int</span> c = instance-&gt;my_int;   <span class=\"comment\">// &#x27;-&gt;&#x27; æ˜¯å‰ä¸€ç§æƒ…å†µçš„è¯­æ³•ç³–</span></span><br></pre></td></tr></table></figure>\n<p>è®¿é—®ç»“æ„ä½“å­—æ®µçš„ä¸‰ç§æ–¹å¼ï¼š</p>\n<ul>\n<li><code>info.my_int</code> ï¼šä½¿ç”¨  <code>.</code>  æ“ä½œç¬¦ç›´æ¥è®¿é—®ç»“æ„ä½“å˜é‡  <code>info</code>  ä¸­çš„å­—æ®µ  <code>my_int</code> ã€‚è¿™æ˜¯æœ€ç®€å•çš„è®¿é—®æ–¹å¼ï¼Œå› ä¸º  <code>info</code>  æ˜¯ç»“æ„ä½“å˜é‡ï¼Œä¸æ˜¯æŒ‡é’ˆã€‚</li>\n<li><code>*instance</code> ï¼šè§£å¼•ç”¨æŒ‡é’ˆ  <code>instance</code> ï¼Œè·å–å®ƒæŒ‡å‘çš„ç»“æ„ä½“  <code>info</code> ã€‚ <code>(*instance)</code>  ä»£è¡¨ç»“æ„ä½“æœ¬èº«ã€‚<br>\n <code>(*instance).my_int</code> ï¼šåœ¨è§£å¼•ç”¨åä½¿ç”¨ <code>.</code>  æ“ä½œç¬¦è®¿é—®ç»“æ„ä½“å­—æ®µ  <code>my_int</code> ã€‚è¿™ç§æ–¹å¼ç›¸å½“äºå¯¹ info å˜é‡çš„ç›´æ¥è®¿é—®ï¼Œåªä¸è¿‡æ˜¯é€šè¿‡æŒ‡é’ˆæ¥å®Œæˆçš„ã€‚</li>\n<li><code>instance-&gt;my_int</code> ï¼š <code>-&gt;</code>  æ˜¯ä¸€ç§ç®€ä¾¿å†™æ³•ï¼ˆè¯­æ³•ç³–ï¼‰ï¼Œç”¨äºè®¿é—®æŒ‡é’ˆæŒ‡å‘çš„ç»“æ„ä½“çš„å­—æ®µã€‚è¿™ç›¸å½“äº  <code>(*instance).my_int</code> ï¼Œä½†å†™æ³•æ›´åŠ ç®€æ´ã€‚ <code>-&gt;</code>  åªèƒ½ç”¨äºæŒ‡é’ˆï¼Œè€Œ  <code>.</code>  ç”¨äºç›´æ¥çš„ç»“æ„ä½“å˜é‡ã€‚</li>\n</ul>\n<h2 id=\"Heap Overflow\" class=\"active\"><a class=\"anchor\"  href=\"#Heap Overflow\">#</a>Heap Overflow</h2>\n<ol>\n<li>Simple Heap Overflow</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>Simple Heap Overflow</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">target</span> &#123;</span></span><br><span class=\"line\">     <span class=\"type\">char</span> buf[<span class=\"number\">100</span>];        <span class=\"comment\">// æ˜“å—æ”»å‡»çš„ç¼“å†²åŒº</span></span><br><span class=\"line\">     <span class=\"type\">void</span> (*fun)(<span class=\"type\">char</span> *);  <span class=\"comment\">// å‡½æ•°æŒ‡é’ˆ</span></span><br><span class=\"line\"> &#125; <span class=\"type\">target_t</span>;</span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">foo</span><span class=\"params\">(<span class=\"type\">char</span> *buf)</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// ç›®æ ‡å‡½æ•°ï¼Œå¯èƒ½è¢«æ”»å‡»è€…æ§åˆ¶çš„æ•°æ®æ›¿æ¢</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> &#123;</span><br><span class=\"line\">     <span class=\"type\">target_t</span> *rec = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">target_t</span>)); <span class=\"comment\">// åŠ¨æ€åˆ†é…ç»“æ„ä½“å†…å­˜</span></span><br><span class=\"line\">     rec-&gt;fun = foo; <span class=\"comment\">// å°†å‡½æ•°æŒ‡é’ˆåˆå§‹åŒ–ä¸º foo</span></span><br><span class=\"line\">     gets(rec-&gt;buf); <span class=\"comment\">// æ˜“å—æ”»å‡»çš„å‡½æ•°ï¼Œå¯èƒ½å¯¼è‡´ç¼“å†²åŒºæº¢å‡º</span></span><br><span class=\"line\">     rec-&gt;fun(<span class=\"string\">&quot;test&quot;</span>); <span class=\"comment\">// è°ƒç”¨å‡½æ•°æŒ‡é’ˆ</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ç»“æ„ä½“å®šä¹‰</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">target</span> &#123;</span></span><br><span class=\"line\">     <span class=\"type\">char</span> buf[<span class=\"number\">100</span>];        <span class=\"comment\">// ç¼“å†²åŒº</span></span><br><span class=\"line\">     <span class=\"type\">void</span> (*fun)(<span class=\"type\">char</span> *);  <span class=\"comment\">// å‡½æ•°æŒ‡é’ˆ</span></span><br><span class=\"line\"> &#125; <span class=\"type\">target_t</span>;</span><br></pre></td></tr></table></figure>\n<p>ç»“æ„ä½“  <code>target</code>  åŒ…å«ä¸¤ä¸ªå­—æ®µï¼š<br>\n <code>buf</code> ï¼šä¸€ä¸ªå¤§å°ä¸º 100 å­—èŠ‚çš„å­—ç¬¦æ•°ç»„ï¼Œæ˜¯æ˜“å—æ”»å‡»çš„ç¼“å†²åŒºã€‚<br>\n <code>fun</code> ï¼šä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼ŒæŒ‡å‘æ¥å—ä¸€ä¸ªå­—ç¬¦æŒ‡é’ˆå‚æ•°çš„å‡½æ•°ã€‚</p>\n<ul>\n<li>ç¼“å†²åŒºæº¢å‡º</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gets(rec-&gt;buf);</span><br></pre></td></tr></table></figure>\n<p><code>gets()</code>  æ˜¯ä¸€ä¸ªå±é™©çš„å‡½æ•°ï¼Œå®ƒä»æ ‡å‡†è¾“å…¥è¯»å–æ•°æ®å¹¶å­˜å‚¨åˆ°æŒ‡å®šçš„ç¼“å†²åŒº  <code>buf</code>  ä¸­ã€‚<br>\n <code>gets()</code>  ä¸ä¼šæ£€æŸ¥è¾“å…¥æ•°æ®çš„é•¿åº¦ï¼Œå¦‚æœè¾“å…¥è¶…è¿‡äº†  <code>buf</code>  çš„ 100 å­—èŠ‚å¤§å°é™åˆ¶ï¼Œå°±ä¼šå¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚</p>\n<ul>\n<li>åˆ©ç”¨å †æº¢å‡º<br>\nå½“æ”»å‡»è€…æä¾›çš„è¾“å…¥é•¿åº¦è¶…è¿‡ 100 å­—èŠ‚æ—¶ï¼Œè¶…å‡ºçš„æ•°æ®å°†ä¼šè¦†ç›–  <code>fun</code>  å‡½æ•°æŒ‡é’ˆã€‚<br>\næ”»å‡»è€…å¯ä»¥åˆ©ç”¨è¿™ç§æƒ…å†µï¼Œå°†  <code>fun</code>  æŒ‡é’ˆé‡å†™ä¸ºæ”»å‡»è€…æ§åˆ¶çš„åœ°å€ï¼Œä»è€Œåœ¨ç¨‹åºä¸­æ‰§è¡Œä»»æ„ä»£ç ã€‚</li>\n</ul>\n<ol start=\"2\">\n<li>Difficult to Overwrite Non-Contiguous Memory<br>\nHeap buffers are not adjacent, there may some extra space</li>\n</ol>\n<ul>\n<li>It may be possible to calculate the extra space to craft an exploit</li>\n<li>But the exploit will be application-specific!\n<ol>\n<li>å †å†…å­˜çš„åˆ†æ•£æ€§\n<ul>\n<li>å †ä¸Šçš„ç¼“å†²åŒºå¹¶ä¸æ€»æ˜¯ç›¸é‚»çš„ï¼Œå› ä¸ºå®ƒä»¬æ ¹æ®å†…å­˜åˆ†é…å™¨çš„ç­–ç•¥è¿›è¡Œåˆ†é…ã€‚</li>\n<li>ä¸åŒåˆ†é…ä¹‹é—´å¯èƒ½å­˜åœ¨ç©ºéš™ï¼ˆpaddingï¼‰æˆ–å…ƒæ•°æ®ï¼ˆmetadataï¼‰ï¼Œä½¿å¾—ç›´æ¥è¦†ç›–éè¿ç»­å†…å­˜å˜å¾—å›°éš¾ã€‚</li>\n</ul>\n</li>\n<li>å†…å­˜åˆ†é…å™¨çš„å…ƒæ•°æ®\n<ul>\n<li>å †å†…å­˜ä¸­åˆ†é…çš„æ¯ä¸ªå—é€šå¸¸å¸¦æœ‰å…ƒæ•°æ®ï¼ˆå¦‚å¤§å°ã€çŠ¶æ€ã€æŒ‡å‘ä¸‹ä¸€ä¸ªå—çš„æŒ‡é’ˆç­‰ï¼‰ï¼Œç”¨äºç®¡ç†å†…å­˜å—çš„åˆ†é…å’Œé‡Šæ”¾ã€‚</li>\n<li>æ”»å‡»è€…åœ¨è¯•å›¾è¦†ç›–éè¿ç»­å†…å­˜æ—¶ï¼Œè¿˜éœ€è¦è€ƒè™‘è¿™äº›å…ƒæ•°æ®çš„å­˜åœ¨ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´åˆ†é…å™¨å´©æºƒæˆ–å¼‚å¸¸ï¼Œæš´éœ²æ”»å‡»çš„ç—•è¿¹ã€‚</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Heap Allocator\" class=\"active\"><a class=\"anchor\"  href=\"#Heap Allocator\">#</a>Heap Allocator</h2>\n<ol>\n<li>How heap memory is allocated?<br>\nHeap allocator maintains a <strong>doubly-linked list</strong> of allocated and free chunks (blocks of memory)\n<ul>\n<li><code>malloc()</code>  and  <code>free()</code>  add or remove chunks from this list<br>\nChunk management information is stored together with user data in memory</li>\n<li>Writing data past the end of a chunk boundary may overwrite the management fields</li>\n</ul>\n</li>\n<li>Chunk Record<br>\nHeap blocks are C records (i.e. struct) that have a few fields along with the chunk of memory\n<ul>\n<li>fd: the pointer to the next block</li>\n<li>bk: the pointer to the previous block</li>\n<li>ps: the size of the previous chunk</li>\n<li>sz: the size of the current chunk</li>\n<li>Other fields such as free flag to indicate if the current chunk is in the freelis</li>\n</ul>\n</li>\n<li>Unlink a Chunk<br>\n <code>free()</code>  removes a chunk from allocated list</li>\n</ol>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/28/671f8d584507c.png\" alt=\"img\"></p>\n<ul>\n<li>Unlink performs the following two writes on the listâ€™s fields:\n<ul>\n<li>chunk2â€&gt;bkâ€&gt;fd = chunk2â€&gt;fd</li>\n<li>chunk2â€&gt;fdâ€&gt;bk = chunk2â€&gt;bk</li>\n</ul>\n</li>\n<li>By overflowing  <code>chunk2</code> , attacker can take control of  <code>chunk2â€&gt;fd</code>  and  <code>chunk2â€&gt;bk</code></li>\n<li>Suppose the attacker wants to write  <code>value</code>  to memory address  <code>addr</code>\n<ul>\n<li>Attacker sets  <code>chunk2â€&gt;fd</code>  to be  <code>value</code></li>\n<li>Attacker sets  <code>chunk2â€&gt;bk</code>  to be  <code>(addr - offset_fd)</code>\n<ul>\n<li><code>offset_fd</code>  is the offset of the fd field in the record</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>The attacker can write arbitrary value to arbitrary memory address in this way</li>\n<li>The first unlink write achieves the attackerâ€™s goal:  <code>chunk2â€&gt;bkâ€&gt;fd = chunk2â€&gt;fd</code></li>\n<li>The first write effectively becomes:  <code>(addr - offset_fb)â€&gt;fd = value</code></li>\n<li>This is the same as  <code>*addr = value</code>\n<ul>\n<li>Fields are selected by offsets</li>\n<li><code>offset_fd</code>  cancels out  <code>fd</code> <br>\nAttackers can use hundreds of writes to copy the shellcode into memory</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Prevention\" class=\"active\"><a class=\"anchor\"  href=\"#Prevention\">#</a>Prevention</h2>\n<p>Very hard to detect and prevent due to the dynamic nature of the heap<br>\nPossible ways to protect against heap overflow</p>\n<ul>\n<li>Prevent execution of the payload by separating the code and data</li>\n<li>Introduce randomisation so the heap is not found at a fixed offset</li>\n<li>Introduce sanity checks into the heap allocator</li>\n</ul>\n<h1 id=\"Pointer-related heap errors \" class=\"active\"><a class=\"anchor\"  href=\"#Pointer-related heap errors \">#</a>Pointer-related heap errors </h1>\n<h2 id=\"Use After Free\" class=\"active\"><a class=\"anchor\"  href=\"#Use After Free\">#</a>Use After Free</h2>\n<ol>\n<li>A memory is accessed after it is freed (and re-allocated)\n<ul>\n<li>Can cause a program to crash, use unexpected values, or execute code</li>\n</ul>\n</li>\n<li>Attackers may overwrite the re-allocated memory including metadata\n<ul>\n<li>May result in the same effect as some heap overflow vulnerabilities</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>Use After Free Example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span> &#123; </span><br><span class=\"line\">    <span class=\"type\">char</span> *buf1, *buf2; </span><br><span class=\"line\">    buf1 = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(BUFSIZE1); <span class=\"comment\">// ä¸º buf1 åˆ†é… BUFSIZE1 å¤§å°çš„å†…å­˜</span></span><br><span class=\"line\">    <span class=\"comment\">// é‡Šæ”¾ buf1ï¼Œä½¿å…¶åˆ†é…çš„å†…å­˜å¯è¢«é‡ç”¨</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(buf1); </span><br><span class=\"line\">    <span class=\"comment\">// å¯èƒ½åœ¨ buf1 é‡Šæ”¾çš„å†…å­˜åŒºåŸŸå†…åˆ†é… buf2</span></span><br><span class=\"line\">    buf2 = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(BUFSIZE2); </span><br><span class=\"line\">    <span class=\"comment\">// æ”»å‡»è€…å¯èƒ½ä¼šé€šè¿‡è¦†ç›– buf2 åŠå…¶å…ƒæ•°æ®æ¥åˆ©ç”¨æ¼æ´</span></span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>(buf1, argv[<span class=\"number\">1</span>], BUFSIZE1<span class=\"number\">-1</span>); </span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Example Problems\n<ol>\n<li><code>free(buf1)</code>  çš„å½±å“\n<ul>\n<li>å½“  <code>buf1</code>  è¢«é‡Šæ”¾åï¼Œå…¶å¯¹åº”çš„å†…å­˜åŒºåŸŸå˜å¾—å¯ä¾›å†æ¬¡åˆ†é…ã€‚</li>\n<li>å› ä¸º  <code>free()</code>  å¹¶ä¸ä¼šç«‹å³å°†å†…å­˜æ¸…é›¶æˆ–ä½¿æŒ‡é’ˆå¤±æ•ˆï¼Œæ‰€ä»¥  <code>buf1</code>  ä»ç„¶æŒ‡å‘è¢«é‡Šæ”¾çš„å†…å­˜åŒºåŸŸã€‚</li>\n<li>åœ¨è¿™æ®µä»£ç ä¸­ï¼Œ <code>buf2</code>  å¯èƒ½ä¼šè¢«åˆ†é…åˆ°  <code>buf1</code>  é‡Šæ”¾çš„å†…å­˜åŒºåŸŸï¼ˆè¿™å–å†³äºå †åˆ†é…å™¨çš„å®ç°å’Œå†…å­˜å¸ƒå±€ï¼‰ã€‚</li>\n</ul>\n</li>\n<li><code>strncpy(buf1, argv[1], BUFSIZE1-1)</code>  çš„é—®é¢˜\n<ul>\n<li>å³ä½¿  <code>buf1</code>  å·²è¢«é‡Šæ”¾ï¼Œç¨‹åºä»ç„¶åœ¨æ­¤å¤„è¯•å›¾ä½¿ç”¨  <code>buf1</code>  è¿›è¡Œå†™æ“ä½œã€‚</li>\n<li>ç”±äº  <code>buf1</code>  è¢«é‡Šæ”¾åå¯èƒ½è¢«  <code>buf2</code>  é‡æ–°ä½¿ç”¨ï¼Œ <code>buf1</code>  å’Œ  <code>buf2</code>  å¯èƒ½æŒ‡å‘ç›¸åŒçš„å†…å­˜åŒºåŸŸã€‚è¿™æ„å‘³ç€é€šè¿‡  <code>strncpy()</code>  å¯¹  <code>buf1</code>  çš„å†™å…¥å¯èƒ½ä¼šå½±å“  <code>buf2</code> ï¼Œç”šè‡³è¦†ç›–  <code>buf2</code>  çš„å…ƒæ•°æ®ã€‚</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Double Free\" class=\"active\"><a class=\"anchor\"  href=\"#Double Free\">#</a>Double Free</h2>\n<ol>\n<li>A memory address is freed (i.e.  <code>free()</code> ) twice\n<ul>\n<li>Can also cause a program to crash, use unexpected values, or execute code</li>\n</ul>\n</li>\n<li>Attackers may corrupt metadata of new memory allocated at the address\n<ul>\n<li>May also result in the same effect as some heap overflow vulnerabilities</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>Double Free Example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span> &#123; </span><br><span class=\"line\">    <span class=\"type\">char</span> *buf1, *buf2; </span><br><span class=\"line\">    buf1 = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(BUFSIZE1);  <span class=\"comment\">// ä¸º buf1 åˆ†é… BUFSIZE1 å¤§å°çš„å†…å­˜</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(buf1);  <span class=\"comment\">// é‡Šæ”¾ buf1ï¼Œå†…å­˜å¯ä¾›é‡ç”¨</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf2 å¯èƒ½è¢«åˆ†é…åˆ° buf1 é‡Šæ”¾çš„å†…å­˜åŒºåŸŸ</span></span><br><span class=\"line\">    buf2 = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(BUFSIZE2);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf2 å¯èƒ½åŒ…å«æ”»å‡»è€…æä¾›çš„æ•°æ®</span></span><br><span class=\"line\">    <span class=\"built_in\">strncpy</span>(buf2, argv[<span class=\"number\">1</span>], BUFSIZE2<span class=\"number\">-1</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf1 è¢«å†æ¬¡é‡Šæ”¾ï¼ˆåŒé‡é‡Šæ”¾ï¼‰</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(buf1); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// é‡Šæ”¾ buf2ï¼ˆä½¿ç”¨äº†å¯èƒ½è¢«æ”»å‡»è€…ä¿®æ”¹çš„å…ƒæ•°æ®ï¼‰</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(buf2);  </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Example Problems\n<ol>\n<li>ç¬¬ä¸€æ¬¡é‡Šæ”¾  <code>buf1</code>\n<ul>\n<li>é€šè¿‡  <code>free(buf1)</code> ï¼Œ <code>buf1</code>  æ‰€å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾ï¼Œæˆä¸ºå¯ä¾›é‡ç”¨çš„å†…å­˜åŒºåŸŸã€‚</li>\n<li><code>buf2</code>  å¯èƒ½åˆ†é…åˆ°  <code>buf1</code>  çš„å†…å­˜åŒºåŸŸ</li>\n<li>å› ä¸º  <code>buf1</code>  å·²è¢«é‡Šæ”¾ï¼Œå†…å­˜åˆ†é…å™¨å¯èƒ½ä¼šå°†  <code>buf2</code>  åˆ†é…åˆ°ä¹‹å‰  <code>buf1</code>  å ç”¨çš„å†…å­˜åŒºåŸŸã€‚</li>\n<li>æ”»å‡»è€…å¯èƒ½é€šè¿‡è¦†ç›–  <code>buf2</code>  ä¸­çš„å†…å®¹æ¥ä¿®æ”¹å…ƒæ•°æ®</li>\n<li>ä½¿ç”¨  <code>strncpy()</code>  å‡½æ•°å°†ç”¨æˆ·è¾“å…¥å¤åˆ¶åˆ°  <code>buf2</code>  ä¸­ï¼Œè¿™å¯èƒ½å¯¼è‡´è¦†ç›–  <code>buf2</code>  çš„å…ƒæ•°æ®ï¼ˆå¦‚å †é“¾è¡¨æŒ‡é’ˆæˆ–å…¶ä»–å…³é”®æ•°æ®ï¼‰ã€‚</li>\n</ul>\n</li>\n<li>ç¬¬äºŒæ¬¡é‡Šæ”¾  <code>buf1</code>\n<ul>\n<li><code>free(buf1)</code>  å¯¼è‡´åŒé‡é‡Šæ”¾ï¼Œå› ä¸º  <code>buf1</code>  å·²ç»åœ¨ç¬¬ä¸€æ¬¡é‡Šæ”¾åè¢«é‡ç”¨ï¼Œç°åœ¨ä¸  <code>buf2</code>  æŒ‡å‘ç›¸åŒçš„å†…å­˜åŒºåŸŸã€‚</li>\n<li>æ­¤æ—¶ï¼Œå†…å­˜åˆ†é…å™¨å¯èƒ½ä¼šä½¿ç”¨è¢«æ”»å‡»è€…ä¿®æ”¹çš„å…ƒæ•°æ®ï¼Œä»è€Œå¯¼è‡´ä¸å®‰å…¨çš„å†…å­˜æ“ä½œã€‚</li>\n</ul>\n</li>\n<li>é‡Šæ”¾  <code>buf2</code>\n<ul>\n<li>å½“  <code>buf2</code>  è¢«é‡Šæ”¾æ—¶ï¼Œå†…å­˜åˆ†é…å™¨å¯èƒ½ä¼šå†æ¬¡å¤„ç†è¢«æ”»å‡»è€…ä¿®æ”¹çš„å…ƒæ•°æ®ï¼Œè¿›ä¸€æ­¥å¯¼è‡´å†…å­˜è¦†ç›–æˆ–å¼‚å¸¸ã€‚</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Prevention and Detection of Pointer Errors\" class=\"active\"><a class=\"anchor\"  href=\"#Prevention and Detection of Pointer Errors\">#</a>Prevention and Detection of Pointer Errors</h2>\n<ol>\n<li>Difficult to detect all of them by either dynamic or static analysis</li>\n</ol>\n<ul>\n<li>Complex runtime states</li>\n<li>E.g. memory may be allocated, freed and used in different functions via aliases (pointers)</li>\n<li>Fuzzing may detect some in executed paths when they crash the program</li>\n</ul>\n<ol start=\"2\">\n<li>The simplest prevention is to set all freed pointers to NULL</li>\n</ol>\n<ul>\n<li>Trigger null pointer dereference errors when accessed</li>\n<li>Most operating systems provide built-in defence against null-pointer dereference</li>\n</ul>\n",
            "tags": [
                "C",
                "software security"
            ]
        },
        {
            "id": "http://example.com/course/AFL/",
            "url": "http://example.com/course/AFL/",
            "title": "AFL",
            "date_published": "2024-10-28T04:45:49.000Z",
            "content_html": "<h1 id=\"American Fuzzy Lop\" class=\"active\"><a class=\"anchor\"  href=\"#American Fuzzy Lop\">#</a> American Fuzzy Lop</h1>\n<h2 id=\"Definition\" class=\"active\"><a class=\"anchor\"  href=\"#Definition\">#</a>Definition</h2>\n<ol>\n<li>A security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. Currently state-of-the-practice at fuzzing (together with forks)</li>\n</ol>\n<ul>\n<li>A type of coverage-based fuzzing: Instrument target programs to track test coverage</li>\n<li>A type of evolutionary/genetic fuzzing: Attempt to generate inputs based on the response of the program</li>\n</ul>\n<ol start=\"2\">\n<li>Why AFL</li>\n</ol>\n<ul>\n<li>The best general purpose fuzzer\n<ul>\n<li>For C/C++/Objective C programs</li>\n</ul>\n</li>\n<li>Effective and well-engineered with lots of heuristics\n<ul>\n<li>Fast â€“ lots of test cases per second</li>\n<li>Clever â€“ test cases are well chosen</li>\n<li>Easy to use (Linux and other platforms)</li>\n</ul>\n</li>\n<li>Deliver out-of-the-box performance far superior to mutation fuzzing or coverage-only tools</li>\n</ul>\n<ol start=\"3\">\n<li>AFL Approach\n<ol>\n<li>Load user-supplied initial test cases into the queue</li>\n<li>Take next input file from the queue</li>\n<li>Attempt to trim the test case to the smallest size</li>\n<li>Repeatedly mutate the file using traditional fuzzing strategies</li>\n<li>If any of the generated mutations resulted in a new state transition recorded by the instrumentation, add mutated output as a new entry in the queue</li>\n<li>Go to 2<br>\n<img data-src=\"https://img.picui.cn/free/2024/10/28/671f221b5c7ee.png\" alt=\"img\"></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Fuzzing Through AFL\" class=\"active\"><a class=\"anchor\"  href=\"#Fuzzing Through AFL\">#</a>Fuzzing Through AFL</h2>\n<ol>\n<li>Instrumenting Programs for AFL<br>\nCompile through AFL wrappers to generate an instrumented executable for fuzzing\n<ul>\n<li>Basically, replace  <code>gcc</code>  with  <code>aflâ€gcc</code>  or  <code>afl-clang</code></li>\n<li>For simple compilation,  <code>aflâ€gcc test.c â€o test</code> <br>\nFor larger projects that use the make build system, add to the Makefile:</li>\n<li><code>CC=path-to/afl-gcc</code>  or  <code>CC=path-to/afl-clang</code></li>\n<li>This allows to build instrumented target program with the AFL wrappers<br>\nFor C++ code, use the C++ wrappers  <code>afl-g++</code>  or  <code>afl-clang++</code></li>\n<li>For example in the Makefile:  <code>CXX=path-to/afl-g++</code>  or  <code>CXX=path-to/afl-clang++</code> <br>\nAFL ä¼šåœ¨ç¼–è¯‘æ—¶æ’è£…ç›®æ ‡ç¨‹åºçš„ä»£ç ï¼Œä»¥ä¾¿åœ¨æ‰§è¡ŒæœŸé—´è·Ÿè¸ªè·¯å¾„è¦†ç›–æƒ…å†µã€‚æ’è£…åçš„äºŒè¿›åˆ¶æ–‡ä»¶åŒ…å«å¯¹ <code> __afl_maybe_log</code>  çš„è°ƒç”¨ï¼Œè¯¥å‡½æ•°è®°å½•ç¨‹åºçš„æ‰§è¡ŒçŠ¶æ€ã€‚</li>\n</ul>\n</li>\n<li>Fuzzing Through AFL</li>\n</ol>\n<ul>\n<li>Start fuzzing with AFL   <code>aflâ€fuzz â€i testcase â€o output ./test @@</code></li>\n<li>Test cases are under testcase</li>\n<li>The output produced by  goes to the output directory</li>\n<li>The special symbols  <code>@@</code>  tell AFL to take the file names under test case and feed it to test. Not needed if the program takes input from stdin</li>\n<li>Other common options:\n<ul>\n<li><code>-t</code>  sets timeout for the executed process</li>\n<li><code>-m</code>  sets memory limit for the executed process</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Initial Test Cases<br>\nDonâ€™t waste too much time trying to synthesise your targetâ€™s input format<br>\nFind some real inputs that exercise as much of the target as possible<br>\nFrom the AFL user guide:\n<ul>\n<li>Keep the files small. Under 1 kB is ideal, although not strictly necessary</li>\n<li>Use multiple test cases only if they are functionally different from each other</li>\n</ul>\n</li>\n<li>When To Stop</li>\n</ol>\n<ul>\n<li>Never, as fuzzing is part of continuous integration</li>\n<li>hen the  <code>cycles counter</code>  is green\n<ul>\n<li>Last new path was found many cycles ago</li>\n<li>Pending paths is zero</li>\n</ul>\n</li>\n<li>When the cycles counter is blue\n<ul>\n<li>Last new path was found over a cycle ago</li>\n</ul>\n</li>\n<li>If you want to stop earlier, press Ctrl-C\n<ul>\n<li>E.g. itâ€™s been running for a while (hours + millions of executions + at least 2 cycles</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>AFL Output</li>\n</ol>\n<ul>\n<li>File  <code>fuzzer_stats</code>  provides summary of stats UI</li>\n<li>File  <code>plot_data</code>  shows the progress of fuzzer</li>\n<li>Directory  <code>queue</code>  shows inputs that led to paths</li>\n<li>Directory  <code>crashes</code>  contains input that caused crash</li>\n<li>Directory  <code>hangs</code>  contains input that caused hang</li>\n</ul>\n<ol start=\"6\">\n<li>AFL Crashes<br>\nUnique if the associated execution paths involve any state transitions not seen previously. A single bug may be reached in multiple ways, but AFL can usually recognise<br>\nCrashes may be caused by failed assertions - as they abort</li>\n</ol>\n<h1 id=\"Compiler-supported sanitizers\" class=\"active\"><a class=\"anchor\"  href=\"#Compiler-supported sanitizers\">#</a>Compiler-supported sanitizers</h1>\n<ol>\n<li>Sanitisers å’ŒåŠ å›ºæªæ–½</li>\n</ol>\n<ul>\n<li>Sanitisersï¼ˆå†…å­˜æ¸…ç†å™¨ï¼‰ï¼šé€šè¿‡åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­æ’å…¥é¢å¤–çš„ä»£ç ï¼Œæ£€æŸ¥ä¸è‰¯çš„è¿è¡Œæ¡ä»¶ã€‚æé«˜æ¨¡ç³Šæµ‹è¯•æ•ˆæœã€‚</li>\n<li>Common compiler-supported sanitisers: ASan, MSan, UBSan, TSan</li>\n<li>åŠ å›ºé€‰é¡¹ï¼šä½¿å†…å­˜é”™è¯¯çš„æ£€æµ‹æ›´å®¹æ˜“ã€‚ <code>AFL_HARDEN=1</code> ï¼šAFL çš„ç¡¬åŒ–é€‰é¡¹ï¼Œç”¨äºæ£€æµ‹æ›´å¤šçš„å†…å­˜é”™è¯¯ã€‚</li>\n<li>æ³¨æ„ï¼šSanitisers é€šå¸¸ä¸å…¼å®¹ï¼Œå› æ­¤å»ºè®®ï¼š\n<ul>\n<li>å¤§å¤šæ•°æ¨¡ç³Šæµ‹è¯•è¿è¡Œæ—¶å¯ç”¨  <code>AFL_HARDEN</code> ã€‚</li>\n<li>å°éƒ¨åˆ†æµ‹è¯•è¿è¡Œæ—¶åˆ†åˆ«å¯ç”¨æ¯ä¸ª Sanitisersï¼Œä»¥è¦†ç›–ä¸åŒç±»å‹çš„å†…å­˜é”™è¯¯ã€‚</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>ASanï¼ˆAddress Sanitizerï¼‰Compile with  <code>-fsanitize=address</code> <br>\n æ£€æµ‹å†…å®¹ï¼š\n<ul>\n<li>å †ã€æ ˆå’Œå…¨å±€å˜é‡çš„è¶Šç•Œè®¿é—®ã€‚</li>\n<li>Use-after-freeã€double-freeã€invalid freeã€‚</li>\n<li>å†…å­˜æ³„æ¼ã€‚</li>\n</ul>\n</li>\n</ol>\n<p>æ€§èƒ½å½±å“ï¼šå¤§çº¦ 2 å€çš„è¿è¡Œæ—¶é—´å¼€é”€ã€‚</p>\n<figure class=\"highlight c\"><figcaption><span>ASan Example1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 10 </span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"type\">char</span> s[N] = <span class=\"string\">&quot;123456789&quot;</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= N; i++) </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, s[i]); </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>Loop bound goes past the end of the array, cannot assess  <code>s[10]</code></p>\n <figure class=\"highlight c\"><figcaption><span>ASan Example2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"type\">int</span> *a = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * <span class=\"number\">100</span>); </span><br><span class=\"line\">     <span class=\"built_in\">free</span>(a); </span><br><span class=\"line\">     <span class=\"keyword\">return</span> a[<span class=\"number\">5</span>]; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>The array is dereferenced after it is free</p>\n <figure class=\"highlight c\"><figcaption><span>ASan Example3</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"type\">char</span> *s = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>) * <span class=\"number\">10</span>); </span><br><span class=\"line\">     <span class=\"built_in\">free</span>(s); </span><br><span class=\"line\">     <span class=\"built_in\">free</span>(s);</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>, s);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>The array is double-freed</p>\n<ol start=\"3\">\n<li>MSanï¼ˆMemory Sanitizerï¼‰ Compile with  <code>-fsanitize=memory</code> <br>\n æ£€æµ‹æœªåˆå§‹åŒ–çš„å†…å­˜ä½¿ç”¨ã€‚<br>\næ€§èƒ½å½±å“ï¼šå¤§çº¦ 3 å€çš„è¿è¡Œæ—¶é—´å¼€é”€ã€‚</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>MSan Example1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"type\">int</span> a[<span class=\"number\">10</span>]; </span><br><span class=\"line\">     a[<span class=\"number\">2</span>] = <span class=\"number\">0</span>; </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (a[argc]) </span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;print something\\n&quot;</span>); </span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>The array is allocated on <strong>stack</strong>, but only partially initialised</p>\n <figure class=\"highlight c\"><figcaption><span>MSan Example2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"type\">int</span> a = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * <span class=\"number\">10</span>);</span><br><span class=\"line\">     a[<span class=\"number\">2</span>] = <span class=\"number\">0</span>; </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (a[argc]) </span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;print something\\n&quot;</span>); </span><br><span class=\"line\">     <span class=\"built_in\">free</span>(a); </span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>The array is allocated on <strong>heap</strong>, but only partially initialised</p>\n<ol start=\"4\">\n<li>UBSanï¼ˆUndefined Behavior Sanitizerï¼‰ Compile with  <code>-fsanitize=undefined</code> <br>\n æ£€æµ‹ï¼š\n<ul>\n<li>è§£å¼•ç”¨ç©ºæŒ‡é’ˆã€‚</li>\n<li>æœ‰ç¬¦å·æ•´æ•°æº¢å‡ºã€‚<br>\næ€§èƒ½å½±å“ï¼šå¤§çº¦ 20% çš„è¿è¡Œæ—¶é—´å¼€é”€ã€‚</li>\n</ul>\n</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>UBSan Example1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"type\">int</span> n = <span class=\"number\">65</span>; </span><br><span class=\"line\">     <span class=\"type\">int</span> m = n / (n - n); </span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>Division-by-zero is undefined</p>\n <figure class=\"highlight c\"><figcaption><span>UBSan Example2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">foo</span> </span></span><br><span class=\"line\"><span class=\"class\"> &#123;</span> </span><br><span class=\"line\">     <span class=\"type\">int</span> a, b; </span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">foo</span> *<span class=\"title\">x</span> =</span> <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">     <span class=\"type\">int</span> m = x-&gt;a;  <span class=\"comment\">// è®¿é—®ç©ºæŒ‡é’ˆ</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>Accessing a null pointer is undefined</p>\n<ol start=\"5\">\n<li>TSanï¼ˆThread Sanitizerï¼‰<br>\næ£€æµ‹æ•°æ®ç«äº‰ï¼ˆdata racesï¼‰ã€‚<br>\næ€§èƒ½å½±å“ï¼šè¿è¡Œæ—¶é—´å¼€é”€çº¦ä¸º 5-15 å€ï¼Œå†…å­˜å¼€é”€çº¦ä¸º 5-10 å€ã€‚</li>\n</ol>\n<h1 id=\"Others\" class=\"active\"><a class=\"anchor\"  href=\"#Others\">#</a>Others</h1>\n<ol>\n<li>\n<p>Parallel Fuzzing(High performance fuzzing)<br>\nRun concurrent fuzzing jobs on multicore systems</p>\n<ul>\n<li>One master instance, one slave per core</li>\n<li>Use the afl-gotcpu tool to measure per-core pre-emption rate<br>\nRun the master (-M) like this:</li>\n<li><code>./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01</code> <br>\nThen, run the slaves (-S) instances like this:</li>\n<li><code>./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02</code></li>\n<li><code>./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03</code></li>\n</ul>\n</li>\n<li>\n<p>Fuzzer Dictionaries(Improve fuzzer mutations)<br>\nBy default, AFL mutation engine is optimised for compact data formats<br>\nCustom dictionaries can help the fuzzer access paths it otherwise wouldnâ€™t  <code>afl-fuzz -x mydict</code> <br>\nGet them from:</p>\n<ul>\n<li><code>dictionaries</code>  directory in AFL</li>\n<li><code>libtokencap</code>  directory in AFL\n<ul>\n<li>Create a dictionary by intercepting calls like  <code>strcmp</code>  and  <code>memcmp</code></li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy8rL21hc3Rlci90ZXN0aW5nL2xpYmZ1enplci9mdXp6ZXJzL2RpY3Rz\">Online resource</span></li>\n</ul>\n</li>\n<li>\n<p>Limitations of Fuzzing</p>\n</li>\n</ol>\n<ul>\n<li>Hard to tell when to stop</li>\n<li>Test the target in the exact configuration you provided, on the input source you set up</li>\n<li>Can get stuck (e.g. checksums)</li>\n<li>Crashes only (typical of most fuzzers). Only notice problems that can be automatically detected</li>\n<li>Need to build target from source</li>\n<li>stdin or file input only</li>\n<li>Coverage-based instrumentation wonâ€™t guide it towards all crashes\n<ul>\n<li><code>x = 1/(input â€“ 1234)</code>  ï¼šåœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒAFL å¯èƒ½éš¾ä»¥æ‰¾åˆ°è¾“å…¥ 1234ï¼Œä»è€Œå¯¼è‡´æ— æ³•æ£€æµ‹åˆ°é™¤é›¶é”™è¯¯ã€‚</li>\n</ul>\n</li>\n<li>No automatic parallelisation</li>\n<li>Linux/macOS only</li>\n</ul>\n<ol start=\"4\">\n<li>libFuzzer: Guided Fuzzing for APIs<br>\nThe other top general purpose fuzzer\n<ul>\n<li>Use similar algorithms to AFL</li>\n<li>Build it with special compiler instrumentation (LLVM)<br>\nTargets functions rather than programs</li>\n<li>Testers have to write a harness</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "C",
                "software security",
                "AFL",
                "Linux"
            ]
        },
        {
            "id": "http://example.com/course/Format-string-bugs/",
            "url": "http://example.com/course/Format-string-bugs/",
            "title": "Format string bugs",
            "date_published": "2024-10-26T11:52:22.000Z",
            "content_html": "<h1 id=\"Format Functions\" class=\"active\"><a class=\"anchor\"  href=\"#Format Functions\">#</a>Format Functions</h1>\n<ol>\n<li>Format Functions</li>\n</ol>\n<ul>\n<li><code>printf</code>  Output a formatted string</li>\n<li><code>fprintf</code>  Writes the printf to a file</li>\n<li><code>sprintf</code>  Prints into a string</li>\n<li><code>snprintf</code>  Prints into a string checking the length</li>\n<li><code>vprintf</code>  Prints the argument list to stdout</li>\n<li><code>vfprintf</code>  Prints the argument list to a file</li>\n<li><code>vsprintf</code>  Prints the argument list to a string</li>\n<li><code>vsnprintf</code>  Prints the argument to a string checking the length<br>\n æ€»ç»“ï¼š <code>printf</code>  å’Œ  <code>fprintf</code>  ç”¨äºè¾“å‡ºæ ¼å¼åŒ–å­—ç¬¦ä¸²åˆ°æ ‡å‡†è¾“å‡ºæˆ–æ–‡ä»¶ã€‚<br>\n <code>sprintf</code>  å’Œ  <code>snprintf</code>  ç”¨äºå°†æ ¼å¼åŒ–å­—ç¬¦ä¸²å†™å…¥å­—ç¬¦ä¸²ç¼“å†²åŒºï¼Œ <code>snprintf</code>  æ›´å®‰å…¨ã€‚<br>\n <code>vprintf</code> ã€ <code>vfprintf</code> ã€ <code>vsprintf</code>  å’Œ  <code>vsnprintf</code>  ç”¨äºå¤„ç†å¯å˜å‚æ•°åˆ—è¡¨ï¼Œä¸å‰é¢çš„å‡½æ•°ç±»ä¼¼ï¼Œä½†ä¸“é—¨ç”¨äº  <code>va_list</code>  å‚æ•°çš„å¤„ç†ã€‚</li>\n</ul>\n<ol start=\"2\">\n<li>Format Strings</li>\n</ol>\n<ul>\n<li>Format String is the argument of format functions that contains format parameters. Format parameters are placeholders to be replaced with user inputs</li>\n<li>For example, the statement will output different sentences, depending on what is contained in the variable name:  <code>printf(&quot;Hello, %s.&quot;, &amp;name);</code></li>\n<li>If the variable name contains the string â€œZzâ€, then  <code>printf()</code>  will output: Hello, Zz.</li>\n</ul>\n<ol start=\"3\">\n<li>Common Parameters Used in Format String Attacks</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>å‚æ•°</th>\n<th>æè¿°</th>\n<th>ä¼ é€’æ–¹å¼</th>\n<th>åœ¨æ”»å‡»ä¸­çš„ä½œç”¨</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%s</td>\n<td>æ‰“å°å­—ç¬¦ä¸²</td>\n<td>å¼•ç”¨ï¼ˆæŒ‡å‘å­—ç¬¦ä¸²çš„æŒ‡é’ˆï¼‰</td>\n<td>æ”»å‡»è€…å¯ä»¥åˆ©ç”¨ % s æ‰“å°å‡ºå†…å­˜ä¸­çš„ä»»æ„æ•°æ®ï¼Œé€šè¿‡æä¾›ç‰¹å®šçš„å†…å­˜åœ°å€ï¼Œè¯»å–æ•æ„Ÿæ•°æ®ï¼ˆå¦‚å¯†ç ã€å¯†é’¥ç­‰ï¼‰ã€‚</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>æ‰“å°æœ‰ç¬¦å·åè¿›åˆ¶æ•´æ•°</td>\n<td>æ•´æ•°å€¼</td>\n<td>è™½ç„¶ % d é€šå¸¸ç”¨äºæ•´æ•°æ˜¾ç¤ºï¼Œä½†æ”»å‡»è€…å¯ä»¥é€šè¿‡å®ƒæ¥æ³„éœ²å†…å­˜ä¸­çš„æ•´æ•°å€¼ã€‚</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>æ‰“å°æ— ç¬¦å·åè¿›åˆ¶æ•´æ•°</td>\n<td>æ— ç¬¦å·æ•´æ•°å€¼</td>\n<td>ä¸ % d ç±»ä¼¼ï¼Œä½†ç”¨äºæ— ç¬¦å·æ•´æ•°çš„æ˜¾ç¤ºã€‚</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>æ‰“å°åå…­è¿›åˆ¶æ•´æ•°ï¼ˆå°å†™ï¼‰</td>\n<td>æ— ç¬¦å·æ•´æ•°å€¼</td>\n<td>æ”»å‡»è€…å¯ä»¥é€šè¿‡ % x é€æ­¥è¯»å–å†…å­˜ï¼Œä»¥åå…­è¿›åˆ¶æ˜¾ç¤ºåœ°å€ä¸­çš„æ•°æ®å†…å®¹ã€‚</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>æ‰“å°å•ä¸ªå­—ç¬¦</td>\n<td>å­—ç¬¦å€¼</td>\n<td>ç”¨äºæ˜¾ç¤ºå•ä¸ªå­—ç¬¦ï¼Œä½†åœ¨æ”»å‡»ä¸­ç”¨é€”æœ‰é™ã€‚</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>å°†å·²æ‰“å°çš„å­—ç¬¦æ•°å†™å…¥æŒ‡å®šå˜é‡</td>\n<td>å¼•ç”¨ï¼ˆæŒ‡å‘æ•´æ•°çš„æŒ‡é’ˆï¼‰</td>\n<td>æ”»å‡»è€…å¯ä»¥åˆ©ç”¨ % n ä¿®æ”¹ä»»æ„å†…å­˜åœ°å€çš„å€¼ï¼Œè¿™æ˜¯æ ¼å¼å­—ç¬¦ä¸²æ”»å‡»ä¸­æœ€å±é™©çš„å‚æ•°ä¹‹ä¸€ï¼Œå¯èƒ½è¢«ç”¨æ¥ä¿®æ”¹ç¨‹åºçš„æ§åˆ¶æµã€‚</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>æ‰“å° % å­—ç¬¦</td>\n<td>æ— </td>\n<td>ç”¨äºè¾“å‡º % å­—ç¬¦ï¼Œæ— ç‰¹åˆ«çš„æ”»å‡»ä»·å€¼ã€‚</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li>How Do Format Functions Work?<br>\nAccording to the data format dictated by the format parameters, format functions retrieve the arguments from the stack</li>\n</ol>\n<ul>\n<li>printf(â€œA is the number %d, B is the string %sâ€, A, &amp;B);<br>\nThe  <code>printf()</code>  function will attempt to retrieve the value of A and the address of string B from the stack<br>\n åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²ä¸­ï¼Œæ¯ä¸ªæ ¼å¼å‚æ•°ï¼ˆå¦‚  <code>%d</code> ã€ <code>%s</code> ï¼‰éƒ½å‘Šè¯‰  <code>printf()</code>  å¦‚ä½•è§£é‡Šæ ˆä¸­çš„æ•°æ®ï¼š <code>%d</code>  è¡¨ç¤ºæ£€ç´¢ä¸€ä¸ª æ•´æ•°å€¼ã€‚ <code>%s</code>  è¡¨ç¤ºæ£€ç´¢ä¸€ä¸ª å­—ç¬¦ä¸²æŒ‡é’ˆï¼ˆåœ°å€ï¼‰ï¼Œç„¶åæ ¹æ®åœ°å€æ‰“å°å¯¹åº”çš„å­—ç¬¦ä¸²ã€‚</li>\n</ul>\n<h1 id=\"Exploit\" class=\"active\"><a class=\"anchor\"  href=\"#Exploit\">#</a>Exploit</h1>\nThe vulnerability occurs when there is a mismatch between the number of format parameters and the number of function arguments provided to fill those places \n- For example, if an attacker is able to supply more placeholders than there are arguments, he/she can use format functions to read or write the stack! \nFormat functions can be exploited when an attacker is given direct control over the format string fed into the function\n<ol>\n<li>Reading Data from Stack</li>\n</ol>\n<ul>\n<li>printf(&quot;A is the number  <code>%d</code> , reading stack data:  <code>%x</code> &quot;, A);\n<ul>\n<li><code>printf()</code>  will attempt to retrieve two values from the stack</li>\n<li>But only one of those is placed on the stack</li>\n<li><code>printf()</code>  will retrieve the next value on the stack and display it in hex format!</li>\n</ul>\n</li>\n<li>To print the next 20 items on the stack:\n<ul>\n<li>printf(&quot;%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x&quot;);</li>\n</ul>\n</li>\n<li>To print the tenth element next on the stack:\n<ul>\n<li>printf(&quot;%10$x&quot;);</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Reading Data at Arbitrary Location  <code>%s</code></li>\n</ol>\n<ul>\n<li>Format functions treat the data on the stack as an address to go fetch a string\n<ul>\n<li>Note that  <code>%s</code>  is passed as reference!</li>\n</ul>\n</li>\n<li>How to control the address accessed by  <code>%s</code> ?\n<ul>\n<li>Place an address on the format string (the string is stored on stack)</li>\n<li>Get  <code>%s</code>  to dereference it!</li>\n</ul>\n</li>\n<li>To print the string located at address 0x12345678:\n<ul>\n<li>printf(&quot;\\x78\\x56\\x34\\x12%x%x%x%s&quot;, A, B, C);</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Writing Data at Arbitrary Location  <code>%n</code></li>\n</ol>\n<ul>\n<li><code>%n</code>  stores the number of characters written so far into the corresponding function argument! For example, the following code put the integer 5 into the variable  <code>num_char</code></li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num_char; </span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;11111%n&quot;</span>, &amp;num_char); </span><br></pre></td></tr></table></figure>\n<p>With width-controlling format parameters, the attacker can write arbitrary integers to the location pointed to by the function argument</p>\n<ul>\n<li>Write 10 to num_char using width-controlling format parameter</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num_char; </span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%10d%n&quot;</span>, <span class=\"number\">0</span>, &amp;num_char);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Control the amount of data written with length parameter\n<ul>\n<li><code>printf(&quot;%10d%hn&quot;, 0, &amp;num_char);</code></li>\n<li>Writes 2 bytes (instead of 4 bytes) to  <code>&amp;num_char</code></li>\n</ul>\n</li>\n<li>Combined with the trick to access arbitrary memory locations, the attacker can write to arbitrary memory locations</li>\n</ul>\n<ol start=\"4\">\n<li>Example</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"type\">char</span> buf[<span class=\"number\">512</span>]; </span><br><span class=\"line\">     fgets(buf, <span class=\"keyword\">sizeof</span>(buf), <span class=\"built_in\">stdin</span>); <span class=\"comment\">// å®‰å…¨è¯»å–è¾“å…¥ï¼Œä¸ä¼šå¯¼è‡´ç¼“å†²åŒºæº¢å‡º</span></span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The input is:&quot;</span>); </span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(buf);  <span class=\"comment\">// å­˜åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\"> &#125; </span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>printf(buf);</code>  ç›´æ¥ä½¿ç”¨äº†ç”¨æˆ·è¾“å…¥çš„å†…å®¹ä½œä¸ºæ ¼å¼åŒ–å­—ç¬¦ä¸²ã€‚å¦‚æœ  <code>buf</code>  ä¸­åŒ…å«æ ¼å¼åŒ–å ä½ç¬¦ï¼ˆå¦‚  <code>%s</code> ã€ <code>%x</code> ã€ <code>%n</code>  ç­‰ï¼‰ï¼Œ <code>printf()</code>  ä¼šå°†å…¶è§£é‡Šä¸ºæ ¼å¼åŒ–æŒ‡ä»¤ï¼Œä»è€Œé€ æˆå®‰å…¨éšæ‚£ã€‚</li>\n<li>ä¿®å¤ï¼š  <code>printf(&quot;The input is: %s&quot;, buf);</code> ï¼š% s ç¡®ä¿è¾“å…¥å†…å®¹è¢«å½“ä½œæ™®é€šå­—ç¬¦ä¸²å¤„ç†ï¼Œè€Œä¸æ˜¯æ ¼å¼åŒ–å­—ç¬¦ä¸²</li>\n</ul>\n<h1 id=\"Denial of Service Attacks\" class=\"active\"><a class=\"anchor\"  href=\"#Denial of Service Attacks\">#</a>Denial of Service Attacks</h1>\n<ul>\n<li>\n<p>Crash the program by attempting to access an invalid address</p>\n<ul>\n<li>Use  <code>%s</code>  to retrieve a value from the stack till encountering an invalid memory location</li>\n</ul>\n</li>\n<li>\n<p>The exploit string would look something like this</p>\n<ul>\n<li>Â·printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;);Â·</li>\n</ul>\n</li>\n<li>\n<p>The more %s used in the format string, the higher the chance of an invalid address</p>\n</li>\n</ul>\n<h1 id=\"Format String Attacks Prevention\" class=\"active\"><a class=\"anchor\"  href=\"#Format String Attacks Prevention\">#</a>Format String Attacks Prevention</h1>\n<ol>\n<li>Hard-coded format strings (e.g. no  <code>printf(arg)</code> )</li>\n<li>Do not use the fancy  <code>%n</code></li>\n<li>Be careful with pass as references</li>\n</ol>\n<ul>\n<li>e.g.  <code>%s</code>  and  <code>sprintf</code>  can be used to create disclosure attacks</li>\n</ul>\n<ol start=\"4\">\n<li>Compiler support to match  <code>printf</code>  arguments with format string</li>\n</ol>\n<ul>\n<li>e.g. the  <code>gcc</code>  compiler provides options to check format strings</li>\n</ul>\n",
            "tags": [
                "C",
                "software security",
                "vulnerability"
            ]
        },
        {
            "id": "http://example.com/course/Integer-overflow/",
            "url": "http://example.com/course/Integer-overflow/",
            "title": "Integer overflow",
            "date_published": "2024-10-26T10:33:32.000Z",
            "content_html": "<h1 id=\"Integer overflow\" class=\"active\"><a class=\"anchor\"  href=\"#Integer overflow\">#</a>Integer overflow</h1>\n When the result of an integer operation does not fit within the allocated memory space. All common languages are affected \n<ol>\n<li>How Does an Integer Overflow Happen?\n<ol>\n<li>æ— ç¬¦å·æ•´æ•°æº¢å‡ºï¼šä¾‹å¦‚ï¼Œä¸€ä¸ª 32 ä½æ— ç¬¦å·æ•´æ•°çš„èŒƒå›´æ˜¯ 0 åˆ° 4,294,967,295ï¼ˆå³ 2**32 âˆ’ 1 æˆ– 0xffffffffï¼‰ã€‚å¦‚æœæˆ‘ä»¬æ‰§è¡Œè®¡ç®— 4,294,967,295 + 1ï¼Œåˆ™ä¼šå¯¼è‡´æº¢å‡ºï¼Œå› ä¸ºç»“æœè¶…å‡ºäº†æ— ç¬¦å·æ•´æ•°çš„èŒƒå›´</li>\n<li>æœ‰ç¬¦å·æ•´æ•°æº¢å‡º</li>\n</ol>\n<ul>\n<li>ç¬¦å·ä½çš„æº¢å‡º<br>\nå½“ä¸€ä¸ªæ•´æ•°è¿ç®—çš„ç»“æœè¶…è¿‡æœ‰ç¬¦å·æ•´æ•°çš„èŒƒå›´æ—¶ï¼Œç¬¦å·ä½ï¼ˆæœ€é«˜ä½ï¼‰å¯èƒ½ä¼šè¢«è¦†ç›–ï¼Œä»è€Œå¼•å‘æº¢å‡ºã€‚<br>\næœ‰ç¬¦å·æ•´æ•°çš„ç¬¦å·ä½ï¼šåœ¨æœ‰ç¬¦å·æ•´æ•°ä¸­ï¼Œæœ€é«˜ä½ç”¨æ¥è¡¨ç¤ºæ•°å€¼çš„æ­£è´Ÿã€‚ä¾‹å¦‚ï¼Œ32 ä½æœ‰ç¬¦å·æ•´æ•°çš„æœ€é«˜ä½æ˜¯ç¬¬ 31 ä½ï¼ˆç¬¬ 0 ä½åˆ°ç¬¬ 30 ä½æ˜¯æ•°å€¼ä½ï¼‰ã€‚æº¢å‡ºå¯¼è‡´ç¬¦å·å˜åŒ–ï¼šå¦‚æœè¿ç®—ç»“æœè¶…å‡ºæ­£æ•°èŒƒå›´ï¼Œç¬¦å·ä½ä¼šè¢«è®¾ç½®ä¸º 1ï¼Œè¿™ä¼šå¯¼è‡´æ•°å€¼è¢«è§£é‡Šä¸ºè´Ÿæ•°ã€‚ä¾‹å¦‚ï¼Œåœ¨ 32 ä½æœ‰ç¬¦å·æ•´æ•°ä¸­ï¼Œ+2,147,483,647 + 1 ä¼šå¯¼è‡´æ•°å€¼å˜æˆ -2,147,483,648ï¼Œå› ä¸ºç¬¦å·ä½è¢«æ”¹å˜ã€‚</li>\n<li>å‘ä¸‹ç±»å‹è½¬æ¢ï¼ˆDowncastingï¼‰å’Œæ•°å€¼æˆªæ–­ï¼ˆTruncationï¼‰\n<ul>\n<li>å‘ä¸‹ç±»å‹è½¬æ¢ï¼šæŒ‡å°†ä¸€ä¸ªé«˜ç²¾åº¦çš„æ•°æ®ç±»å‹è½¬æ¢ä¸ºä½ç²¾åº¦çš„æ•°æ®ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå°† long ç±»å‹è½¬æ¢ä¸º int æ—¶ï¼Œå¦‚æœåŸå§‹å€¼è¶…è¿‡ int çš„èŒƒå›´ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ•°å€¼æˆªæ–­ã€‚</li>\n<li>æ•°å€¼æˆªæ–­å¯èƒ½å¯¼è‡´æº¢å‡ºï¼šæˆªæ–­å‘ç”Ÿæ—¶ï¼Œè¾ƒé«˜ä½çš„æ•°å€¼ä¼šè¢«å¿½ç•¥ï¼Œåªä¿ç•™ä½ä½éƒ¨åˆ†ã€‚è¿™å¯èƒ½å¯¼è‡´æ•°å€¼é”™è¯¯ï¼Œç”šè‡³è§¦å‘æ•´æ•°æº¢å‡ºã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ª 64 ä½çš„ long ç±»å‹è¢«è½¬æ¢ä¸º 32 ä½çš„ int ç±»å‹ï¼Œè€Œå…¶æ•°å€¼è¶…è¿‡äº† 32 ä½æ•´æ•°çš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆé«˜ä½å°†è¢«æˆªæ–­ï¼Œåªä¿ç•™ä½ 32 ä½ï¼Œå¯èƒ½å¯¼è‡´æº¢å‡ºæˆ–é”™è¯¯çš„è®¡ç®—ç»“æœã€‚</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Risks of Integer Overflow<br>\nMostly lead to program errors, but can have severe consequences</li>\n</ol>\n<ul>\n<li>Buffer overflow occurs when an integer overflow happens in calculating the length of the buffer</li>\n<li>Erroneous program behaviours in mission critical software Incorrect financial calculations</li>\n</ul>\n<h1 id=\"Real-World Examples\" class=\"active\"><a class=\"anchor\"  href=\"#Real-World Examples\">#</a>Real-World Examples</h1>\n<ol>\n<li>Integer Overflow Leads to Buffer Overflow in OpenSSH 3.3</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nresp = packet_get_int(); </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (nresp &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\"> \tresponse = xmalloc(nresp * <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span> *)); </span><br><span class=\"line\"> \t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nresp; i++) </span><br><span class=\"line\"> \t\tresponse[i] = packet_get_string(<span class=\"literal\">NULL</span>); </span><br><span class=\"line\"> &#125; </span><br></pre></td></tr></table></figure>\n<p>When  <code>nresp</code>  is 1073741824 (1073741824*4=4294967296=2**32), results in an overflow</p>\n<ul>\n<li><code>xmalloc()</code>  receives and allocates a 0-byte buffer</li>\n<li>The subsequent loop causes a heap buffer overflow (å½“å¾ªç¯è¯•å›¾å°†æ•°æ®å†™å…¥åˆ°  <code>response</code>  æ—¶ï¼Œç”±äº  <code>response</code>  å¹¶æœªçœŸæ­£åˆ†é…å†…å­˜ï¼Œå†™å…¥æ“ä½œä¼šè¦†ç›–å…¶ä»–å†…å­˜åŒºåŸŸï¼Œå¯¼è‡´ç¨‹åºå´©æºƒæˆ–è¢«æ”»å‡»è€…åˆ©ç”¨ã€‚)</li>\n<li>fixed:  <code>if (nresp &gt; 0 &amp;&amp; nresp &lt;= SIZE_MAX / sizeof(char *))</code></li>\n</ul>\n<ol start=\"2\">\n<li>A Real-World Vulnerability in the Handling JPEG Files</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">getComment</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> len, <span class=\"type\">char</span> *src)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\"> \t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> size; </span><br><span class=\"line\"> \tsize = len â€ <span class=\"number\">2</span>; </span><br><span class=\"line\"> \t<span class=\"type\">char</span> *comment = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(size + <span class=\"number\">1</span>); </span><br><span class=\"line\"> \t<span class=\"built_in\">memcpy</span>(comment, src, size); </span><br><span class=\"line\"> \t<span class=\"keyword\">return</span>; </span><br><span class=\"line\"> &#125; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>æ•´æ•°ä¸‹æº¢<br>\nåœ¨è¿™æ®µä»£ç ä¸­ï¼Œå˜é‡  <code>len</code>  å’Œ  <code>size</code>  è¢«å£°æ˜ä¸ºæ— ç¬¦å·æ•´æ•°ï¼ˆunsigned intï¼‰ï¼Œè¿™æ„å‘³ç€å®ƒä»¬çš„å€¼ä¸èƒ½æ˜¯è´Ÿæ•°ã€‚<br>\nå½“  <code>len</code>  å°äº 2 æ—¶ï¼Œè®¡ç®—  <code>size = len - 2</code>  ä¼šå¯¼è‡´ æ•´æ•°ä¸‹æº¢ï¼š<br>\nä¾‹å¦‚ï¼Œ <code>len</code>  ä¸º 1 æ—¶ï¼Œ <code>size</code>  å°†å˜ä¸º 0xffffffffï¼ˆ4294967295ï¼‰ï¼Œå³æ— ç¬¦å·æ•´æ•°çš„æœ€å¤§å€¼ã€‚<br>\nä¸‹æº¢çš„åŸå› åœ¨äºæ— ç¬¦å·æ•´æ•°çš„è¿ç®—ç‰¹æ€§ï¼Œå½“å‡æ³•ç»“æœä¸ºè´Ÿæ—¶ï¼Œä¼šå›ç»•ï¼ˆwrap aroundï¼‰åˆ°æœ€å¤§å€¼ã€‚</li>\n<li>0 å­—èŠ‚å†…å­˜åˆ†é…<br>\nåœ¨ä¸‹æº¢çš„æƒ…å†µä¸‹ï¼Œå½“  <code>size</code>  è¢«è®¾ç½®ä¸º 0xffffffff æ—¶ï¼Œè¡¨è¾¾å¼  <code>size + 1</code>  å˜ä¸º 0ã€‚<br>\nè¿™ä¼šå¯¼è‡´  <code>malloc(0)</code> ï¼Œå³åˆ†é…ä¸€ä¸ª 0 å­—èŠ‚çš„ç¼“å†²åŒºã€‚<br>\nåœ¨è®¸å¤šç³»ç»Ÿä¸­ï¼Œ0 å­—èŠ‚çš„  <code>malloc()</code>  æ˜¯åˆæ³•çš„ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼Œä½†è¯¥æŒ‡é’ˆä¸èƒ½è¢«å†™å…¥ä»»ä½•æ•°æ®ã€‚</li>\n<li>å †ç¼“å†²åŒºæº¢å‡º<br>\n <code>memcpy(comment, src, size)</code>  å°†ä»  <code>src</code>  å¤åˆ¶  <code>size</code>  ä¸ªå­—èŠ‚åˆ°  <code>comment</code> ï¼Œå…¶ä¸­  <code>size</code>  çš„å€¼ä¸º 0xffffffffã€‚<br>\nç”±äº  <code>comment</code>  æ˜¯ä¸€ä¸ª 0 å­—èŠ‚çš„ç¼“å†²åŒºï¼Œè¿™å°†å¯¼è‡´ å †ç¼“å†²åŒºæº¢å‡ºï¼Œå¯èƒ½è¦†ç›–å…¶ä»–å †å†…å­˜åŒºåŸŸï¼Œä»è€Œå¯¼è‡´ç¨‹åºå´©æºƒæˆ–è¢«æ”»å‡»è€…åˆ©ç”¨ã€‚</li>\n<li>ä¿®å¤</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> size = len - <span class=\"number\">2</span>;</span><br><span class=\"line\"> ...</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Example 3</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">CopyStructs</span><span class=\"params\">(InputFile* pInFile, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> count)</span> &#123;</span><br><span class=\"line\">     <span class=\"type\">unsigned</span> <span class=\"type\">long</span> i;</span><br><span class=\"line\">     m_pStructs = new Structs[count]; </span><br><span class=\"line\">     <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123; </span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!ReadFromFile(pInFile, &amp;(m_pStructs[i]))) </span><br><span class=\"line\">             <span class=\"keyword\">break</span>; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>The C++â€™s  <code>new[]</code>  operator, it is similar to  <code>malloc(count*sizeof(Structs))</code> <br>\nAllocate a buffer smaller than we need, the attacker is able to write over the buffer</p>\n<ul>\n<li>By <strong>overflowing the multiplication operation</strong> internally</li>\n</ul>\n<ol start=\"4\">\n<li>Example 4</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_BUF 256</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BadCode</span><span class=\"params\">(<span class=\"type\">char</span> *input)</span> </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">     <span class=\"type\">short</span> len; </span><br><span class=\"line\">     <span class=\"type\">char</span> buf[MAX_BUF]; </span><br><span class=\"line\">     len = <span class=\"built_in\">strlen</span>(input); </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (len &lt; MAX_BUF) </span><br><span class=\"line\">         <span class=\"built_in\">strcpy</span>(buf, input); </span><br><span class=\"line\"> &#125; </span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>strlen()</code>  è¿”å›æ— ç¬¦å·æ•´æ•°<br>\n <code>strlen()</code>  è¿”å›çš„æ˜¯æ— ç¬¦å·æ•´æ•°ç±»å‹ <code>size_t</code> ï¼Œé€šå¸¸æ˜¯ä¸€ä¸ª 32 ä½æˆ– 64 ä½æ— ç¬¦å·æ•´æ•°ã€‚<br>\n <code>len</code>  è¢«å®šä¹‰ä¸ºä¸€ä¸ª 16 ä½æœ‰ç¬¦å·çŸ­æ•´å‹ <code>short</code> ï¼Œå…¶èŒƒå›´æ˜¯ -32,768 åˆ° 32,767ã€‚</li>\n<li>ç±»å‹æˆªæ–­å’Œç¬¦å·ç¿»è½¬<br>\nå½“  <code>strlen(input)</code>  è¿”å›çš„é•¿åº¦è¶…è¿‡  <code>32,767</code>  æ—¶ï¼Œèµ‹å€¼ç»™  <code>short len</code>  æ—¶ä¼šå‘ç”Ÿ ç±»å‹æˆªæ–­ï¼Œå¯¼è‡´æº¢å‡ºã€‚<br>\nä¾‹å¦‚ï¼Œå¦‚æœ  <code>strlen(input)</code>  è¿”å› 40,000ï¼Œé‚£ä¹ˆèµ‹å€¼åï¼Œ <code>len</code>  çš„å€¼å°†ä¼šå˜æˆ -25,536ï¼ˆæº¢å‡ºåçš„å€¼ï¼‰ï¼Œå› ä¸º  <code>short</code>  ç±»å‹çš„æœ€å¤§æ­£å€¼åªèƒ½åˆ° 32,767ã€‚<br>\nè¿™ä¼šå°†ä¸€ä¸ªæœ¬åº”æ˜¯å¤§äº 256 çš„å€¼å˜æˆä¸€ä¸ªè´Ÿæ•°ã€‚</li>\n<li>ç¼“å†²åŒºæº¢å‡ºé£é™©<br>\nåœ¨ç±»å‹æˆªæ–­åï¼Œ <code>len</code>  å¯èƒ½æ˜¯è´Ÿæ•°ã€‚æ¡ä»¶  <code>if (len &lt; MAX_BUF)</code>  å°†ä¼šæˆç«‹ï¼Œå› ä¸ºè´Ÿæ•°å°äº 256ã€‚<br>\nè¿™æ„å‘³ç€ï¼Œå³ä½¿è¾“å…¥å­—ç¬¦ä¸²çš„å®é™…é•¿åº¦è¶…è¿‡äº† 256 å­—èŠ‚ï¼Œ <code>strcpy(buf, input)</code>  ä»ä¼šè¢«æ‰§è¡Œï¼Œå¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚</li>\n<li>ä¿®å¤<br>\n <code>len = strnlen(input, MAX_BUF);</code> : The  <code>strnlen()</code>  function returns an integer value capped by  <code>MAX_BUF</code></li>\n</ul>\n<h1 id=\"Integer Overflow Prevention\" class=\"active\"><a class=\"anchor\"  href=\"#Integer Overflow Prevention\">#</a>Integer Overflow Prevention</h1>\nInteger overflow is very hard to discover and prevent\n<ol>\n<li>Runtime checks</li>\n</ol>\n<ul>\n<li>ubsan instruments binaries to be executed and checks the results of arithmetic operations</li>\n<li>Microsoft Visual C++ 2005 and later automatically catch calls to operator new that overflow</li>\n</ul>\n<ol start=\"2\">\n<li>Library support</li>\n</ol>\n<ul>\n<li>SafeInt class performs safe operations</li>\n</ul>\n<ol start=\"3\">\n<li>Static analysis tools and formal verification techniques<br>\n åœ¨ç¨‹åºç¼–è¯‘å‰å¯¹æºä»£ç è¿›è¡Œåˆ†æï¼Œå¯»æ‰¾æ½œåœ¨çš„æ•´æ•°æº¢å‡ºé—®é¢˜ã€‚è¿™äº›å·¥å…·å¯ä»¥æ£€æµ‹ä»£ç ä¸­çš„å¸¸è§æ•´æ•°è¿ç®—é”™è¯¯ï¼ŒåŒ…æ‹¬åŠ å‡ä¹˜é™¤æº¢å‡ºã€ç±»å‹è½¬æ¢æº¢å‡ºç­‰</li>\n</ol>\n",
            "tags": [
                "C",
                "software security"
            ]
        },
        {
            "id": "http://example.com/course/Stack-buffer-overflow/",
            "url": "http://example.com/course/Stack-buffer-overflow/",
            "title": "Stack buffer overflow",
            "date_published": "2024-10-26T07:50:30.000Z",
            "content_html": "<h1 id=\"Stack buffer overflow\" class=\"active\"><a class=\"anchor\"  href=\"#Stack buffer overflow\">#</a>Stack buffer overflow</h1>\n<ol>\n<li>The Process Stack</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>Sample Process C Code</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">A</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c)</span>  </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">\t<span class=\"type\">char</span> buffer1[<span class=\"number\">5</span>]; </span><br><span class=\"line\">\t<span class=\"type\">char</span> buffer2[<span class=\"number\">10</span>]; </span><br><span class=\"line\">    \t... </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>  </span><br><span class=\"line\"> &#123; </span><br><span class=\"line\">\tA(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(...); </span><br><span class=\"line\">   \t ... </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/26/671ca1b71cfbb.png\" alt=\"img\"></p>\n<p>åœ¨è°ƒç”¨å‡½æ•°æ—¶ï¼Œå‡½æ•°å‚æ•°æ˜¯æŒ‰ç…§ä»å³åˆ°å·¦çš„é¡ºåºä¾æ¬¡å‹å…¥æ ˆä¸­ã€‚è¿™ç§å‚æ•°ä¼ é€’æ–¹å¼æ˜¯ x86 æ¶æ„çš„æ ‡å‡†åšæ³•ï¼Œç”¨äºä¿è¯å‡½æ•°å‚æ•°åœ¨æ ˆä¸Šçš„æ­£ç¡®é¡ºåºã€‚<br>\nåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå‡½æ•°  <code>A(int a, int b, int c)</code>  è¢«è°ƒç”¨æ—¶ï¼Œ <code>c</code>  é¦–å…ˆè¢«å‹å…¥æ ˆï¼Œç„¶åæ˜¯  <code>b</code> ï¼Œæœ€åæ˜¯  <code>a</code> ã€‚</p>\n<ol start=\"2\">\n<li>Buffer Overflow</li>\n</ol>\n<ul>\n<li>Occurs when:<br>\nInput is unconstrained<br>\nRuns past the end of a buffer, replacing valid (control) data</li>\n<li>Technique that allows:<br>\nYour code to be executed by another program<br>\nOverflow data area to alter variable values</li>\n<li>Problem: declaration in version of login.c is  <code>char name[80], passwd[80], hash[13];</code> . Attack login procedure:\n<ol>\n<li>User types username, which is stored in name</li>\n<li>Compute hash for the corresponding password</li>\n<li>User types password, pads to 80 chars, and types hash for that password</li>\n<li>The program validates password against user-supplied hash; user is in (with any password)</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Stack Smashing<br>\n ç¼“å†²åŒºæº¢å‡ºæ”»å‡»çš„æ ¸å¿ƒæ˜¯è¦†ç›–æ ˆä¸Šçš„ è¿”å›åœ°å€ï¼ˆretï¼‰ã€‚å½“è¿”å›åœ°å€è¢«è¦†ç›–æ—¶ï¼Œç¨‹åºåœ¨å‡½æ•°è¿”å›æ—¶ä¸ä¼šè·³å›è°ƒç”¨å‡½æ•°çš„ä½ç½®ï¼Œè€Œæ˜¯è·³è½¬åˆ°æ”»å‡»è€…æŒ‡å®šçš„ä½ç½®ã€‚æ”»å‡»è€…å¯ä»¥åˆ©ç”¨è¿™ç§æŠ€æœ¯è®©ç¨‹åºæ‰§è¡Œä»»æ„ä»£ç ï¼ˆå¦‚æ¶æ„ä»£ç æˆ– shellcodeï¼‰ï¼Œè¿™è¢«ç§°ä¸ºå †æ ˆç ´åã€‚</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>Stack Smashing</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionA</span><span class=\"params\">(<span class=\"type\">char</span> *str)</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"type\">char</span> buffer[<span class=\"number\">16</span>]; </span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(buffer, str);   <span class=\"comment\">//segmentation fault</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"type\">char</span> large_string[<span class=\"number\">256</span>]; </span><br><span class=\"line\">\t<span class=\"type\">int</span> i; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">255</span>; i++) </span><br><span class=\"line\">       &#123; </span><br><span class=\"line\">\t\tlarge_string[i] = <span class=\"string\">&#x27;A&#x27;</span>; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">\tfunctionA(large_string); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>buffer</code> ï¼šåœ¨  <code>functionA</code>  ä¸­å£°æ˜ä¸º 16 å­—èŠ‚çš„å­—ç¬¦æ•°ç»„ã€‚</li>\n<li><code>strcpy(buffer, str)</code> ï¼šä½¿ç”¨  <code>strcpy</code>  å°†å¤–éƒ¨ä¼ å…¥çš„å­—ç¬¦ä¸² str å¤åˆ¶åˆ° buffer ä¸­ã€‚ç”±äº  <code>strcpy</code>  ä¸æ£€æŸ¥é•¿åº¦ï¼Œå¦‚æœ  <code>str</code>  çš„é•¿åº¦è¶…è¿‡ 16 å­—èŠ‚ï¼Œä¼šå¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚</li>\n<li>åœ¨  <code>main</code>  ä¸­ï¼Œ <code>large_string</code>  æ˜¯ä¸€ä¸ª 256 å­—èŠ‚çš„æ•°ç»„ï¼Œå®ƒè¢«å¡«å……ä¸º 255 ä¸ª â€˜Aâ€™ã€‚å½“  <code>large_string</code>  è¢«ä¼ é€’ç»™  <code>functionA</code>  æ—¶ï¼Œ <code>buffer</code>  è¢«æº¢å‡ºã€‚</li>\n<li>ä¿®å¤ï¼š  <code>strcpy(buffer, str)</code>  --&gt;  <code>strncpy(buffer, str, 16);</code></li>\n</ul>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/26/671ca87ccb1e2.png\" alt=\"img\"><br>\n <code>large_str</code>  has overflowed  <code>buffer</code>  and  <code>sfp</code>  and  <code>ret</code>  and  <code>*str</code> .Note that  <code>ret</code>  is the return address!<br>\nThis means we can get the function to return to any point in the code that we specify.</p>\n<ul>\n<li>Buffer overflows allow us to change return address\n<ol>\n<li>Can point to any function in the library</li>\n<li>Can point to own code</li>\n</ol>\n</li>\n<li>Add code in the overflowed buffer\n<ol>\n<li>Run at privilege of process (very useful if root!)</li>\n<li>Even a small buffer can invoke a shell using the system call (often called shellcode)</li>\n</ol>\n</li>\n<li>Attacker would like to run shell at root level\n<ol>\n<li>Make system call to  <code>execve</code> , passing  <code>/bin/sh</code></li>\n<li>Needs to be part of the buffer, and in assembly code (ä»¥ä¾¿ç²¾ç¡®æ§åˆ¶å…¶å¤§å°å’ŒåŠŸèƒ½)</li>\n<li>Program has to fit in buffer without overwriting return address (å¦‚æœ shellcode è¦†ç›–äº†è¿”å›åœ°å€æœ¬èº«ï¼Œå¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒè€Œæ— æ³•æ‰§è¡Œæ”»å‡»ä»£ç )</li>\n<li>Pad out buffer to return address, and point return address to start of buffer</li>\n<li>Donâ€™t generate core dump (this will cause suspicion)</li>\n</ol>\n</li>\n</ul>\n<ol start=\"4\">\n<li>What do You Need to Hack a Buffer Overflow\n<ol>\n<li>Address where buffer begins</li>\n</ol>\n<ul>\n<li>Easy to get if you have access to the same type of system being attacked</li>\n<li>Can use Null Operation (NOP) commands to make the target address bigger</li>\n</ul>\n<ol start=\"2\">\n<li>Location where return address is stored</li>\n</ol>\n<ul>\n<li>Can pad out the buffer with return address</li>\n</ul>\n<ol start=\"3\">\n<li>Assembly language program to spawn a shell (shellcode payload)</li>\n</ol>\n<ul>\n<li>Can use gdb to disassemble a program for you</li>\n</ul>\n</li>\n<li>Affected Languages</li>\n</ol>\n<p>Buffer overflows mainly occur in low-level programming languages that allow direct memory access: Assembler, C, C++<br>\nNote that some high-level languages such as Java, C# and Visual Basic are written in C, C++ or call modules written in these languages</p>\n<ol start=\"6\">\n<li>\n<p>Buffer Overflow Examples<br>\nFunctions that handle arrays but do not check length (checking for termination character is insufficient) In C/C++,   <code>gets</code> ,  <code>strcpy</code> ,  <code>strcat</code> ,  <code>sprintf</code></p>\n<ol>\n<li>Example 1</li>\n</ol>\n</li>\n</ol>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[<span class=\"number\">20</span>]; </span><br><span class=\"line\"> gets(buf);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>char buf[20]</code> ï¼šå®šä¹‰äº†ä¸€ä¸ªé•¿åº¦ä¸º 20 çš„å­—ç¬¦æ•°ç»„  <code>buf</code> ã€‚</p>\n</li>\n<li>\n<p><code>gets(buf)</code> ï¼šä½¿ç”¨  <code>gets()</code>  å‡½æ•°ä»æ ‡å‡†è¾“å…¥è¯»å–å­—ç¬¦ä¸²ï¼Œå¹¶å­˜å‚¨åœ¨  <code>buf</code>  ä¸­</p>\n</li>\n<li>\n<p><code>gets()</code>  å‡½æ•°ä¸æ£€æŸ¥è¾“å…¥çš„é•¿åº¦ï¼Œæ„å‘³ç€å¦‚æœè¾“å…¥çš„å­—ç¬¦ä¸²é•¿åº¦è¶…è¿‡äº†  <code>buf</code>  çš„å¤§å°ï¼ˆ20 å­—èŠ‚ï¼‰ï¼Œåˆ™ä¼šå‘ç”Ÿç¼“å†²åŒºæº¢å‡ºã€‚</p>\n</li>\n<li>\n<p>ä¿®å¤ï¼š  <code>fgets(buf, sizeof(buf), stdin);</code></p>\n<ol start=\"2\">\n<li>Example 2</li>\n</ol>\n</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[<span class=\"number\">20</span>]; </span><br><span class=\"line\"> <span class=\"type\">char</span> prefix[] = <span class=\"string\">&quot;http://&quot;</span>; </span><br><span class=\"line\">   ... </span><br><span class=\"line\">   <span class=\"comment\">// copies the string prefix to buf </span></span><br><span class=\"line\"> <span class=\"built_in\">strcpy</span>(buf, prefix); </span><br><span class=\"line\">   <span class=\"comment\">// concatenates path to the string buf </span></span><br><span class=\"line\"> <span class=\"built_in\">strncat</span>(buf, path, <span class=\"keyword\">sizeof</span>(buf));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>char buf[20]</code> ï¼šå®šä¹‰äº†ä¸€ä¸ªé•¿åº¦ä¸º 20 å­—èŠ‚çš„å­—ç¬¦æ•°ç»„  <code>buf</code> ã€‚</p>\n</li>\n<li>\n<p><code>char prefix[] = &quot;http://&quot;;</code> ï¼šå®šä¹‰äº†ä¸€ä¸ªåŒ…å«å­—ç¬¦ä¸²  <code>&quot;http://&quot;</code>  çš„å­—ç¬¦æ•°ç»„ã€‚</p>\n</li>\n<li>\n<p><code>strcpy(buf, prefix)</code> ï¼šå°†å­—ç¬¦ä¸²  <code>&quot;http://&quot;</code>  å¤åˆ¶åˆ°  <code>buf</code>  ä¸­ã€‚</p>\n<ul>\n<li>é—®é¢˜ï¼š <code>&quot;http://&quot;</code>  é•¿åº¦ä¸º 7 å­—èŠ‚ï¼ˆåŒ…æ‹¬ç»ˆæ­¢ç¬¦ \\0ï¼‰ï¼Œåœ¨å¤åˆ¶åï¼Œ <code>buf</code>  ä¸­åªå‰©ä¸‹ 13 ä¸ªå­—èŠ‚å¯ç”¨ã€‚</li>\n</ul>\n</li>\n<li>\n<p><code>strncat(buf, path, sizeof(buf))</code> ï¼šå°†å­—ç¬¦ä¸²  <code>path</code>  è¿æ¥åˆ°  <code>buf</code>  ä¸­ï¼ŒæŒ‡å®šçš„æœ€å¤§é•¿åº¦ä¸º  <code>sizeof(buf)</code> ï¼ˆå³ 20 å­—èŠ‚ï¼‰ã€‚</p>\n<ul>\n<li>é—®é¢˜ï¼šè¿™é‡Œçš„  <code>sizeof(buf)</code>  æ˜¯ 20 å­—èŠ‚ï¼Œä½†åœ¨å‰é¢å·²ç»ç”¨æ‰äº† 7 å­—èŠ‚ï¼ˆåŒ…æ‹¬ç»ˆæ­¢ç¬¦ï¼‰ã€‚ <code>strncat()</code>  è¯•å›¾è¿½åŠ   <code>path</code>  çš„å†…å®¹æ—¶ï¼Œå¯èƒ½ä¼šè¶…å‡º  <code>buf</code>  çš„å‰©ä½™ç©ºé—´ï¼ˆ13 å­—èŠ‚ï¼‰ï¼Œå¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚</li>\n</ul>\n</li>\n<li>\n<p>ä¿®å¤ï¼š <code>strncat(buf, path, sizeof(buf) - strlen(buf) - 1);</code></p>\n<ol start=\"3\">\n<li>Example 3</li>\n</ol>\n</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[<span class=\"number\">32</span>]; </span><br><span class=\"line\"> <span class=\"built_in\">strncpy</span>(buf, data, <span class=\"built_in\">strlen</span>(data)); </span><br></pre></td></tr></table></figure>\n<p><code>strncpy(buf, data, strlen(data))</code> ï¼šå°†å­—ç¬¦ä¸²  <code>data</code>  å¤åˆ¶åˆ°  <code>buf</code>  ä¸­ï¼Œå¤åˆ¶çš„é•¿åº¦ä¸º  <code>strlen(data)</code> ã€‚</p>\n<ul>\n<li>\n<p>ç¼ºé™· 1ï¼šç¼ºå°‘ç»ˆæ­¢ç¬¦ \\0ï¼š <code>strncpy</code>  ä¸ä¼šè‡ªåŠ¨æ·»åŠ å­—ç¬¦ä¸²çš„ç»ˆæ­¢ç¬¦  <code>\\0</code> ï¼Œå¦‚æœ  <code>data</code>  çš„é•¿åº¦ç­‰äºæˆ–å¤§äº 32ï¼Œé‚£ä¹ˆ  <code>buf</code>  ä¸ä¼šä»¥  <code>\\0</code>  ç»“å°¾ã€‚è¿™å¯èƒ½å¯¼è‡´  <code>buf</code>  è¢«å½“ä½œæœªç»ˆæ­¢çš„å­—ç¬¦ä¸²å¤„ç†ï¼Œå¸¦æ¥ä¸ç¡®å®šçš„è¡Œä¸ºæˆ–å®‰å…¨é£é™©ã€‚</p>\n</li>\n<li>\n<p>ç¼ºé™· 2ï¼šå¯èƒ½çš„ç¼“å†²åŒºæº¢å‡ºï¼šå¦‚æœ  <code>strlen(data) &gt; 32</code> ï¼Œ <code>strncpy</code>  å°†å°è¯•å¤åˆ¶è¶…è¿‡  <code>buf</code>  å¤§å°çš„å†…å®¹ï¼Œå¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚</p>\n</li>\n<li>\n<p>ä¿®å¤ï¼š <code>strncpy(buf, data, sizeof(buf) - 1); buf[sizeof(buf) - 1] = '\\0';</code></p>\n<ol start=\"4\">\n<li>Example 4</li>\n</ol>\n</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buf[MAX_PATH]; </span><br><span class=\"line\"> <span class=\"built_in\">sprintf</span>(buf, <span class=\"string\">&quot;%s - %d\\n&quot;</span>, path, errno);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>sprintf(buf, &quot;%s - %d\\n&quot;, path, errno)</code>  ä¼šå°†  <code>path</code>  å’Œ  <code>errno</code>  çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²å¤åˆ¶åˆ°  <code>buf</code>  ä¸­ã€‚</li>\n<li><code>sprintf</code>  ä¸æ£€æŸ¥  <code>buf</code>  çš„å¤§å°æ˜¯å¦è¶³ä»¥å®¹çº³æ ¼å¼åŒ–åçš„ç»“æœã€‚å¦‚æœ  <code>path</code>  å¾ˆé•¿ï¼ŒåŠ ä¸Šæ•°å­—  <code>errno</code>  å’Œå…¶ä»–å­—ç¬¦ï¼Œå¯èƒ½ä¼šè¶…è¿‡  <code>MAX_PATH</code> ï¼Œå¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚</li>\n<li>ä¿®å¤ï¼š  <code>snprintf(buf, sizeof(buf), &quot;%s - %d\\n&quot;, path, errno);</code></li>\n</ul>\n<h1 id=\"Stack buffer overflow prevention\" class=\"active\"><a class=\"anchor\"  href=\"#Stack buffer overflow prevention\">#</a>Stack buffer overflow prevention</h1>\n<ol>\n<li>Spotting Buffer Overflows</li>\n</ol>\n<ul>\n<li>Check inputs, whether read from the network, a file, or from the command line</li>\n<li>Check transfer of data from said input to internal structures</li>\n<li>Look for use of unsafe string handling calls</li>\n<li>Look for use of arithmetic to calculate an allocation size or remaining buffer size</li>\n</ul>\n<ol start=\"2\">\n<li>Fixing Buffer Overflows</li>\n</ol>\n<ul>\n<li>Replace dangerous string handling functions</li>\n<li>Replace C string buffers with C++ strings</li>\n<li>Replace static arrays with STL containers</li>\n<li>Use analysis tools, Examples include Fortify, Coverity, PREfast, and Klocwor</li>\n</ul>\n<ol start=\"3\">\n<li>Code Analysis</li>\n</ol>\n<ul>\n<li>Statically check source to detect buffer overflows s</li>\n<li>Several tools exist to automate the review process<br>\nStanford:  Engler, et al.  Test trust inconsistency<br>\n@stake.com  (<span class=\"exturl\" data-url=\"aHR0cDovL2wwcGh0LmNvbQ==\">l0pht.com</span>): SLINT (designed for UNIX)<br>\nBerkeley:  Wagner, et al.  Test constraint violations</li>\n<li>Find lots of bugs, but not all</li>\n</ul>\n<ol start=\"4\">\n<li>Marking Stack as Non-Execute<br>\nBasic stack exploit can be prevented by marking stack segment as non-executable<br>\nLimitations and Problems</li>\n</ol>\n<ul>\n<li>Some apps need executable stack (e.g. LISP interpreters)</li>\n<li>Does not block more general overflow exploits</li>\n<li>Overflow on heap: overflow buffer next to func pointer</li>\n<li>Cannot make all the data segment non-executable</li>\n<li>More recent UNIX and MS windows emit dynamic code into program data for performance optimisations</li>\n</ul>\n<ol start=\"5\">\n<li>Stack Protection and Run-time Checking<br>\nMany run-time checking techniques\n<ol>\n<li>Example:  StackGuard (WireX)</li>\n</ol>\n<ul>\n<li>Run time tests for stack integrity</li>\n<li>Code generator for emitting code to set up and tear down functions</li>\n<li>Embeds â€œcanariesâ€ in stack frames and verify their integrity prior to function return</li>\n</ul>\n<ol start=\"2\">\n<li>Libsafe (Avaya Labs)</li>\n</ol>\n<ul>\n<li>Dynamically loaded library</li>\n<li>Intercepts calls to  <code>strcpy (dest, src)</code>\n<ul>\n<li>Validate sufficient space in current stack frame: |framepointerâ€“dest| &gt; strlen(src)</li>\n<li>If so, does strcpy. Otherwise, terminates application</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Address obfuscation (Stony Brookâ€™03)</li>\n</ol>\n<ul>\n<li>Encrypt return address on stack by XORing with random string. Decrypt just before returning from function</li>\n<li>Attacker needs decryption key to set return address to desired value</li>\n</ul>\n<ol start=\"7\">\n<li>PaX ASLR: Randomise location of libc</li>\n</ol>\n<ul>\n<li>Attacker cannot jump directly to exec function</li>\n</ul>\n",
            "tags": [
                "C",
                "software security",
                "vulnerability"
            ]
        }
    ]
}