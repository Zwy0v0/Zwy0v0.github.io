<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;c&#34; tag</title>
        <link>http://example.com</link>
        <description>🌸</description>
        <language>zh-CN</language>
        <pubDate>Sat, 26 Oct 2024 20:33:32 +1000</pubDate>
        <lastBuildDate>Sat, 26 Oct 2024 20:33:32 +1000</lastBuildDate>
        <category>C language</category>
        <category>Linux</category>
        <category>software security</category>
        <category>C</category>
        <category>vulnerability</category>
        <category>gdb</category>
        <category>Blog</category>
        <category>日常</category>
        <category>JavaScript</category>
        <item>
            <guid isPermalink="true">http://example.com/course/Integer-overflow/</guid>
            <title>Integer overflow</title>
            <link>http://example.com/course/Integer-overflow/</link>
            <category>software security</category>
            <category>C</category>
            <pubDate>Sat, 26 Oct 2024 20:33:32 +1000</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Integer overflow&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Integer overflow&#34;&gt;#&lt;/a&gt;Integer overflow&lt;/h1&gt;
 When the result of an integer operation does not fit within the allocated memory space. All common languages are affected 
&lt;ol&gt;
&lt;li&gt;How Does an Integer Overflow Happen?
&lt;ol&gt;
&lt;li&gt;无符号整数溢出：例如，一个 32 位无符号整数的范围是 0 到 4,294,967,295（即 2**32 − 1 或 0xffffffff）。如果我们执行计算 4,294,967,295 + 1，则会导致溢出，因为结果超出了无符号整数的范围&lt;/li&gt;
&lt;li&gt;有符号整数溢出&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;符号位的溢出&lt;br&gt;
当一个整数运算的结果超过有符号整数的范围时，符号位（最高位）可能会被覆盖，从而引发溢出。&lt;br&gt;
有符号整数的符号位：在有符号整数中，最高位用来表示数值的正负。例如，32 位有符号整数的最高位是第 31 位（第 0 位到第 30 位是数值位）。溢出导致符号变化：如果运算结果超出正数范围，符号位会被设置为 1，这会导致数值被解释为负数。例如，在 32 位有符号整数中，+2,147,483,647 + 1 会导致数值变成 -2,147,483,648，因为符号位被改变。&lt;/li&gt;
&lt;li&gt;向下类型转换（Downcasting）和数值截断（Truncation）
&lt;ul&gt;
&lt;li&gt;向下类型转换：指将一个高精度的数据类型转换为低精度的数据类型。例如，将 long 类型转换为 int 时，如果原始值超过 int 的范围，可能会导致数值截断。&lt;/li&gt;
&lt;li&gt;数值截断可能导致溢出：截断发生时，较高位的数值会被忽略，只保留低位部分。这可能导致数值错误，甚至触发整数溢出。例如，如果一个 64 位的 long 类型被转换为 32 位的 int 类型，而其数值超过了 32 位整数的最大值，那么高位将被截断，只保留低 32 位，可能导致溢出或错误的计算结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Risks of Integer Overflow&lt;br&gt;
Mostly lead to program errors, but can have severe consequences&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Buffer overflow occurs when an integer overflow happens in calculating the length of the buffer&lt;/li&gt;
&lt;li&gt;Erroneous program behaviours in mission critical software Incorrect financial calculations&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Real-World Examples&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Real-World Examples&#34;&gt;#&lt;/a&gt;Real-World Examples&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Integer Overflow Leads to Buffer Overflow in OpenSSH 3.3&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;nresp = packet_get_int(); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (nresp &amp;gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	response = xmalloc(nresp * &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *)); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; nresp; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 		response[i] = packet_get_string(&lt;span class=&#34;literal&#34;&gt;NULL&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;When  &lt;code&gt;nresp&lt;/code&gt;  is 1073741824 (1073741824*4=4294967296=2**32), results in an overflow&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xmalloc()&lt;/code&gt;  receives and allocates a 0-byte buffer&lt;/li&gt;
&lt;li&gt;The subsequent loop causes a heap buffer overflow (当循环试图将数据写入到  &lt;code&gt;response&lt;/code&gt;  时，由于  &lt;code&gt;response&lt;/code&gt;  并未真正分配内存，写入操作会覆盖其他内存区域，导致程序崩溃或被攻击者利用。)&lt;/li&gt;
&lt;li&gt;fixed:  &lt;code&gt;if (nresp &amp;gt; 0 &amp;amp;&amp;amp; nresp &amp;lt;= SIZE_MAX / sizeof(char *))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;A Real-World Vulnerability in the Handling JPEG Files&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getComment&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; len, &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *src)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; size; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	size = len ‐ &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *comment = (&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(size + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;built_in&#34;&gt;memcpy&lt;/span&gt;(comment, src, size); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; 	&lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;整数下溢&lt;br&gt;
在这段代码中，变量  &lt;code&gt;len&lt;/code&gt;  和  &lt;code&gt;size&lt;/code&gt;  被声明为无符号整数（unsigned int），这意味着它们的值不能是负数。&lt;br&gt;
当  &lt;code&gt;len&lt;/code&gt;  小于 2 时，计算  &lt;code&gt;size = len - 2&lt;/code&gt;  会导致 整数下溢：&lt;br&gt;
例如， &lt;code&gt;len&lt;/code&gt;  为 1 时， &lt;code&gt;size&lt;/code&gt;  将变为 0xffffffff（4294967295），即无符号整数的最大值。&lt;br&gt;
下溢的原因在于无符号整数的运算特性，当减法结果为负时，会回绕（wrap around）到最大值。&lt;/li&gt;
&lt;li&gt;0 字节内存分配&lt;br&gt;
在下溢的情况下，当  &lt;code&gt;size&lt;/code&gt;  被设置为 0xffffffff 时，表达式  &lt;code&gt;size + 1&lt;/code&gt;  变为 0。&lt;br&gt;
这会导致  &lt;code&gt;malloc(0)&lt;/code&gt; ，即分配一个 0 字节的缓冲区。&lt;br&gt;
在许多系统中，0 字节的  &lt;code&gt;malloc()&lt;/code&gt;  是合法的，它会返回一个指针，但该指针不能被写入任何数据。&lt;/li&gt;
&lt;li&gt;堆缓冲区溢出&lt;br&gt;
 &lt;code&gt;memcpy(comment, src, size)&lt;/code&gt;  将从  &lt;code&gt;src&lt;/code&gt;  复制  &lt;code&gt;size&lt;/code&gt;  个字节到  &lt;code&gt;comment&lt;/code&gt; ，其中  &lt;code&gt;size&lt;/code&gt;  的值为 0xffffffff。&lt;br&gt;
由于  &lt;code&gt;comment&lt;/code&gt;  是一个 0 字节的缓冲区，这将导致 堆缓冲区溢出，可能覆盖其他堆内存区域，从而导致程序崩溃或被攻击者利用。&lt;/li&gt;
&lt;li&gt;修复&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (len &amp;lt;= &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; size = len - &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Example 3&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;CopyStructs&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(InputFile* pInFile, &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; count)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;long&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     m_pStructs = new Structs[count]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!ReadFromFile(pInFile, &amp;amp;(m_pStructs[i]))) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;             &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The C++’s  &lt;code&gt;new[]&lt;/code&gt;  operator, it is similar to  &lt;code&gt;malloc(count*sizeof(Structs))&lt;/code&gt; &lt;br&gt;
Allocate a buffer smaller than we need, the attacker is able to write over the buffer&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;By &lt;strong&gt;overflowing the multiplication operation&lt;/strong&gt; internally&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Example 4&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;define&lt;/span&gt; MAX_BUF 256&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;BadCode&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *input)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;short&lt;/span&gt; len; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[MAX_BUF]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     len = &lt;span class=&#34;built_in&#34;&gt;strlen&lt;/span&gt;(input); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (len &amp;lt; MAX_BUF) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         &lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buf, input); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;strlen()&lt;/code&gt;  返回无符号整数&lt;br&gt;
 &lt;code&gt;strlen()&lt;/code&gt;  返回的是无符号整数类型 &lt;code&gt;size_t&lt;/code&gt; ，通常是一个 32 位或 64 位无符号整数。&lt;br&gt;
 &lt;code&gt;len&lt;/code&gt;  被定义为一个 16 位有符号短整型 &lt;code&gt;short&lt;/code&gt; ，其范围是 -32,768 到 32,767。&lt;/li&gt;
&lt;li&gt;类型截断和符号翻转&lt;br&gt;
当  &lt;code&gt;strlen(input)&lt;/code&gt;  返回的长度超过  &lt;code&gt;32,767&lt;/code&gt;  时，赋值给  &lt;code&gt;short len&lt;/code&gt;  时会发生 类型截断，导致溢出。&lt;br&gt;
例如，如果  &lt;code&gt;strlen(input)&lt;/code&gt;  返回 40,000，那么赋值后， &lt;code&gt;len&lt;/code&gt;  的值将会变成 -25,536（溢出后的值），因为  &lt;code&gt;short&lt;/code&gt;  类型的最大正值只能到 32,767。&lt;br&gt;
这会将一个本应是大于 256 的值变成一个负数。&lt;/li&gt;
&lt;li&gt;缓冲区溢出风险&lt;br&gt;
在类型截断后， &lt;code&gt;len&lt;/code&gt;  可能是负数。条件  &lt;code&gt;if (len &amp;lt; MAX_BUF)&lt;/code&gt;  将会成立，因为负数小于 256。&lt;br&gt;
这意味着，即使输入字符串的实际长度超过了 256 字节， &lt;code&gt;strcpy(buf, input)&lt;/code&gt;  仍会被执行，导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;修复&lt;br&gt;
 &lt;code&gt;len = strnlen(input, MAX_BUF);&lt;/code&gt; : The  &lt;code&gt;strnlen()&lt;/code&gt;  function returns an integer value capped by  &lt;code&gt;MAX_BUF&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Integer Overflow Prevention&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Integer Overflow Prevention&#34;&gt;#&lt;/a&gt;Integer Overflow Prevention&lt;/h1&gt;
Integer overflow is very hard to discover and prevent
&lt;ol&gt;
&lt;li&gt;Runtime checks&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ubsan instruments binaries to be executed and checks the results of arithmetic operations&lt;/li&gt;
&lt;li&gt;Microsoft Visual C++ 2005 and later automatically catch calls to operator new that overflow&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Library support&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;SafeInt class performs safe operations&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Static analysis tools and formal verification techniques&lt;br&gt;
 在程序编译前对源代码进行分析，寻找潜在的整数溢出问题。这些工具可以检测代码中的常见整数运算错误，包括加减乘除溢出、类型转换溢出等&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/course/Stack-buffer-overflow/</guid>
            <title>Stack buffer overflow</title>
            <link>http://example.com/course/Stack-buffer-overflow/</link>
            <category>software security</category>
            <category>C</category>
            <category>vulnerability</category>
            <pubDate>Sat, 26 Oct 2024 17:50:30 +1000</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Stack buffer overflow&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Stack buffer overflow&#34;&gt;#&lt;/a&gt;Stack buffer overflow&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;The Process Stack&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Sample Process C Code&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; b, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; c)&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer1[&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer2[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    	... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	A(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(...); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   	 ... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/26/671ca1b71cfbb.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在调用函数时，函数参数是按照从右到左的顺序依次压入栈中。这种参数传递方式是 x86 架构的标准做法，用于保证函数参数在栈上的正确顺序。&lt;br&gt;
在这个例子中，函数  &lt;code&gt;A(int a, int b, int c)&lt;/code&gt;  被调用时， &lt;code&gt;c&lt;/code&gt;  首先被压入栈，然后是  &lt;code&gt;b&lt;/code&gt; ，最后是  &lt;code&gt;a&lt;/code&gt; 。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Buffer Overflow&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Occurs when:&lt;br&gt;
Input is unconstrained&lt;br&gt;
Runs past the end of a buffer, replacing valid (control) data&lt;/li&gt;
&lt;li&gt;Technique that allows:&lt;br&gt;
Your code to be executed by another program&lt;br&gt;
Overflow data area to alter variable values&lt;/li&gt;
&lt;li&gt;Problem: declaration in version of login.c is  &lt;code&gt;char name[80], passwd[80], hash[13];&lt;/code&gt; . Attack login procedure:
&lt;ol&gt;
&lt;li&gt;User types username, which is stored in name&lt;/li&gt;
&lt;li&gt;Compute hash for the corresponding password&lt;/li&gt;
&lt;li&gt;User types password, pads to 80 chars, and types hash for that password&lt;/li&gt;
&lt;li&gt;The program validates password against user-supplied hash; user is in (with any password)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Stack Smashing&lt;br&gt;
 缓冲区溢出攻击的核心是覆盖栈上的 返回地址（ret）。当返回地址被覆盖时，程序在函数返回时不会跳回调用函数的位置，而是跳转到攻击者指定的位置。攻击者可以利用这种技术让程序执行任意代码（如恶意代码或 shellcode），这被称为堆栈破坏。&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;Stack Smashing&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionA&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; *str)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buffer[&lt;span class=&#34;number&#34;&gt;16&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buffer, str);   &lt;span class=&#34;comment&#34;&gt;//segmentation fault&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; large_string[&lt;span class=&#34;number&#34;&gt;256&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;255&lt;/span&gt;; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		large_string[i] = &lt;span class=&#34;string&#34;&gt;&amp;#x27;A&amp;#x27;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	functionA(large_string); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buffer&lt;/code&gt; ：在  &lt;code&gt;functionA&lt;/code&gt;  中声明为 16 字节的字符数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcpy(buffer, str)&lt;/code&gt; ：使用  &lt;code&gt;strcpy&lt;/code&gt;  将外部传入的字符串 str 复制到 buffer 中。由于  &lt;code&gt;strcpy&lt;/code&gt;  不检查长度，如果  &lt;code&gt;str&lt;/code&gt;  的长度超过 16 字节，会导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;在  &lt;code&gt;main&lt;/code&gt;  中， &lt;code&gt;large_string&lt;/code&gt;  是一个 256 字节的数组，它被填充为 255 个 ‘A’。当  &lt;code&gt;large_string&lt;/code&gt;  被传递给  &lt;code&gt;functionA&lt;/code&gt;  时， &lt;code&gt;buffer&lt;/code&gt;  被溢出。&lt;/li&gt;
&lt;li&gt;修复：  &lt;code&gt;strcpy(buffer, str)&lt;/code&gt;  --&amp;gt;  &lt;code&gt;strncpy(buffer, str, 16);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img.picui.cn/free/2024/10/26/671ca87ccb1e2.png&#34; alt=&#34;img&#34;&gt;&lt;br&gt;
 &lt;code&gt;large_str&lt;/code&gt;  has overflowed  &lt;code&gt;buffer&lt;/code&gt;  and  &lt;code&gt;sfp&lt;/code&gt;  and  &lt;code&gt;ret&lt;/code&gt;  and  &lt;code&gt;*str&lt;/code&gt; .Note that  &lt;code&gt;ret&lt;/code&gt;  is the return address!&lt;br&gt;
This means we can get the function to return to any point in the code that we specify.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer overflows allow us to change return address
&lt;ol&gt;
&lt;li&gt;Can point to any function in the library&lt;/li&gt;
&lt;li&gt;Can point to own code&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Add code in the overflowed buffer
&lt;ol&gt;
&lt;li&gt;Run at privilege of process (very useful if root!)&lt;/li&gt;
&lt;li&gt;Even a small buffer can invoke a shell using the system call (often called shellcode)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Attacker would like to run shell at root level
&lt;ol&gt;
&lt;li&gt;Make system call to  &lt;code&gt;execve&lt;/code&gt; , passing  &lt;code&gt;/bin/sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Needs to be part of the buffer, and in assembly code (以便精确控制其大小和功能)&lt;/li&gt;
&lt;li&gt;Program has to fit in buffer without overwriting return address (如果 shellcode 覆盖了返回地址本身，可能导致程序崩溃而无法执行攻击代码)&lt;/li&gt;
&lt;li&gt;Pad out buffer to return address, and point return address to start of buffer&lt;/li&gt;
&lt;li&gt;Don’t generate core dump (this will cause suspicion)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;What do You Need to Hack a Buffer Overflow
&lt;ol&gt;
&lt;li&gt;Address where buffer begins&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Easy to get if you have access to the same type of system being attacked&lt;/li&gt;
&lt;li&gt;Can use Null Operation (NOP) commands to make the target address bigger&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Location where return address is stored&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Can pad out the buffer with return address&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Assembly language program to spawn a shell (shellcode payload)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Can use gdb to disassemble a program for you&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Affected Languages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Buffer overflows mainly occur in low-level programming languages that allow direct memory access: Assembler, C, C++&lt;br&gt;
Note that some high-level languages such as Java, C# and Visual Basic are written in C, C++ or call modules written in these languages&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;Buffer Overflow Examples&lt;br&gt;
Functions that handle arrays but do not check length (checking for termination character is insufficient) In C/C++,   &lt;code&gt;gets&lt;/code&gt; ,  &lt;code&gt;strcpy&lt;/code&gt; ,  &lt;code&gt;strcat&lt;/code&gt; ,  &lt;code&gt;sprintf&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Example 1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; gets(buf);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char buf[20]&lt;/code&gt; ：定义了一个长度为 20 的字符数组  &lt;code&gt;buf&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gets(buf)&lt;/code&gt; ：使用  &lt;code&gt;gets()&lt;/code&gt;  函数从标准输入读取字符串，并存储在  &lt;code&gt;buf&lt;/code&gt;  中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gets()&lt;/code&gt;  函数不检查输入的长度，意味着如果输入的字符串长度超过了  &lt;code&gt;buf&lt;/code&gt;  的大小（20 字节），则会发生缓冲区溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复：  &lt;code&gt;fgets(buf, sizeof(buf), stdin);&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Example 2&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; prefix[] = &lt;span class=&#34;string&#34;&gt;&amp;quot;http://&amp;quot;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   ... &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &lt;span class=&#34;comment&#34;&gt;// copies the string prefix to buf &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strcpy&lt;/span&gt;(buf, prefix); &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &lt;span class=&#34;comment&#34;&gt;// concatenates path to the string buf &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strncat&lt;/span&gt;(buf, path, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(buf));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char buf[20]&lt;/code&gt; ：定义了一个长度为 20 字节的字符数组  &lt;code&gt;buf&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char prefix[] = &amp;quot;http://&amp;quot;;&lt;/code&gt; ：定义了一个包含字符串  &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt;  的字符数组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strcpy(buf, prefix)&lt;/code&gt; ：将字符串  &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt;  复制到  &lt;code&gt;buf&lt;/code&gt;  中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题： &lt;code&gt;&amp;quot;http://&amp;quot;&lt;/code&gt;  长度为 7 字节（包括终止符 \0），在复制后， &lt;code&gt;buf&lt;/code&gt;  中只剩下 13 个字节可用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strncat(buf, path, sizeof(buf))&lt;/code&gt; ：将字符串  &lt;code&gt;path&lt;/code&gt;  连接到  &lt;code&gt;buf&lt;/code&gt;  中，指定的最大长度为  &lt;code&gt;sizeof(buf)&lt;/code&gt; （即 20 字节）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题：这里的  &lt;code&gt;sizeof(buf)&lt;/code&gt;  是 20 字节，但在前面已经用掉了 7 字节（包括终止符）。 &lt;code&gt;strncat()&lt;/code&gt;  试图追加  &lt;code&gt;path&lt;/code&gt;  的内容时，可能会超出  &lt;code&gt;buf&lt;/code&gt;  的剩余空间（13 字节），导致缓冲区溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复： &lt;code&gt;strncat(buf, path, sizeof(buf) - strlen(buf) - 1);&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Example 3&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[&lt;span class=&#34;number&#34;&gt;32&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;strncpy&lt;/span&gt;(buf, data, &lt;span class=&#34;built_in&#34;&gt;strlen&lt;/span&gt;(data)); &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;strncpy(buf, data, strlen(data))&lt;/code&gt; ：将字符串  &lt;code&gt;data&lt;/code&gt;  复制到  &lt;code&gt;buf&lt;/code&gt;  中，复制的长度为  &lt;code&gt;strlen(data)&lt;/code&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缺陷 1：缺少终止符 \0： &lt;code&gt;strncpy&lt;/code&gt;  不会自动添加字符串的终止符  &lt;code&gt;\0&lt;/code&gt; ，如果  &lt;code&gt;data&lt;/code&gt;  的长度等于或大于 32，那么  &lt;code&gt;buf&lt;/code&gt;  不会以  &lt;code&gt;\0&lt;/code&gt;  结尾。这可能导致  &lt;code&gt;buf&lt;/code&gt;  被当作未终止的字符串处理，带来不确定的行为或安全风险。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺陷 2：可能的缓冲区溢出：如果  &lt;code&gt;strlen(data) &amp;gt; 32&lt;/code&gt; ， &lt;code&gt;strncpy&lt;/code&gt;  将尝试复制超过  &lt;code&gt;buf&lt;/code&gt;  大小的内容，导致缓冲区溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复： &lt;code&gt;strncpy(buf, data, sizeof(buf) - 1); buf[sizeof(buf) - 1] = &#39;\0&#39;;&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Example 4&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;OvO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; buf[MAX_PATH]; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;built_in&#34;&gt;sprintf&lt;/span&gt;(buf, &lt;span class=&#34;string&#34;&gt;&amp;quot;%s - %d\n&amp;quot;&lt;/span&gt;, path, errno);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sprintf(buf, &amp;quot;%s - %d\n&amp;quot;, path, errno)&lt;/code&gt;  会将  &lt;code&gt;path&lt;/code&gt;  和  &lt;code&gt;errno&lt;/code&gt;  的格式化字符串复制到  &lt;code&gt;buf&lt;/code&gt;  中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sprintf&lt;/code&gt;  不检查  &lt;code&gt;buf&lt;/code&gt;  的大小是否足以容纳格式化后的结果。如果  &lt;code&gt;path&lt;/code&gt;  很长，加上数字  &lt;code&gt;errno&lt;/code&gt;  和其他字符，可能会超过  &lt;code&gt;MAX_PATH&lt;/code&gt; ，导致缓冲区溢出。&lt;/li&gt;
&lt;li&gt;修复：  &lt;code&gt;snprintf(buf, sizeof(buf), &amp;quot;%s - %d\n&amp;quot;, path, errno);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Stack buffer overflow prevention&#34; class=&#34;active&#34;&gt;&lt;a class=&#34;anchor&#34;  href=&#34;#Stack buffer overflow prevention&#34;&gt;#&lt;/a&gt;Stack buffer overflow prevention&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Spotting Buffer Overflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Check inputs, whether read from the network, a file, or from the command line&lt;/li&gt;
&lt;li&gt;Check transfer of data from said input to internal structures&lt;/li&gt;
&lt;li&gt;Look for use of unsafe string handling calls&lt;/li&gt;
&lt;li&gt;Look for use of arithmetic to calculate an allocation size or remaining buffer size&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Fixing Buffer Overflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Replace dangerous string handling functions&lt;/li&gt;
&lt;li&gt;Replace C string buffers with C++ strings&lt;/li&gt;
&lt;li&gt;Replace static arrays with STL containers&lt;/li&gt;
&lt;li&gt;Use analysis tools, Examples include Fortify, Coverity, PREfast, and Klocwor&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Code Analysis&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Statically check source to detect buffer overflows s&lt;/li&gt;
&lt;li&gt;Several tools exist to automate the review process&lt;br&gt;
Stanford:  Engler, et al.  Test trust inconsistency&lt;br&gt;
@stake.com  (&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2wwcGh0LmNvbQ==&#34;&gt;l0pht.com&lt;/span&gt;): SLINT (designed for UNIX)&lt;br&gt;
Berkeley:  Wagner, et al.  Test constraint violations&lt;/li&gt;
&lt;li&gt;Find lots of bugs, but not all&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Marking Stack as Non-Execute&lt;br&gt;
Basic stack exploit can be prevented by marking stack segment as non-executable&lt;br&gt;
Limitations and Problems&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Some apps need executable stack (e.g. LISP interpreters)&lt;/li&gt;
&lt;li&gt;Does not block more general overflow exploits&lt;/li&gt;
&lt;li&gt;Overflow on heap: overflow buffer next to func pointer&lt;/li&gt;
&lt;li&gt;Cannot make all the data segment non-executable&lt;/li&gt;
&lt;li&gt;More recent UNIX and MS windows emit dynamic code into program data for performance optimisations&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Stack Protection and Run-time Checking&lt;br&gt;
Many run-time checking techniques
&lt;ol&gt;
&lt;li&gt;Example:  StackGuard (WireX)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Run time tests for stack integrity&lt;/li&gt;
&lt;li&gt;Code generator for emitting code to set up and tear down functions&lt;/li&gt;
&lt;li&gt;Embeds “canaries” in stack frames and verify their integrity prior to function return&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Libsafe (Avaya Labs)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Dynamically loaded library&lt;/li&gt;
&lt;li&gt;Intercepts calls to  &lt;code&gt;strcpy (dest, src)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Validate sufficient space in current stack frame: |framepointer–dest| &amp;gt; strlen(src)&lt;/li&gt;
&lt;li&gt;If so, does strcpy. Otherwise, terminates application&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Address obfuscation (Stony Brook’03)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Encrypt return address on stack by XORing with random string. Decrypt just before returning from function&lt;/li&gt;
&lt;li&gt;Attacker needs decryption key to set return address to desired value&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;PaX ASLR: Randomise location of libc&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Attacker cannot jump directly to exec function&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
