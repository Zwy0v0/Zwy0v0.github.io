{
    "version": "https://jsonfeed.org/version/1",
    "title": "null â€¢ All posts by \"è¯¾ç¨‹ç¬”è®°\" category",
    "description": "ğŸŒ¸",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/course/C-language-basics-and-Computer-memory/",
            "url": "http://example.com/course/C-language-basics-and-Computer-memory/",
            "title": "C language basics and Computer memory",
            "date_published": "2024-10-24T11:00:05.000Z",
            "content_html": "<h1 id=\"C language basics\" class=\"active\"><a class=\"anchor\"  href=\"#C language basics\">#</a>C language basics</h1>\n<h2 id=\"input/output\" class=\"active\"><a class=\"anchor\"  href=\"#input/output\">#</a> input/output</h2>\n\n<ol>\n<li>To print output to the terminal screen:</li>\n</ol>\n<ul>\n<li>printf(â€œHello\\nâ€);</li>\n<li>printf(â€œHello %sâ€, â€œhaxorâ€);  &#x2F;&#x2F; using a format string</li>\n</ul>\n<ol start=\"2\">\n<li>To get input from the user:</li>\n</ol>\n<ul>\n<li>scanf(â€œ%dâ€, &amp;number);</li>\n</ul>\n <figure class=\"highlight c\"><figcaption><span>Input/output format symbols</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test\\n&quot;</span>);   <span class=\"comment\">// `\\n`:  Carriage return/new line</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test %d&quot;</span>, <span class=\"number\">123</span>);  <span class=\"comment\">//`%d`:  Decimal value</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test %s&quot;</span>, <span class=\"string\">&quot;123&quot;</span>);  <span class=\"comment\">//`%s`:  String value</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;test %x&quot;</span>, <span class=\"number\">0x123</span>);  <span class=\"comment\">//`%x`:  Hex value</span></span><br></pre></td></tr></table></figure>\n\n <figure class=\"highlight c\"><figcaption><span>C Program takes command-line arguments</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//meet.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\">greeting(<span class=\"type\">char</span> *temp1, <span class=\"type\">char</span> *temp2) <span class=\"comment\">// greeting function to say hello</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">400</span>];  <span class=\"comment\">// string variable to hold the name</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(name, temp2);  <span class=\"comment\">// copy function argument to name</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello %s %s\\n&quot;</span>, temp1, name);  <span class=\"comment\">// print out the greeting</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[]) <span class=\"comment\">// note the format for arguments</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    greeting(argv[<span class=\"number\">1</span>], argv[<span class=\"number\">2</span>]);  <span class=\"comment\">// call function, pass title &amp; name</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Bye %s %s\\n&quot;</span>, argv[<span class=\"number\">1</span>], argv[<span class=\"number\">2</span>]);  <span class=\"comment\">// say â€œbye&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Compiling C programs\" class=\"active\"><a class=\"anchor\"  href=\"#Compiling C programs\">#</a> Compiling C programs</h2>\nCompiling C programs(Linux) Using gcc\n\n<ol>\n<li><p>To compile our <code>meet.c</code> program, type</p>\n <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$gcc</span> -o meet meet.c</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Then to execute the new program, type</p>\n <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./meet zz</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Commonly used gcc flags</p>\n</li>\n</ol>\n<ul>\n<li>-o <filename>: produces compiled binary file with filename (a.out by default).</li>\n<li>-S: produces assembly code in a file; saved with a .s extension</li>\n<li>-g, -ggdb: produces extra debugging information for gdb (GNU debugger)</li>\n<li>-c: compiles without linking; produces object files with an .o extension</li>\n<li>Check out manual by using: man gcc</li>\n</ul>\n<ol start=\"4\">\n<li>32-bit vs 64-bit compilation</li>\n</ol>\n<ul>\n<li>To compile into 32-bit binaries: <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$gcc</span> -m32 hello.c -o hello</span><br></pre></td></tr></table></figure></li>\n<li>install a standard library of  <figure class=\"highlight bash\"><figcaption><span>OvO</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$sudo</span> apt install gcc-multilib </span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"C vs C#\" class=\"active\"><a class=\"anchor\"  href=\"#C vs C#\">#</a> C vs C#</h2>\n\n<ol>\n<li>C# is type-safe</li>\n</ol>\n<ul>\n<li>Strong static type system + runtime checks (e.g. bounds, type casts) + automatic memory management</li>\n</ul>\n<ol start=\"2\">\n<li>C is type-unsafe</li>\n</ol>\n<ul>\n<li>Pointers + no runtime check (out-of-bound access, bad type casts), manual memory management<br>Runtime array bounds check in C#</li>\n</ul>\n<p>If the following C# code is executed on .NET:<br> <figure class=\"highlight c#\"><figcaption><span>(â—Ë‡âˆ€Ë‡â—)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"> arr[<span class=\"number\">10</span>] = <span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure><br>An exception will be raised at runtime!</p>\n<p>The length of the array is recorded and checked by the runtime</p>\n<ul>\n<li>The length of an array is fixed once created</li>\n</ul>\n<p>No runtime array bounds check in C, If the same C code is executed:<br> <figure class=\"highlight c\"><figcaption><span>(â—Ë‡âˆ€Ë‡â—)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\"> arr[<span class=\"number\">10</span>] = <span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure><br>No error, result in a silent buffer overflow!</p>\n<ul>\n<li>Unexpected behaviours such as mysterious crashes depending on what was overwritten</li>\n<li>Attackers may exploit this if they can control the overwritten data</li>\n</ul>\n<ol start=\"3\">\n<li>Automatic memory management in C#</li>\n</ol>\n<p>Programmers do not write code to perform memory management tasks<br>Garbage collector manages the allocation and release of memory<br>C# has no common memory problems such as buffer overflow</p>\n<ol start=\"4\">\n<li>C# strings</li>\n</ol>\n<p>C# strings are <code>objects</code> of the <code>String</code> class</p>\n<ul>\n<li>Similar to an array of chars, but immutable</li>\n<li>The length is stored on the object for bounds checks at runtime</li>\n</ul>\n<p>All string manipulation operations do not modify the original string</p>\n<ul>\n<li>A new string is created upon modification</li>\n<li>For example, <code>str.Trim()</code> returns a new string</li>\n</ul>\n<ol start=\"5\">\n<li>C strings</li>\n</ol>\n<p>C strings are arrays of characters</p>\n<ul>\n<li>Terminated by and including the first occurrence of the null character <code>\\0</code></li>\n</ul>\n<p>String length is not automatically tracked</p>\n<ul>\n<li>It is determined by the number of bytes (character) preceding the null character. </li>\n<li>The memory required to store a string is the number of characters plus one</li>\n</ul>\n<p>A string can be manipulated just like any other arrays</p>\n<ul>\n<li>We usually use some built-in string functions in C libraries <figure class=\"highlight c\"><figcaption><span>copy one string to another</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span>    <span class=\"comment\">// use string library     </span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;Hello, Z&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(str2, str1);  <span class=\"comment\">// copy each character in str1 into str2</span></span><br></pre></td></tr></table></figure>\n The function <code>strcpy</code> copies each character in the source string (a series of characters ending with and including a null character) into the destination string <figure class=\"highlight c\"><figcaption><span>To compare two strings</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"> <span class=\"type\">char</span> str2[] = <span class=\"string\">&quot;haxor&quot;</span>;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(str1, str2) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Strings are the same.\\n&quot;</span>);</span><br><span class=\"line\"> <span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Strings are different.\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n This code prints out: Strings are different.<br> Note that the function <code>strcmp()</code> does not return a <code>boolean</code> result</li>\n<li>Zero represents false, anything else represents true</li>\n<li>No <code>boolean</code> type in C language prior to C99</li>\n</ul>\n<ol start=\"6\">\n<li><strong>Other common string functions</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQ19Qcm9ncmFtbWluZy9TdHJpbmdfbWFuaXB1bGF0aW9u\">More can be found</span><br> <code>strlen</code>: gets the length of a string<br> <code>strncpy</code>: copies one string to another with a bound<br> <code>strcat</code>, <code>strncat</code>: string concatenation<br> <code>gets</code>, <code>fgets</code>: receives input into a string</li>\n</ol>\n<h2 id=\"C strings is error prone\" class=\"active\"><a class=\"anchor\"  href=\"#C strings is error prone\">#</a>C strings is error prone</h2>\n\n<ol>\n<li>Common string manipulation errors:</li>\n</ol>\n<ul>\n<li>Buffer errors</li>\n<li>Heap errors</li>\n<li>Outâ€byâ€bound errors</li>\n<li>Integer overflows</li>\n<li>Other memory, pointer and type errors</li>\n</ul>\n<p><strong>When data is copied from an unbounded source to a fixedâ€length sink</strong><br> <figure class=\"highlight c\"><figcaption><span>Unbounded string copy</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> \t<span class=\"type\">char</span> username[<span class=\"number\">8</span>];</span><br><span class=\"line\"> \t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please enter your username:&quot;</span>);</span><br><span class=\"line\"> \tgets(username);</span><br><span class=\"line\"> \t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Your username is %s\\n&quot;</span>, username);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>Use of <code>gets()</code> Function</li>\n</ul>\n<p>The function <code>gets()</code> reads input from the user into a buffer, but it does not check the length of the input against the bufferâ€™s size.<br>In this code, the <code>username</code> array is only 8 bytes long. However, <code>gets()</code> allows users to enter an input of any length, which means it can write beyond the 8 bytes allocated for <code>username</code>.<br>This can cause a buffer overflow, which can lead to memory corruption, unexpected behavior, or even security vulnerabilities where attackers can execute arbitrary code.</p>\n<ul>\n<li>Fixed-Length Buffer</li>\n</ul>\n<p>The username array is declared to have a size of 8, but we need to reserve one byte for the null-terminator <code>\\0</code>, which marks the end of the string.<br>This means only 7 characters can safely be stored in the username buffer.<br>If the input exceeds this limit, it will overflow into adjacent memory, potentially causing the program to crash or behave unpredictably.<br> <figure class=\"highlight c\"><figcaption><span>Unbounded string copy(fixed)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> username[<span class=\"number\">8</span>];  <span class=\"comment\">// Buffer limited to 8 bytes</span></span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please enter your username:&quot;</span>);</span><br><span class=\"line\">    fgets(username, <span class=\"keyword\">sizeof</span>(username), <span class=\"built_in\">stdin</span>);  <span class=\"comment\">// Limit input size to prevent overflow</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Your username is %s\\n&quot;</span>, username);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">// Standard return type</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>Better string functions from libraries</strong><br> Should use functions that restrict the number of bytes for safer programming</p>\n<ul>\n<li>Use <code>fgets()</code>, instead of <code>gets()</code></li>\n<li>Use <code>strncpy()</code>, instead of <code>strcpy()</code></li>\n<li>Use <code>strncat()</code>, instead of <code>strcat()</code></li>\n<li>Use <code>snprintf()</code>, instead of instead of <code>sprintf()</code></li>\n</ul>\n<p><strong>Nullâ€termination errors</strong><br> <figure class=\"highlight c\"><figcaption><span>Nullâ€termination errors</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr, <span class=\"string\">&quot;0123456789&quot;</span>, <span class=\"keyword\">sizeof</span>(arr));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, arr);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>The array is not properly terminated by a null character! </p>\n<ul>\n<li>When there is no null character among the first n character of the source, the string placed in the<br>destination will not be null-terminated!<br>The <code>printf()</code> call prints out all bytes as character till reaching a null!</li>\n</ul>\n<p>To test out, letâ€™s add another array:<br> <figure class=\"highlight c\"><figcaption><span>Nullâ€termination errors</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr2[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr, <span class=\"string\">&quot;0123456789&quot;</span>, <span class=\"keyword\">sizeof</span>(arr));</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr2, <span class=\"string\">&quot;9876543210&quot;</span>, <span class=\"keyword\">sizeof</span>(arr2));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, arr);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br> The program will print out 01234567899876543210<br> Where the length of source string is the same or greater than the length of target string</p>\n<ul>\n<li>The source string gets truncated</li>\n<li>The target string may not be properly terminated by null!</li>\n</ul>\n<p> How can we fix it?<br> Manually add a null character at the end of the target string:<br> <figure class=\"highlight c\"><figcaption><span>Nullâ€termination errors(fixed)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> arr[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strncpy</span>(arr, <span class=\"string\">&quot;0123456789&quot;</span>, <span class=\"keyword\">sizeof</span>(arr)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tarr[<span class=\"keyword\">sizeof</span>(arr)<span class=\"number\">-1</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, arr);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br>The function char <code>*fgets(char *str, int n, FILE *stream)</code> reads <code>(n-1)</code> characters from the specific stream plus the final null character</p>\n<h1 id=\" Computer memory\" class=\"active\"><a class=\"anchor\"  href=\"# Computer memory\">#</a> Computer memory</h1>\n\n<h2 id=\" Intel x86 (32-bit)\" class=\"active\"><a class=\"anchor\"  href=\"# Intel x86 (32-bit)\">#</a> Intel x86 (32-bit)</h2>\n\n<ol>\n<li>von Neumann architecture</li>\n</ol>\n<ul>\n<li><p>Central processing unit (CPU) executes code </p>\n</li>\n<li><p>Main memory of the system (RAM) stores all data and code</p>\n</li>\n<li><p>Input&#x2F;output system (I&#x2F;O) interfaces with devices such as hard drives, keyboards, and monitors</p>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/24/671a56f0c953f.png\" alt=\"img\"></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>CPU</li>\n</ol>\n<p>The <strong>control unit</strong> gets instructions to execute from RAM using the instruction pointer, which stores the address of the instruction to execute<br><strong>Registers</strong> are the CPUâ€™s basic data storage units and are often used to save time so that the CPU doesnâ€™t need to access RAM. </p>\n<p>åœ¨ 32 ä½ x86 æ¶æ„ä¸­ï¼Œä¸»è¦çš„é€šç”¨å¯„å­˜å™¨åŒ…æ‹¬ï¼š</p>\n<ul>\n<li>EAX: ç´¯åŠ å™¨å¯„å­˜å™¨ï¼Œç”¨äºç®—æœ¯è¿ç®—å’Œè¿”å›å€¼ã€‚</li>\n<li>EBX: åŸºå€å¯„å­˜å™¨ï¼Œå¸¸ç”¨äºåŸºå€å­˜å–ã€‚</li>\n<li>ECX: è®¡æ•°å™¨å¯„å­˜å™¨ï¼Œå¸¸ç”¨äºå¾ªç¯å’Œç§»ä½æ“ä½œã€‚</li>\n<li>EDX: æ•°æ®å¯„å­˜å™¨ï¼Œç”¨äº I&#x2F;O æ“ä½œå’Œä¹˜é™¤æ³•ã€‚</li>\n<li>ESI: æºç´¢å¼•å¯„å­˜å™¨ï¼Œå¸¸ç”¨äºæŒ‡å‘å†…å­˜æ•°æ®æºã€‚</li>\n<li>EDI: ç›®æ ‡ç´¢å¼•å¯„å­˜å™¨ï¼Œå¸¸ç”¨äºæŒ‡å‘å†…å­˜æ•°æ®ç›®æ ‡ã€‚</li>\n<li>EBP: åŸºå€æŒ‡é’ˆå¯„å­˜å™¨ï¼Œç”¨äºæ ˆå¸§åŸºå€æŒ‡é’ˆã€‚</li>\n<li>ESP: æ ˆæŒ‡é’ˆå¯„å­˜å™¨ï¼ŒæŒ‡å‘å½“å‰æ ˆé¡¶</li>\n</ul>\n<p>The <strong>Arithmetic Logic Unit (ALU)</strong> executes an instruction fetched from RAM and places the results in registers or memory</p>\n<p>CPU runs a program by fetching and executing each instruction</p>\n<h2 id=\"Programs in the main memory\" class=\"active\"><a class=\"anchor\"  href=\"#Programs in the main memory\"> #</a>  Programs in the main memory</h2>\n\n<p> Processes are programs loaded into memory, broken into small sections</p>\n<ul>\n<li><p>.text section</p>\n</li>\n<li><p>.data section</p>\n</li>\n<li><p>.bss section</p>\n</li>\n<li><p>Heap section</p>\n</li>\n<li><p>Stack section</p>\n</li>\n<li><p>Environment&#x2F;Arguments section</p>\n<p><img data-src=\"https://img.picui.cn/free/2024/10/24/671a56f09cb3d.png\" alt=\"img\"></p>\n</li>\n</ul>\n<ol>\n<li>.text section</li>\n</ol>\n<p>Correspond to the .text portion of the binary executable file. </p>\n<p>Contain the machine instructions to get the task done</p>\n<ol start=\"2\">\n<li>.data section</li>\n</ol>\n<p>Store global initialised variables such as:</p>\n<ul>\n<li>int a &#x3D; 0;</li>\n</ul>\n<ol start=\"3\">\n<li>.bss section</li>\n</ol>\n<p>Store global uninitialised variables such as:</p>\n<ul>\n<li>int a;</li>\n</ul>\n<ol start=\"4\">\n<li>Heap section</li>\n</ol>\n<p>Store dynamically allocated variables</p>\n<ul>\n<li>Contain the pre-existing value of that memory</li>\n</ul>\n<p>Grows from the lower-addressed memory to the higher-addressed memory</p>\n<ul>\n<li>int *I &#x3D; malloc (sizeof (int));</li>\n</ul>\n<ol start=\"5\">\n<li>Stack section</li>\n</ol>\n<p>Keep track of function calls (recursively)</p>\n<p>Grow from the higher-addressed memory to the lower-addressed memory</p>\n<p>Local variables are in the stack section</p>\n<ol start=\"6\">\n<li>Environment&#x2F;Arguments section</li>\n</ol>\n<p>Store a copy of system-level variables that may be required by the process</p>\n<ul>\n<li>For example, path, shell name, hostname, etc.</li>\n</ul>\n<p>Command-line arguments are stored in this area.</p>\n<h2 id=\" Buffers\" class=\"active\"><a class=\"anchor\"  href=\"# Buffers\">#</a> Buffers</h2>\n\n<p> A storage place used to receive and hold data until it can be handled by a process<br> Each process can have its own set of buffers</p>\n<ul>\n<li>E.g. memory allocated within the .data or .bss section of the processâ€™s memory<br> Buffer is of <strong>fixed length once allocated</strong>.</li>\n<li>Hold any predefined type of data</li>\n</ul>\n<h2 id=\" Pointers\" class=\"active\"><a class=\"anchor\"  href=\"# Pointers\">#</a> Pointers</h2>\n\n<p>Pointers hold the address of other pieces of memory</p>\n<ul>\n<li>Their size is fixed of 4 bytes for 32-bit memory address</li>\n</ul>\n<p>C string can be written as a pointer to character:</p>\n<ul>\n<li>char * str; </li>\n<li>int * point1;</li>\n</ul>\n<p>C#â€™s reference types implicitly use pointers<br>Use dereference to read the value inside the memory address pointed to by the pointer:</p>\n<ul>\n<li>printf(â€œ%dâ€, *point1);</li>\n</ul>\n<p>The <code>*</code> symbol dereferences the pointer called point1 and displays the value of the integer using the <code>printf()</code> function</p>\n<ul>\n<li>The type of <code>point1</code> is a pointer</li>\n<li>The type of <code>*point1</code> is an integer <figure class=\"highlight c\"><figcaption><span>Putting the pieces of memory together</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ind = <span class=\"number\">5</span>;                     <span class=\"comment\">// integer stored in .data (initialized)</span></span><br><span class=\"line\"> <span class=\"type\">char</span> *str;                       <span class=\"comment\">// string pointer stored in .bss (uninitialized)</span></span><br><span class=\"line\"> <span class=\"type\">int</span> nothing;                     <span class=\"comment\">// integer stored in .bss (uninitialized)</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">fun</span><span class=\"params\">(<span class=\"type\">int</span> c)</span> </span><br><span class=\"line\">&#123;                                              </span><br><span class=\"line\"> \t<span class=\"type\">int</span> i = c;                                  <span class=\"comment\">// stored in stack section</span></span><br><span class=\"line\"> \tstr = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">10</span> * <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>));    <span class=\"comment\">// reserves 10 characters in heap region </span></span><br><span class=\"line\"> \t<span class=\"built_in\">strncpy</span>(str, <span class=\"string\">&quot;abcde&quot;</span>, <span class=\"number\">5</span>);                   <span class=\"comment\">// copies &quot;abcde&quot; into str</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tfun(<span class=\"number\">1</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n",
            "tags": [
                "C language",
                "Linux",
                "software security"
            ]
        }
    ]
}